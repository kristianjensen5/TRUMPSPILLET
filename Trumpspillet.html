<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gr√∏nlandssatire ‚Äì TrumpV2</title>
<style>
  html,body{margin:0;height:100%;background:#dff4ff;color:#111;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100%;height:100%;touch-action:none}
  .ui{
    position:fixed;left:12px;bottom:12px;z-index:10;
    background:rgba(0,0,0,.7);color:#fff;padding:12px 14px;border-radius:12px;font-size:13px;line-height:1.4;
    box-shadow:0 2px 8px rgba(0,0,0,.4);backdrop-filter:blur(4px);max-width:320px;
    display:flex;flex-direction:column;gap:10px;transition:background 0.2s ease,box-shadow 0.2s ease,padding 0.2s ease
  }
  .ui.collapsed{padding:10px 12px;gap:6px;background:rgba(0,0,0,.55);box-shadow:0 1px 3px rgba(0,0,0,.35)}
  .help-toggle{
    appearance:none;border:none;border-radius:999px;padding:6px 10px;background:rgba(255,255,255,.15);
    color:#fff;font:600 12px system-ui;letter-spacing:.02em;cursor:pointer;display:inline-flex;align-items:center;gap:6px;
    align-self:flex-start;box-shadow:inset 0 0 0 1px rgba(255,255,255,.15);
    transition:background 0.2s ease,transform 0.2s ease,box-shadow 0.2s ease
  }
  .help-toggle:hover,.help-toggle:focus{background:rgba(255,255,255,.25);box-shadow:inset 0 0 0 1px rgba(255,255,255,.35)}
  .help-toggle:focus{outline:none}
  .help-toggle:active{transform:scale(0.97)}
  .help-panel{display:flex;flex-direction:column;gap:6px}
  .ui.collapsed .help-panel{display:none}
  .ui kbd{background:rgba(255,255,255,.18);padding:0 .4em;border-radius:6px}
  .notice{
    position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);color:#fff;
    padding:6px 10px;border-radius:8px;font-size:12px
  }
  .hud{
    position:fixed;right:16px;top:24px;z-index:10;display:flex;flex-direction:column;align-items:flex-end;gap:8px;
    color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.45)
  }
  .chip{display:flex;align-items:center;gap:6px;font-size:13px;font-weight:600;color:inherit}
  .chip canvas{display:block}
  .life-chip{font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,.55)}
  .inv{
    position:fixed;right:16px;top:200px;z-index:9;
    background:rgba(0,0,0,.72);color:#fff;border-radius:12px;padding:10px 8px;display:flex;flex-direction:column;gap:8px;align-items:center;
    max-height:min(70vh, 520px);overflow-y:auto;backdrop-filter:blur(4px);
    box-shadow:0 3px 10px rgba(0,0,0,.35)
  }
  .inv.hidden{display:none}
  .slot{
    width:70px;height:64px;border-radius:10px;background:rgba(255,255,255,.08);
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;padding:6px 8px;
    box-sizing:border-box;overflow:hidden;flex-shrink:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.08)
  }
  .slot span{font-size:10px;opacity:.9;text-align:center;line-height:1.1;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b{font-size:11px;text-align:center;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b, .slot span{display:block;text-shadow:0 1px 1px rgba(0,0,0,.5)}
  .slot.empty{background:rgba(255,255,255,.05);border:1px dashed rgba(255,255,255,.28);box-shadow:none}
  .slot canvas{display:block;margin:0 auto;}
  .areas{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:10;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;max-width:90vw}
  .pill{background:rgba(0,0,0,.7);color:#fff;border-radius:12px;padding:6px 12px;font-size:13px;font-weight:500;white-space:nowrap;box-shadow:0 2px 4px rgba(0,0,0,.3)}
  .hint-label{display:none;font-size:12px;opacity:.85}
  .ui.collapsed .hint-label{display:block}
  @media (prefers-reduced-motion: reduce){ * { animation: none !important; transition: none !important; } }
  @media (pointer: coarse){ .ui{font-size:12px} }
  
  /* 80s Retro Intro Screen */
  .intro-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
    /* Replaced purple gradient with warm cream background */
    background: #efe8d2;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    font-family: 'Courier New', monospace; color: #1a1a1a; text-align: center;
    animation: scanlines 2s linear infinite; padding: 20px; box-sizing: border-box;
    gap: 20px;
  }
  @keyframes scanlines {
    0% { background-position: 0 0; }
    100% { background-position: 0 4px; }
  }
  .intro-title {
    font-size: clamp(24px, 8vw, 48px); font-weight: 800; 
    color: #141414;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5), 0 2px 4px rgba(0,0,0,0.2);
    letter-spacing: 1px; margin: 0;
    width: 100%; text-align: center;
  }
  .intro-subtitle {
    font-size: clamp(14px, 4vw, 20px); color: #2a2a2a; 
    text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    opacity: 0.95;
    max-width: 90%; line-height: 1.5; margin: 0;
    width: 100%; text-align: center;
  }
  @keyframes glow {
    from { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 40px #00ffff; }
    to { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00ffff; }
  }
  .intro-prompt {
    font-size: clamp(14px, 3vw, 18px); color: #1f1f1f; 
    text-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 2px 3px rgba(0,0,0,0.2);
    animation: blinkGlow 1.2s ease-in-out infinite; margin: 0;
    width: 100%; text-align: center; font-weight: 700;
    letter-spacing: 1px;
  }
  @keyframes blinkGlow {
    0%, 40% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
    50%, 90% { 
      opacity: 0.4; 
      text-shadow: 0 0 2px #ff00ff, 0 0 5px #ff00ff;
      transform: scale(0.98);
    }
    100% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
  }
  .intro-button {
    appearance: none; border: 2px solid #2b2b2b; background: rgba(0,0,0,.06);
    color: #1e1e1e; font-family: 'Courier New', monospace; font-weight: 800;
    padding: 10px 18px; border-radius: 10px; cursor: pointer;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    box-shadow: 0 0 0 0 rgba(0,0,0,0);
    transition: transform .08s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
  }
  .intro-button:hover { background: rgba(0,0,0,.1); border-color:#1e1e1e; }
  .intro-button:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,0,0,.12); }
  .intro-button:active { transform: scale(0.98); background: rgba(0,0,0,.15); }

  /* Override the intro canvas border to match darker UI */
  #intro-canvas { border-color: #3a3a3a !important; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="ui collapsed" id="help-card">
  <button id="help-toggle" class="help-toggle" type="button" aria-expanded="false" aria-controls="help-panel">
    ‚ùî Vis styring
  </button>
  <div class="help-panel" id="help-panel" hidden>
    <div>‚Üê‚Üì‚Üí bev√¶gelse ¬∑ <kbd>Space</kbd>/<kbd>‚Üë</kbd> hop ¬∑ <kbd>E</kbd> interag√©r ¬∑ <kbd>I</kbd> info ¬∑ <kbd>B</kbd> inventar ¬∑ <kbd>T</kbd> tweet</div>
    <small style="opacity: 0.8;"><kbd>R</kbd> reset ¬∑ <kbd>N</kbd> non-violent ¬∑ <kbd>F</kbd> FPS ¬∑ <kbd>K</kbd> debug</small>
  </div>
  <span class="hint-label" aria-hidden="true">E: interag√©r</span>
  <!-- .hint-label is used to keep wording centralized if you localize -->
  
</div>
<div id="hud" class="hud"></div>
<div id="inv" class="inv" role="region" aria-label="Inventar" aria-hidden="false"></div>
<div id="areas2" class="areas"></div>
<div id="intro" class="intro-screen">
  <canvas id="intro-canvas" width="600" height="400" style="image-rendering: pixelated; border: 2px solid #00ffff; background: #000022; max-width: min(90vw, 600px); height: auto; flex-shrink: 0;"></canvas>
  <div class="intro-title">Try not to destroy the world Donald</div>
  <div class="intro-subtitle">Being the best president ever is tough. Bet YOU can't handle it</div>
  <div class="intro-prompt" aria-live="polite">Tryk Enter eller klik Start for at begynde</div>
  <button id="start-btn" class="intro-button" type="button" aria-label="Start spil">Start</button>
</div>


<!-- Lottie (Bodymovin) for AE JSON rendering -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
<script>
  (() => {
    // ---------- Konfiguration ----------
    const CFG = {
    NON_VIOLENT: false,
    SPEED: 210,
    INTERACT_DIST: 48,
    BUBBLE_TIME: 2000,
    SCALE: 1,
    SHOW_PULSE: false,
    DEBUG: false, // Toggle for debug info
    SHOW_FPS: false // Toggle for FPS counter
  };
  
  // ---------- Game Constants ----------
  const GAME_CONSTANTS = {
    // Character dimensions and positioning
    CHAR: {
      WIDTH: 24,
      HEIGHT: 44,
      BEAR_WIDTH: 70,
      BEAR_HEIGHT: 40
    },
    
    // UI and bubble positioning
    UI: {
      BUBBLE_FONT_SIZE: 12,
      BUBBLE_LINE_HEIGHT: 16,
      BUBBLE_PADDING: 8,
      BUBBLE_TAIL_OFFSET: 18,
      BUBBLE_Y_OFFSET: 46,
      BUBBLE_TAIL_Y: 30,
      PULSE_DISTANCE: 110,
      INTERACTION_FEEDBACK_SIZE: 3,
      CLICK_DISTANCE: 100
    },
    
    // World positioning (base values before scaling)
    WORLD: {
      FLOOR_HEIGHT: 120,
      PLAYER_START_X: 160,
      HELI_Y_OFFSET: 18,
      GREENLAND: {
        MINE_X: 520,
        RIG_X: 380,
        HELI_X: 160,
        BEAR_X: 760,
        METTE_X: 980
      },
      OVAL: {
        DOOR_X: 160,
        AIDE_X: 380,
        HELI_X: 160,
        YES_X: 820
      },
      KREMLIN: {
        DOOR_X: 160,
        PUTIN_X: 380,
        HELI_X: 160
      }
    },
    
    // Physics and movement
    PHYSICS: {
      GRAVITY: 1400,
      BEAR_SPEED: 100,
      BEAR_ANGRY_SPEED: 300,
      BEAR_CHASE_DISTANCE: 30,
      BEAR_ATTACK_CHANCE: 0.02,
      KNOCKBACK_FORCE: 280,
      HORIZONTAL_KNOCKBACK: 60,
      SCREEN_MARGIN: 40,
      BOUNCE_DAMPING: 0.3,
      CHASE_DAMPING: 0.96,
      NORMAL_DAMPING: 0.92,
      GROUND_DAMPING_CHASE: 0.95,
      GROUND_DAMPING_NORMAL: 0.85
    },
    
    // Coins and collectibles positioning
    COINS: {
      GREENLAND_POSITIONS: [
        {x: 250, y: -35},
        {x: 450, y: -45},
        {x: 650, y: -40},
        {x: 850, y: -25}
      ],
      OVAL_POSITIONS: [
        {x: 300, y: -30},
        {x: 500, y: -35},
        {x: 700, y: -25}
      ],
      KREMLIN_POSITIONS: [
        {x: 280, y: -30},
        {x: 480, y: -35},
        {x: 680, y: -25},
        {x: 880, y: -40}
      ]
    },
    
    // Animation and effects
    ANIMATION: {
      BLINK_DURATION: 150,
      NOD_SPEED: 0.8,
      PRESS_EFFECT_DURATION: 200,
      SHAKE_AMPLITUDE: 8,
      SHAKE_DURATION: 600,
      FEEDBACK_DURATION: 500,
      WATER_RISE_SPEED: 480, // frames to rise full height
      EXPLOSION_DELAY: 2000,
      INTRO_UPDATE_MS: 100
    },
    
    // Game timing and scoring
    GAME: {
      TOTAL_TIME_MS: 6 * 60 * 1000, // 6 minutes
      NEEDED_PER_AREA: 3,
      RELATIONSHIP_THRESHOLDS: {
        TRUST_LOW: 30,
        RESPECT_LOW: 30,
        FEAR_HIGH: 70
      }
    },
    
    // Performance and rendering
    PERFORMANCE: {
      TARGET_FPS: 60,
      MIN_FPS: 30,
      MOUSE_THROTTLE_MS: 16,
      MAX_BORDER_POINTS: 200,
      PARTICLE_LIMITS: {
        BLOOD: 100,
        SPARKS: 50,
        DOWNWASH: 30,
        OIL: 40,
        FLAME: 25
      }
    }
  };
  
  // ---------- Scene System ----------
  class Scene {
    constructor(name) {
      this.name = name;
      this.objects = [];
      this.characters = [];
      this.initialized = false;
    }
    
    init() {
      if (this.initialized) return;
      this.reset();
      this.initialized = true;
    }
    
    reset() {
      // Override in subclasses
    }
    
    update(dt) {
      // Override in subclasses
      this.characters.forEach(char => {
        if (char.update) char.update(dt);
      });
    }
    
    draw(ctx) {
      // Override in subclasses
      this.objects.forEach(obj => {
        if (obj.draw) obj.draw(ctx);
      });
      this.characters.forEach(char => {
        if (char.draw) char.draw(ctx);
      });
    }
    
    handleClick(x, y) {
      // Override in subclasses
      return false; // Return true if click was handled
    }
    
    handleInteraction(obj) {
      // Override in subclasses  
      return false; // Return true if interaction was handled
    }
    
    getNearestObject(x, y, maxDistance = GAME_CONSTANTS.UI.PULSE_DISTANCE) {
      let nearest = null;
      let nearestDist = maxDistance * CFG.SCALE;
      
      [...this.objects, ...this.characters].forEach(obj => {
        if (!obj.x || !obj.y) return;
        const dist = Math.hypot(x - obj.x, y - obj.y);
        if (dist < nearestDist) {
          nearest = obj;
          nearestDist = dist;
        }
      });
      
      return nearest ? { obj: nearest, dist: nearestDist } : null;
    }
  }
  
  // Scene Manager
  const SceneManager = {
    scenes: new Map(),
    currentScene: null,
    
    registerScene(scene) {
      this.scenes.set(scene.name, scene);
    },
    
    switchToScene(sceneName) {
      const scene = this.scenes.get(sceneName);
      if (!scene) {
        console.warn(`Scene '${sceneName}' not found`);
        return false;
      }
      
      this.currentScene = scene;
      scene.init();
      return true;
    },
    
    getCurrentScene() {
      return this.currentScene;
    },
    
    update(dt) {
      if (this.currentScene) {
        safeExecute(() => this.currentScene.update(dt), `Scene ${this.currentScene.name} update`);
      }
    },
    
    draw(ctx) {
      if (this.currentScene) {
        safeDraw(() => this.currentScene.draw(ctx), `Scene ${this.currentScene.name} draw`);
      }
    },
    
    handleClick(x, y) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleClick(x, y), `Scene ${this.currentScene.name} click`, false);
      }
      return false;
    },
    
    handleInteraction(obj) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleInteraction(obj), `Scene ${this.currentScene.name} interaction`, false);
      }
      return false;
    }
  };
  
  // Performance monitoring
  const PERF = {
    frameCount: 0,
    lastFpsUpdate: 0,
    fps: 0,
    renderTime: 0,
    particleCount: 0
  };
  
  // ---------- Graphics Configuration System ----------
  const GRAPHICS = {
    // Image cache for loaded custom graphics
    images: new Map(),
    loading: new Set(),
    
    // Configuration for custom graphics URLs
    config: {
      // Characters
      trump: null,           // URL for Trump sprite
      mette: null,          // URL for Mette sprite
      putin: null,          // URL for Putin sprite
      bear: null,           // URL for Bear sprite
      aide: null,           // URL for Aide sprite
      
      // Backgrounds
      greenland_bg: null,   // URL for Greenland background
      oval_bg: null,        // URL for Oval Office background  
      kremlin_bg: null,     // URL for Kremlin background
      
      // Objects
      helicopter: null,     // URL for helicopter sprite
      mine: null,           // URL for mine sprite
      rig: null,            // URL for oil rig sprite
      flag: null,           // URL for flag sprite
      phone: null,          // URL for phone sprite
      door: null,           // URL for door sprite
      gold_bar: null,       // URL for gold bar (coin) sprite
      dynamite: null,       // URL for dynamite item sprite
      yes_member: null,     // URL for praising group member sprite
      glacier: null,        // URL for glacier sprite
      birthday_art: null,   // URL for final 8-bit birthday drawing

      // Game Over art (per-cause or default)
      gameover_default: null,   // URL used if no cause-specific art provided
      gameover_ice: null,       // URL for ice/water failure
      gameover_nuke: null,      // URL for nuclear failure
      gameover_kremlin: null,   // URL for Kremlin caught failure
      gameover_epstein: null,   // URL for Epstein fail
      
      // Items
      tan_bottle: null,     // URL for tan bottle item
      maga_cap: null,       // URL for MAGA cap item
      golden_shoes: null,   // URL for gold sneakers item
      gold_statue: null,    // URL for gold statue item
      
      // Effects
      missile: null,        // URL for missile sprite
      explosion: null,      // URL for explosion effect
      
      // UI Elements
      inventory_bg: null,   // URL for inventory background
      button: null,         // URL for button sprite

      // Rendering options for specific assets
      birthday_art_fit: null, // 'cover' | 'contain' | 'height' (default 'contain')
      gameover_fit: null,     // 'cover' | 'contain' (default 'contain')

      // Optional localized titles/subtitles for game over causes
      // Example: gameover_title_nuke: 'Kaboom', gameover_subtitle_nuke: 'Maybe not push that button'
      // These are free-form config keys applied via the asset pack 'options'
    },
    
    // Load an image from URL and cache it
    loadImage(key, url) {
      if (!url) return null;
      if (this.images.has(key)) return this.images.get(key);
      if (this.loading.has(key)) return null;
      
      this.loading.add(key);
      const img = new Image();
      try {
        // Set crossOrigin only for remote http(s) URLs; avoid for data: and local/relative paths
        if (typeof url === 'string' && /^https?:/i.test(url)) {
          img.crossOrigin = 'anonymous'; // For CORS support on remote URLs
        }
      } catch(_){}
      
      img.onload = () => {
        this.images.set(key, img);
        this.loading.delete(key);
        if (CFG.DEBUG) console.log(`Loaded custom graphic: ${key}`);
      };
      
      img.onerror = () => {
        this.loading.delete(key);
        console.warn(`Failed to load custom graphic: ${key} from ${url}`);
      };
      
      img.src = url;
      return null; // Will be available on next frame
    },
    
    // Get cached image or load if needed
    getImage(key) {
      const url = this.config[key];
      if (!url) return null;
      return this.loadImage(key, url);
    },
    
    // Draw image if available, otherwise use fallback function
    drawOrFallback(ctx, key, fallbackFn, ...args) {
      const img = this.getImage(key);
      if (img && img.complete) {
        // Extract x, y from args for image drawing
        const [x, y] = args;
        return this.drawImage(ctx, img, x, y);
      } else {
        fallbackFn(...args);
        return false;
      }
    },
    
    // Draw image with proper scaling and positioning
    drawImage(ctx, img, x, y, width = null, height = null, centered = true) {
      if (!img || !img.complete) return false;
      
      const w = width || img.width * CFG.SCALE;
      const h = height || img.height * CFG.SCALE;
      const dx = centered ? x - w/2 : x;
      const dy = centered ? y - h/2 : y;
      
      ctx.drawImage(img, dx, dy, w, h);
      return true;
    },

    // Draw full-screen background if available (cover)
    drawBackground(ctx, key) {
      const url = this.config[key];
      if (!url) return false;
      const img = this.images.get(key);
      if (!(img && img.complete)) {
        this.loadImage(key, url);
        return false;
      }
      // Simple stretch to canvas size; callers can layer content atop
      ctx.drawImage(img, 0, 0, W, H);
      return true;
    },

    // Check if an image is loaded and ready
    imageReady(key){ const img = this.images.get(key); return !!(img && img.complete); },
    
    // Update configuration from external source
    updateConfig(newConfig) {
      Object.assign(this.config, newConfig);
      if (CFG.DEBUG) console.log('Updated graphics configuration:', this.config);
    },
    
    // Clear cache (useful for reloading graphics)
    clearCache() {
      this.images.clear();
      this.loading.clear();
    }
  };
  
  // Expose graphics system globally for external configuration
  window.GRAPHICS = GRAPHICS;
  
  // Convenience function for setting graphics URLs
  window.setGraphic = function(key, url) {
    if (GRAPHICS.config.hasOwnProperty(key)) {
      GRAPHICS.config[key] = url;
      if (CFG.DEBUG) console.log(`Set graphic ${key} to: ${url}`);
    } else {
      console.warn(`Unknown graphic key: ${key}. Available keys:`, Object.keys(GRAPHICS.config));
    }
  };
  
  // Function to set multiple graphics at once
  window.setGraphics = function(configObject) {
    GRAPHICS.updateConfig(configObject);
  };
  
  // Function to list all available graphic keys
  window.listGraphics = function() {
    if (CFG.DEBUG) console.log('Available graphics to customize:', Object.keys(GRAPHICS.config));
    return Object.keys(GRAPHICS.config);
  };

  // -------- Asset Pack Loader (single-file friendly) --------
  // Pack schema:
  // {
  //   images: { key: dataUrlOrHttpUrl, ... },
  //   svgs:   { key: "<svg ...>...</svg>", ... },
  //   lottie: { birthday_art: { ... JSON ... } }
  // }
  function svgToDataUrl(svgString){
    try { return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); }
    catch(_) { return 'data:image/svg+xml;utf8,' + encodeURIComponent(svgString); }
  }
  window.applyAssetPack = function(pack){
    if (!pack || typeof pack !== 'object') { console.warn('applyAssetPack: invalid pack'); return false; }
    const conf = {};
    if (pack.images && typeof pack.images === 'object'){
      for (const [k,v] of Object.entries(pack.images)){
        conf[k] = v; // supports data URLs or http(s) URLs
      }
    }
    // Optional generic options (non-image keys)
    if (pack.options && typeof pack.options === 'object'){
      for (const [k,v] of Object.entries(pack.options)){
        conf[k] = v;
      }
    }
    if (pack.svgs && typeof pack.svgs === 'object'){
      for (const [k,svg] of Object.entries(pack.svgs)){
        conf[k] = svgToDataUrl(String(svg||''));
      }
    }
    if (Object.keys(conf).length){
      GRAPHICS.updateConfig(conf);
      GRAPHICS.clearCache(); // ensure fresh loads on next draw
      // If a direct image is supplied for the final art, prefer it over Lottie
      if (conf.birthday_art) { try { setBirthdayLottieJSON(null); } catch(_){} }
    }
    if (pack.lottie && pack.lottie.birthday_art){
      try { setBirthdayLottieJSON(pack.lottie.birthday_art); } catch(e){ console.warn('Failed to set Lottie JSON from asset pack', e); }
    }
    if (CFG.DEBUG) console.log('Asset pack applied');
    return true;
  };
  window.applyAssetPackFromScript = function(id='asset-pack'){
    try {
      const el = document.getElementById(id);
      if (!el) return false;
      const json = JSON.parse(el.textContent||'{}');
      return window.applyAssetPack(json);
    } catch(e){ console.warn('applyAssetPackFromScript failed', e); return false; }
  };

  // Optional Lottie manager for the final art (requires lottie-web on window.bodymovin)
  const LOTTIE_ART = {
    json: null,
    anim: null,
    container: null,
    canvasEl: null,
    ready: false,
    targetW: 0,
    targetH: 0,
    ensure(){
      if (!window.bodymovin || !this.json) return false;
      if (this.anim) return true;
      // Create hidden container in DOM so lottie can manage its own canvas
      this.container = document.createElement('div');
      Object.assign(this.container.style, { position: 'absolute', left: '-99999px', top: '-99999px', width: '10px', height: '10px', pointerEvents: 'none' });
      document.body.appendChild(this.container);
      this.anim = window.bodymovin.loadAnimation({
        container: this.container,
        renderer: 'canvas',
        loop: false,
        autoplay: true,
        animationData: this.json,
        rendererSettings: { clearCanvas: true, preserveAspectRatio: 'none' }
      });
      this.ready = false;
      const readyFn = () => {
        this.canvasEl = this.container.querySelector('canvas');
        this.ready = !!this.canvasEl;
      };
      this.anim.addEventListener('DOMLoaded', readyFn);
      this.anim.addEventListener('complete', readyFn);
      return true;
    },
    resize(w, h){
      if (!this.ensure()) return false;
      if (this.targetW === w && this.targetH === h) return true;
      this.targetW = w; this.targetH = h;
      this.container.style.width = Math.max(1, Math.floor(w)) + 'px';
      this.container.style.height = Math.max(1, Math.floor(h)) + 'px';
      try { this.anim.resize(); } catch(_){}
      return true;
    }
  };
  window.setBirthdayLottieJSON = function(json){
    try { LOTTIE_ART.json = json; LOTTIE_ART.ready = false; if (LOTTIE_ART.anim){ LOTTIE_ART.anim.destroy(); LOTTIE_ART.anim = null; } } catch(_){}
  };

  // Helper to quickly preview final art source in new tab (PNG only)
  window.previewBirthdayArt = function(){
    try {
      const src = GRAPHICS?.config?.birthday_art;
      if (src && /^data:image\/(png|jpeg)/i.test(src)) {
        const win = window.open('about:blank', '_blank');
        if (!win) { alert('Popup blocked'); return false; }
        const doc = win.document;
        doc.open();
        doc.write('<!doctype html><title>PNG Preview</title><meta charset="utf-8"><style>html,body{margin:0;height:100%;display:grid;place-items:center;background:#fff}</style>');
        doc.write('<img alt="birthday_art" style="max-width:95vw;max-height:95vh;image-rendering:pixelated" src="'+src+'">');
        doc.close();
        return true;
      }
      console.warn('No embedded PNG/JPEG set for birthday_art');
      return false;
    } catch(e){ console.warn('previewBirthdayArt failed', e); return false; }
  }

  // Attempt to load birthday art JSON only if embedded inline
  try {
    const inline = document.getElementById('birthday-lottie-json');
    if (inline && inline.textContent) {
      try { const json = JSON.parse(inline.textContent); setBirthdayLottieJSON(json); if (CFG.DEBUG) console.log('Loaded inline birthday Lottie JSON'); }
      catch(e){ console.warn('Inline birthday JSON parse failed', e); }
    }
  } catch(_){}
  
  // 3) Finally, try to apply a comprehensive asset-pack if embedded
  try { applyAssetPackFromScript('asset-pack'); } catch(_){}
  try { document.addEventListener('DOMContentLoaded', ()=>{ try { applyAssetPackFromScript('asset-pack'); } catch(_){} }); } catch(_){}

  // Optional inline PNG/JPEG support: <img id="birthday-art-inline" src="data:image/png;base64,..." style="display:none">
  try {
    const imgEl = document.getElementById('birthday-art-inline');
    if (imgEl && imgEl.src && /^data:image\/(png|jpeg);base64,/.test(imgEl.src)) {
      setGraphic('birthday_art', imgEl.src);
    }
  } catch(_){}
  
  // Standard dimensions for graphics (at CFG.SCALE = 1)
  window.GRAPHICS_DIMENSIONS = {
    // Characters (width x height in pixels)
    trump: { width: 24, height: 44, description: 'Trump character sprite' },
    mette: { width: 24, height: 44, description: 'Mette character sprite' },
    putin: { width: 24, height: 44, description: 'Putin character sprite' },
    bear: { width: 60, height: 30, description: 'Polar bear sprite' },
    aide: { width: 24, height: 44, description: 'Aide character sprite' },
    
    // Objects
    helicopter: { width: 140, height: 40, description: 'Helicopter sprite (includes rotor)' },
    birthday_art: { width: 600, height: 800, description: 'Final 8-bit birthday drawing' },
    mine: { width: 40, height: 20, description: 'Mine entrance sprite' },
    rig: { width: 64, height: 80, description: 'Oil rig sprite' },
    flag: { width: 36, height: 64, description: 'Flag sprite (pole + flag)' },
    phone: { width: 16, height: 20, description: 'Phone sprite' },
    door: { width: 28, height: 80, description: 'Door sprite' },
    gold_bar: { width: 20, height: 12, description: 'Gold bar (coin) sprite' },
    dynamite: { width: 12, height: 24, description: 'Dynamite item sprite' },
    yes_member: { width: 24, height: 44, description: 'Yes-group member sprite' },
    glacier: { width: 120, height: 100, description: 'Glacier sprite (varies)' },
    
    // Items (inventory size)
    tan_bottle: { width: 16, height: 24, description: 'Tan bottle item' },
    maga_cap: { width: 20, height: 12, description: 'MAGA cap item' },
      golden_shoes: { width: 32, height: 20, description: 'Guldsneakers item' },
    gold_statue: { width: 18, height: 30, description: 'Gold statue item' },
    
    // Effects
    missile: { width: 20, height: 56, description: 'Nuclear missile sprite' },
    explosion: { width: 80, height: 80, description: 'Explosion effect sprite' },
    
    // Game over art (optional, cause-specific)
    gameover_default: { width: 600, height: 360, description: 'Game over art: default' },
    gameover_ice: { width: 600, height: 360, description: 'Game over art: ice/water' },
    gameover_nuke: { width: 600, height: 360, description: 'Game over art: nuclear' },
    gameover_kremlin: { width: 600, height: 360, description: 'Game over art: kremlin caught' },
    gameover_epstein: { width: 600, height: 360, description: 'Game over art: epstein fail' },
    gameover: { width: 600, height: 360, description: 'Game over art: generic alias' },
    
    // Backgrounds (full screen)
    greenland_bg: { width: 1200, height: 800, description: 'Greenland background (will be scaled to screen)' },
    oval_bg: { width: 1200, height: 800, description: 'Oval Office background (will be scaled to screen)' },
    kremlin_bg: { width: 1200, height: 800, description: 'Kremlin background (will be scaled to screen)' },
    
    // UI Elements
    inventory_bg: { width: 70, height: 60, description: 'Inventory slot background' },
    button: { width: 32, height: 16, description: 'Button sprite' }
  };
  
  // Function to get recommended dimensions
  window.getGraphicDimensions = function(key) {
    const dim = GRAPHICS_DIMENSIONS[key];
    if (dim) {
      if (CFG.DEBUG) console.log(`${key}: ${dim.width}x${dim.height}px - ${dim.description}`);
      return dim;
    } else {
      console.warn(`No dimensions defined for: ${key}`);
      return null;
    }
  };
  
  // Function to show all dimensions
  window.showAllDimensions = function() {
    if (CFG.DEBUG) {
      console.log('=== GRAPHICS DIMENSIONS GUIDE ===');
      Object.entries(GRAPHICS_DIMENSIONS).forEach(([key, dim]) => {
        console.log(`${key.padEnd(15)}: ${dim.width.toString().padEnd(4)}x${dim.height.toString().padEnd(4)}px - ${dim.description}`);
      });
    }
  };

  // ---------- Canvas ----------
  const cvs = document.getElementById('game');
  if (!cvs) {
    console.error('Canvas element "game" not found!');
    return;
  }
  const ctx = cvs.getContext('2d');
  if (!ctx) {
    console.error('2D context not supported!');
    return;
  }
  let currentCursor = 'default';
  function setCanvasCursor(cursor){
    const next = cursor || 'default';
    if (currentCursor !== next){
      try { cvs.style.cursor = next; } catch(_){}
      currentCursor = next;
    }
  }
  // Accessibility hint for screen readers
  try { cvs.setAttribute('aria-label','Spilomr√•de'); } catch(_){}
  let W=0,H=0,DPR=1, last=performance.now(), deltaTime=0;
  const TARGET_FPS = (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.TARGET_FPS) || 60;
  const MAX_DELTA = 1000 / ((GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MIN_FPS) || 30); // Cap at configured min FPS
  let skyGrad = null; // cached sky gradient
  // ambient clouds
  let CLOUDS = [];
  // Optional background image for border map (set via setMapImage(url))
  const MAP_IMG = new Image();
  let MAP_IMG_READY = false;
  function setMapImage(url){
    MAP_IMG_READY = false;
    MAP_IMG.onload = ()=>{ MAP_IMG_READY = true; };
    MAP_IMG.onerror = ()=>{ MAP_IMG_READY = false; };
    if (url) MAP_IMG.src = url;
  }

  function fit() {
    try {
      const oldScale = CFG.SCALE || 1;
      DPR = window.devicePixelRatio || 1;
      W = Math.round(innerWidth);
      H = Math.round(innerHeight);
      cvs.width = Math.round(W*DPR);
      cvs.height = Math.round(H*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      CFG.SCALE = Math.max(0.8, Math.min(1.4, W/1200));
      // cache gradient per size
      skyGrad = ctx.createLinearGradient(0,0,0,H);
      skyGrad.addColorStop(0,'#dff4ff');
      skyGrad.addColorStop(1,'#a7dfff');
      // Rescale world positions to new scale to avoid drift on resize
      const ratio = CFG.SCALE / oldScale;
      if (ratio && Math.abs(ratio-1) > 0.001) {
        try { rescaleAll(ratio); } catch(e){ if (CFG.DEBUG) console.warn('rescaleAll failed', e); }
      }
    } catch(err) {
      console.warn('Canvas resize failed:', err);
      // Fallback values
      W = W || 800;
      H = H || 600;
      CFG.SCALE = CFG.SCALE || 1;
    }
  }
  fit();
  addEventListener('resize', fit);

  // Rescale helpers for window resize
  function scaleProps(obj, props, r){ if (!obj) return; props.forEach(p=>{ if (typeof obj[p]==='number') obj[p]*=r; }); }
  function rescaleArray(arr, props, r){ if (!arr) return; arr.forEach(o=>scaleProps(o, props, r)); }
  function rescaleAll(r){
    // Player and ground anchor
    scaleProps(player, ['x','y','w','h'], r);
    player.y = H - world.floor; // stick to ground after resize
    // Greenland
    scaleProps(GL.mine, ['x','y'], r);
    scaleProps(GL.rig, ['x','y'], r);
    scaleProps(GL.heli, ['x','y'], r);
    scaleProps(GL.bear, ['x','y'], r);
    scaleProps(GL.mette, ['x','y'], r);
    if (GL.flag) scaleProps(GL.flag, ['x','y'], r);
    rescaleArray(GL.items, ['x','y'], r);
    rescaleArray(GL.glaciers, ['x','y'], r); // w/h are logical sizes
    rescaleArray(GL.coins, ['x','y'], r);
    // Oval
    scaleProps(OV.door, ['x','y'], r);
    scaleProps(OV.aide, ['x','y'], r);
    scaleProps(OV.heli, ['x','y'], r);
    scaleProps(OV.yes, ['x','y'], r);
    if (OV.buttons) OV.buttons.forEach(b=>scaleProps(b, ['x','y','w','h'], r));
    rescaleArray(OV.coins, ['x','y'], r);
    // Kremlin
    scaleProps(KR.door, ['x','y'], r);
    scaleProps(KR.putin, ['x','y'], r);
    scaleProps(KR.heli, ['x','y'], r);
    scaleProps(KR.camera, ['x','y'], r);
    rescaleArray(KR.statues, ['x','y'], r);
    rescaleArray(KR.coins, ['x','y'], r);
    // Ambient clouds and FX (best-effort)
    if (CLOUDS) CLOUDS.forEach(c=>{ scaleProps(c, ['x','y','w','h','vx'], r); });
  }

  // ---------- Input ----------
  const keys = new Set();
  let choiceOverlay = null; // {text, onKey(k)}
  let flagOverlay = null; // {flagType, startTime} - shows flag planted on Ukraine
  // Continue overlay state (voting machine or tweet-to-continue)
  let continueOverlay = null; // { mode:'voting'|'tweet', phase:'idle'|'spinning'|'done', start, nextAt, interval, inc, stepsLeft, idx, words, stopped, stopAt, stopAtTime, grantDone }
  function startContinueOverlay(mode='voting'){
    continueOverlay = {
      mode,
      phase: 'idle',
      start: nowMs(),
      // Slot-like decelerating steps
      interval: 80, // ms between changes at start
      inc: 36,      // increase per step (slows down)
      stepsLeft: 0, // idle until triggered
      nextAt: nowMs() + 80,
      words: ['DEMOCRAT','INDEPENDENT','REPUBLICAN','TRUMP'],
      idx: 0, // start at DEMOCRAT
      stopped: false,
      stopAt: 'TRUMP',
      stopAtTime: 0,
      grantDone: false
    };
    
    // Virtual canvas size for golf scene (fallback if external loaders aren't present)
    const VIRTUAL_W = window.VIRTUAL_W || 960, VIRTUAL_H = window.VIRTUAL_H || 540;
    window.VIRTUAL_W = VIRTUAL_W; window.VIRTUAL_H = VIRTUAL_H;
    GS.over = true;
    GS.overMode = 'continue';
  }
  function closeContinueOverlay(){ continueOverlay = null; }
  let tweetCount = 0;
  // Consolidated keydown handler for better performance
  addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    let handled = false;
    
    // Intro screen handling
    if (scene === 'intro') {
      if (k === 'enter' || e.code === 'Enter' || (k.length === 1 && k !== ' ' && k !== 'e')) { startGame(); handled = true; }
      if (handled) e.preventDefault();
      return;
    }
    
    // Game over screen handling
    if (GS.over && GS.overMode === 'epstein_success' && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      GS.over = false; GS.overMode = null; GS.overText = '';
      switchScene('greenland');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode === 'epstein_fail' && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      GS.over = false; GS.overMode = null; GS.overText = '';
      switchScene('greenland');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode && String(GS.overMode).startsWith('go_') && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      // Transition from cause art to Continue overlay (voting machine)
      startContinueOverlay('voting');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode === 'continue' && (k==='enter' || e.code==='Enter' || k==='t')){
      // If idle, start spinning; if done, respawn
      if (continueOverlay && continueOverlay.phase === 'idle'){
        continueOverlay.phase = 'spinning';
        continueOverlay.stepsLeft = 12 + Math.floor(Math.random()*6);
        continueOverlay.interval = 80; continueOverlay.inc = 32;
        continueOverlay.nextAt = nowMs() + continueOverlay.interval;
      } else if (continueOverlay && continueOverlay.phase === 'done'){
        GS.over = false; GS.overMode = null; GS.overText=''; GO.cause=null; closeContinueOverlay();
        switchScene('greenland');
      }
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && k === 'r' && e.shiftKey) {
      // Full game restart - go back to intro screen
      resetStateDefaults();
      inventory.length = 0; 
      collectedCoins = 0; // Reset coin counter
      player.goldBalance = 0;
      renderInv();
      player.baseSpeedMul = 1;
      player.goldenShoesOn = false;
      updatePlayerSpeedMul();
      player.tanLevel = 0; 
      player.capOn = false; 
      player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
      renderHUD();
      GS.over = false;
      GS.overText = '';
      scene = 'intro';
      document.getElementById('intro').style.display = 'block';
      handled = true;
    if (handled) e.preventDefault();
    return;
  }
  
    if (choiceOverlay) {
      if (k==='1' || k==='2' || k==='3' || k==='4' || k==='5') { choiceOverlay.onKey(k); handled = true; }
      else if (k==='escape' || k==='esc') { closeChoice(); handled = true; }
    } else if (infoCard) {
      if (k==='enter' || (k && k.length===1)) { infoCard.onKey(k); handled = true; }
      else if (k==='escape' || k==='esc') { closeInfoCard(); handled = true; }
    } else if (flagOverlay) {
      // Only Enter key closes flag overlay
      if (k==='enter') { closeFlagOverlay(); handled = true; }
    } else if (borderDraw){
      if (k==='enter'){ stopBorderDraw(true); handled = true; }
      else if (k==='escape' || k==='esc'){ stopBorderDraw(false); handled = true; }
      else if (k==='backspace'){ if (borderDraw.points.length>0) borderDraw.points.pop(); handled = true; }
      else if (k==='u' && borderDraw.points.length>2){ smoothBorder(); handled = true; }
      else if (k==='c'){ borderDraw.points = []; isDrawing = false; lastDrawPoint = null; handled = true; }
    } else if (tug && (k==='a' || k==='d')){ 
      handleTugKey(k); handled = true; 
    } else if (scene==='golf') {
      handled = golfHandleKeyDown(e, k);
    } else {
      // Normal game controls
      keys.add(k);
      // Epstein scene: pause/resume toggle
      if (scene==='epstein' && k==='p') { EP.paused = !EP.paused; say(player, EP.paused? 'Paused' : 'Resumed', 900); handled = true; }
      if (k==='n') CFG.NON_VIOLENT = !CFG.NON_VIOLENT;
      else if (k==='f') CFG.SHOW_FPS = !CFG.SHOW_FPS; // Toggle FPS display
      else if (k==='k') CFG.DEBUG = !CFG.DEBUG; // Toggle debug mode (changed from backtick to 'k')
      else if (k==='t') doTweet();
      else if (k===' ' || k==='arrowup') doJump();
      else if (k==='1' || k==='2' || k==='3' || k==='4') { useInventoryKey(k); handled = true; }
      else if (k==='i') { const open = helpToggleEl && helpToggleEl.getAttribute('aria-expanded') === 'true'; setHelpCardState(!open); handled = true; }
      else if (k==='b') toggleInventory();
      else if (k==='d') { 
        const dyn = inventory.find(it=>it.id==='dynamite' && (it.qty||0)>0);
        if (dyn){ player.selectedItem = (player.selectedItem==='dynamite')? null : 'dynamite'; renderInv(); handled=true; }
      }
      else if (k==='e') {
        // Interact (including planting dynamite across scenes)
        interact();
      }
      // Reset handling
      else if (k==='r') {
        if (e.shiftKey){ // hard reset
          resetStateDefaults();
          inventory.length = 0; 
          collectedCoins = 0; // Reset coin counter
          player.goldBalance = 0;
          renderInv();
          player.baseSpeedMul = 1; player.goldenShoesOn = false; updatePlayerSpeedMul();
          player.tanLevel = 0; player.capOn = false; 
          player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
          renderHUD();
        } else {
          resetStateDefaults();
        }
        if (scene==='greenland') resetGreenland(); else resetOval();
        handled = true;
      }
      
      if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) handled = true;
    }
    
    if (handled) e.preventDefault();
  }, {passive:false});
  addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (scene==='golf' && golfHandleKeyUp(e, k)){
      e.preventDefault();
      return;
    }
    keys.delete(k);
  });

  // ---------- Hj√¶lpere ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const nowMs = ()=>performance.now();
  function updatePlayerSpeedMul(){
    player.speedMul = (player.baseSpeedMul || 1) * (player.goldenShoesOn ? 2 : 1);
  }
  function pointInPolygon(px, py, poly){
    let inside = false;
    for (let i=0, j=poly.length-1; i<poly.length; j=i++){
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi>py)!=(yj>py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-6)+xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  // Distance from point to axis-aligned rectangle (centered at cx,cy, size w x h)
  function distToRect(px,py,cx,cy,w,h){
    const dx = Math.max(Math.abs(px-cx) - w/2, 0);
    const dy = Math.max(Math.abs(py-cy) - h/2, 0);
    return Math.hypot(dx, dy);
  }
  function heliProximity(heli, px, py){
    // Generous rectangle covering cabin/rotor area down to ground, shifted slightly right
    const cx = heli.x + 20*CFG.SCALE;
    const cy = heli.y - 6*CFG.SCALE;
    const w = 220*CFG.SCALE; // wide so side standing counts
    const h = 120*CFG.SCALE; // tall to include ground under rotor
    return distToRect(px, py, cx, cy, w, h);
  }
  
  // Helper function to darken colors for button press effect
  function darkenColor(color) {
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.max(0, (num >> 16) - 40);
      const g = Math.max(0, ((num >> 8) & 0x00FF) - 40);
      const b = Math.max(0, (num & 0x0000FF) - 40);
      return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
    }
    return color; // fallback if not hex color
  }

  // ---------- Don't-destroy-the-world Game State ----------
  const GS = {
    cleared: { greenland:0, oval:0, kremlin:0, epstein:0 },
    // Align required tasks per area with GAME_CONSTANTS
    needPerArea: (GAME_CONSTANTS && GAME_CONSTANTS.GAME && GAME_CONSTANTS.GAME.NEEDED_PER_AREA) || 5,
    over: false,
    overText: '',
    lives: 0,
    nobelAwarded: false,
    achievements: {
      perfectDiplomat: false, // Win with all relationships > 70
      collector: false, // Win with 10+ inventory items
      twitterAddict: false, // Tweet 5+ times
      bearWhisperer: false, // Defeat bear without infection
      nobelLaureate: false
    }
  };
  const areasEl2 = document.getElementById('areas2');
  try { areasEl2 && areasEl2.setAttribute('aria-live','polite'); } catch(_){}

  // Toggleable help legend
  const helpCardEl = document.getElementById('help-card');
  const helpPanelEl = document.getElementById('help-panel');
  const helpToggleEl = document.getElementById('help-toggle');
  const helpHintEl = helpCardEl ? helpCardEl.querySelector('.hint-label') : null;
  const HELP_STORAGE_KEY = 'trumpv2-help-open';

  function setHelpCardState(open, opts){
    if (!helpCardEl || !helpPanelEl || !helpToggleEl) return;
    const shouldPersist = !opts || opts.persist !== false;
    helpCardEl.classList.toggle('collapsed', !open);
    helpPanelEl.hidden = !open;
    helpToggleEl.setAttribute('aria-expanded', open ? 'true' : 'false');
    helpToggleEl.textContent = open ? '‚ùî Skjul styring' : '‚ùî Vis styring';
    if (helpHintEl) helpHintEl.setAttribute('aria-hidden', open ? 'true' : 'false');
    if (shouldPersist){
      try { localStorage.setItem(HELP_STORAGE_KEY, open ? '1' : '0'); } catch(_){ /* ignore */ }
    }
  }

  if (helpToggleEl){
    // Always start collapsed (ignore any previous preference)
    setHelpCardState(false, { persist:false });
    try { localStorage.setItem(HELP_STORAGE_KEY, '0'); } catch(_){ /* ignore */ }
    helpToggleEl.addEventListener('click', () => {
      const open = helpToggleEl.getAttribute('aria-expanded') === 'true';
      setHelpCardState(!open);
    });
  }

  // Removed global timer ‚Äî no countdown displayed
  function renderAreas2(){ if (!areasEl2) return; areasEl2.innerHTML=''; [['greenland','üá¨üá± Gr√∏nland'],['oval','üèõÔ∏è Hvide Hus'],['kremlin','üá∑üá∫ Kremlin'],['epstein','üìÑ Epstein files']].forEach(([k,label])=>{ const d=document.createElement('span'); d.className='pill'; const progress = GS.cleared[k] || 0; const needed = GS.needPerArea; let bgColor = 'rgba(200,0,0,.8)'; if (progress >= needed) bgColor = 'rgba(0,150,0,.8)'; else if (progress > 0) bgColor = 'rgba(200,150,0,.8)'; d.style.background = bgColor; d.textContent=`${label}: ${progress}/${needed}`; areasEl2.appendChild(d); }); }
  renderAreas2();
  
  // ---------- Game State Variables ----------
  let scene = 'intro'; // 'intro' | 'greenland' | 'oval' | 'kremlin' | 'epstein'
  let introStartTime = 0;
  const world = { floor: 120 };
  let borderDraw = null; // Add this here too
  
  // Removed infection system - replaced with bear chasing
  
  // ---------- Relationship System ----------
  const RELATIONSHIPS = {
    mette: {
      respect: 50, // 0-100
      trust: 50,
      fear: 20,
      lastInteraction: 'neutral'
    },
    putin: {
      respect: 30,
      trust: 20, 
      fear: 10,
      lastInteraction: 'neutral'
    }
  };
  
  function adjustRelationship(character, changes, reason) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return;
    
    // Apply changes with bounds checking
    Object.keys(changes).forEach(stat => {
      if (rel.hasOwnProperty(stat)) {
        rel[stat] = Math.max(0, Math.min(100, rel[stat] + changes[stat]));
      }
    });
    
    // Store context
    rel.lastInteraction = reason;
    rel.lastChange = changes;
    rel.lastChangeTime = nowMs();
    
    if (CFG.DEBUG) console.log(`Relationship with ${character}:`, rel, `(${reason})`);
    
    // Play audio feedback
    ensureAudioInit();
    const totalChange = Object.values(changes).reduce((sum, val) => sum + val, 0);
    if (totalChange > 5) SFX.success();
    else if (totalChange < -5) SFX.error();
    else SFX.click();
  }
  
  function getRelationshipLevel(character, stat) {
    const value = RELATIONSHIPS[character]?.[stat] || 50;
    if (value >= 80) return 'excellent';
    if (value >= 60) return 'good';
    if (value >= 40) return 'neutral';
    if (value >= 20) return 'poor';
    return 'terrible';
  }
  
  function getRelationshipEmoji(character) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return 'üòê';
    
    const avg = (rel.respect + rel.trust - rel.fear) / 3;
    if (avg >= 70) return 'üòç'; // Love
    if (avg >= 50) return 'üòä'; // Like
    if (avg >= 30) return 'üòê'; // Neutral
    if (avg >= 10) return 'üò†'; // Dislike
    return 'ü§¨'; // Hate
  }
  
  // Enhanced drawing state
  let isDrawing = false;
  let lastDrawPoint = null;
  const drawingSettings = {
    smoothingDistance: 15, // Minimum distance between points
    maxDrawingSpeed: 1000, // Max pixels per second
    showPreview: true
  };
  
  // ---------- Audio System ----------
  const AUDIO = {
    enabled: true,
    masterVolume: 0.7,
    sounds: {},
    music: null,
    currentTrack: null
  };
  
  // Web Audio API context for better sound control
  let audioContext = null;
  
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (CFG.DEBUG) console.log('Audio system initialized');
    } catch (e) {
      console.warn('Audio not supported:', e);
      AUDIO.enabled = false;
    }
  }
  
  function playSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!AUDIO.enabled || !audioContext) return;
    
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      
      gainNode.gain.value = volume * AUDIO.masterVolume;
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
      console.warn('Sound play failed:', e);
    }
  }
  
  function playChord(frequencies, duration, volume = 0.2) {
    frequencies.forEach((freq, i) => {
      setTimeout(() => playSound(freq, duration, 'sine', volume), i * 50);
    });
  }
  
  // Sound effect library
  const SFX = {
    click: () => playSound(800, 0.1, 'square', 0.2),
    buttonPress: () => playSound(600, 0.15, 'square', 0.3),
    success: () => playChord([523, 659, 784], 0.5, 0.25), // C-E-G
    error: () => playSound(200, 0.3, 'sawtooth', 0.3),
    helicopter: () => {
      // Simulate rotor sound with multiple tones
      for(let i = 0; i < 10; i++) {
        setTimeout(() => playSound(100 + Math.random()*50, 0.1, 'sawtooth', 0.15), i * 50);
      }
    },
    explosion: () => {
      playSound(60, 0.5, 'sawtooth', 0.4);
      setTimeout(() => playSound(40, 0.8, 'square', 0.3), 100);
    },
    whoosh: () => {
      for(let i = 0; i < 5; i++) {
        setTimeout(() => playSound(400 - i*50, 0.1, 'sine', 0.2), i * 30);
      }
    },
    achievement: () => playChord([523, 659, 784, 1047], 0.8, 0.3), // Victory fanfare
    tweet: () => {
      // Twitter notification sound
      playSound(1000, 0.1, 'sine', 0.15);
      setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 120);
    },
    heartbeat: () => {
      playSound(80, 0.1, 'sine', 0.4);
      setTimeout(() => playSound(80, 0.1, 'sine', 0.4), 150);
    }
  };
  
  // Initialize audio on first user interaction
  let audioInitialized = false;
  function ensureAudioInit() {
    if (!audioInitialized && audioContext?.state === 'suspended') {
      audioContext.resume();
      audioInitialized = true;
    }
  }

  // ---------- Intro Screen ----------
  function initIntro() {
    introStartTime = nowMs();
    const introCanvas = document.getElementById('intro-canvas');
    if (introCanvas) {
      // Ensure canvas is properly sized
      const rect = introCanvas.getBoundingClientRect();
      introCanvas.width = 600;
      introCanvas.height = 400;
      const ictx = introCanvas.getContext('2d');
      if (CFG.DEBUG) console.log('Drawing intro graphics on canvas', introCanvas.width, 'x', introCanvas.height);
      // Enable image smoothing for pixel art
      ictx.imageSmoothingEnabled = false;
      drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
    } else {
      if (CFG.DEBUG) console.log('Intro canvas not found!');
    }
  }
  
  function drawIntroGraphics(ctx, w, h) {
    // Clear canvas first
    ctx.clearRect(0, 0, w, h);
    
    // White background behind helicopter and Trump
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    // Draw simple helicopter and Trump using basic shapes - safer approach
    drawIntroHeli(ctx, w/2, h/2 + 20);
    drawIntroTrump(ctx, w/2 + 60, h/2 + 40);
  }
  
  function drawIntroHeli(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Helicopter body
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(-60, -15, 150, 42);
    
    // Cockpit
    ctx.fillStyle = '#86d0ff';
    ctx.fillRect(69, -9, 15, 24);
    
    // Main rotor shaft
    ctx.fillStyle = '#333';
    ctx.fillRect(9, -27, 6, 12);
    
    // Main rotor blades
    ctx.fillStyle = '#333';
    ctx.fillRect(-60, -33, 210, 6);
    
    // Rotor blur effect
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.fillRect(-90, -34, 270, 9);
    ctx.globalAlpha = 1;
    
    // Landing skids
    ctx.fillStyle = '#333';
    ctx.fillRect(-45, 27, 90, 6);
    ctx.fillRect(30, 27, 60, 6);
    
    ctx.restore();
  }
  
  function drawIntroTrump(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Trump figure (simplified)
    // Suit
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-15, 15, 30, 60);
    
    // Shirt
    ctx.fillStyle = '#d8e6ff';
    ctx.fillRect(-12, 18, 24, 36);
    
    // Tie
    ctx.fillStyle = '#e02424';
    ctx.fillRect(-3, 24, 6, 28);
    
    // Head/face
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-15, -15, 30, 30);
    
    // Hair
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-18, -24, 36, 15);
    
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(-9, -3, 3, 3);
    ctx.fillRect(6, -3, 3, 3);
    
    // Mouth
    ctx.fillStyle = '#c2185b';
    ctx.fillRect(-6, 6, 12, 3);
    
    ctx.restore();
  }
  
  function drawPixelMissile(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    
    // Missile body (gray)
    ctx.fillStyle = '#666';
    ctx.fillRect(-8, -60, 16, 60);
    
    // Missile nose (dark gray)  
    ctx.fillStyle = '#444';
    ctx.fillRect(-6, -70, 12, 10);
    ctx.fillRect(-4, -80, 8, 10);
    ctx.fillRect(-2, -85, 4, 5);
    
    // Fins
    ctx.fillStyle = '#555';
    ctx.fillRect(-12, -20, 8, 12);
    ctx.fillRect(4, -20, 8, 12);
    
    // Nuclear symbol (yellow)
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(-6, -40, 12, 2);
    ctx.fillRect(-1, -45, 2, 12);
    ctx.fillRect(-4, -42, 2, 2);
    ctx.fillRect(2, -42, 2, 2);
    ctx.fillRect(-4, -36, 2, 2);
    ctx.fillRect(2, -36, 2, 2);
    
    // Flames (animated)
    const t = (nowMs() / 100) % 4;
    const flameColors = ['#ff4400', '#ff8800', '#ffaa00'];
    for(let i = 0; i < 3; i++) {
      ctx.fillStyle = flameColors[i];
      const offset = Math.floor(t + i) % 3;
      ctx.fillRect(-6 + i*4, 0, 4, 8 + offset*2);
    }
    
    ctx.restore();
  }
  
  function drawPixelDonald(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    
    // Face (orange/tan)
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-12, -16, 24, 20);
    ctx.fillRect(-10, -18, 20, 2);
    ctx.fillRect(-8, -20, 16, 2);
    
    // Hair (yellow/blonde)
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-14, -22, 20, 8);
    ctx.fillRect(-16, -20, 4, 6);
    ctx.fillRect(8, -24, 8, 4);
    
    // Eyes (white with blue)
    ctx.fillStyle = '#fff';
    ctx.fillRect(-8, -12, 4, 3);
    ctx.fillRect(4, -12, 4, 3);
    ctx.fillStyle = '#0066ff';
    ctx.fillRect(-7, -11, 2, 2);
    ctx.fillRect(5, -11, 2, 2);
    
    // Eyebrows (darker)
    ctx.fillStyle = '#cc8844';
    ctx.fillRect(-9, -14, 5, 1);
    ctx.fillRect(4, -14, 5, 1);
    
    // Nose (slightly darker)
    ctx.fillStyle = '#ee9955';
    ctx.fillRect(-1, -8, 2, 3);
    
    // Mouth (dark)
    ctx.fillStyle = '#442222';
    ctx.fillRect(-4, -4, 8, 2);
    
    // Suit collar (dark blue)
    ctx.fillStyle = '#003366';
    ctx.fillRect(-14, 4, 28, 8);
    
    // Tie (red)
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(-2, 2, 4, 10);
    
    ctx.restore();
  }
  
  // Initialize intro screen
  initIntro();
  
  // Initialize audio system
  initAudio();
  
  // Unified start function to avoid duplication
  function startGame(){
    const introEl = document.getElementById('intro');
    if (introEl) introEl.style.display = 'none';
    scene = 'greenland';
    resetGreenland();
    scheduleHeliIntro('Perfect landing! Welcome to Greenland!');
  }

  window.startGolf = function(entry, opts){
    if (entry && typeof entry === 'object' && !Array.isArray(entry) && !opts){
      opts = entry;
      entry = null;
    }

    if (typeof entry === 'string'){
      const key = entry;
      let loader;
      if (key === 'course-mar-a-lago' && typeof window.__ensureGolfSvgCourse === 'function'){
        try {
          loader = window.__ensureGolfSvgCourse();
        } catch(err){
          console.error('Failed to schedule SVG course load', err);
          loader = Promise.resolve(loadGolfCourseFromDOM(key));
        }
      } else {
        loader = Promise.resolve(loadGolfCourseFromDOM(key));
      }

      loader.then(course => {
        if (course) GOLF.course = course;
        golfStartCourse(opts);
      }).catch(err => {
        console.error('Failed to load golf course', err);
        try {
          const fallback = loadGolfCourseFromDOM(key);
          if (fallback) {
            GOLF.course = fallback;
            golfStartCourse(opts);
            return;
          }
        } catch(_){ }
        try { addCaption(W/2, H/2, 'Golf course data mangler', 1800); } catch(_){ }
      });
      return;
    }

    if (!GOLF.course && typeof window.__ensureGolfSvgCourse === 'function'){
      let handled = false;
      try {
        window.__ensureGolfSvgCourse().then(course => {
          if (course) GOLF.course = course;
          if (!handled) { handled = true; golfStartCourse(opts); }
        }).catch(err => {
          console.error('Failed to forberede golfbane', err);
          if (!handled) { handled = true; golfStartCourse(opts); }
        });
        return;
      } catch(err){
        console.error('Failed to queue SVG course promise', err);
      }
    }

    golfStartCourse(opts);
  };

  // Add click handlers to intro UI
  const introEl = document.getElementById('intro');
  if (introEl) {
    introEl.addEventListener('click', e => {
      if (scene === 'intro') startGame();
    });
  }
  const startBtn = document.getElementById('start-btn');
  if (startBtn) {
    startBtn.addEventListener('click', e => { e.stopPropagation(); startGame(); });
    startBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); startGame(); } });
  }

  function addSafe(sceneKey,id){ const S = sceneKey==='greenland'?GL:sceneKey==='oval'?OV:sceneKey==='kremlin'?KR:EP; if (!S._safe) S._safe=new Set(); if (S._safe.has(id)) return; S._safe.add(id); GS.cleared[sceneKey]++; renderAreas2(); }
  function gameOver(text){ 
    GS.over=true; 
    GS.overText=text;
    SFX.achievement();
  }

  // Cause-based game over (no doom mechanic)
  const GO = { cause: null, timer: null, pending:false, title:null, subtitle:null };
  function gameOverCause(cause, opts){
    const delayMs = (opts && typeof opts.delayMs==='number') ? opts.delayMs : 900; // small delay by default
    GO.cause = cause || 'generic';
    GO.title = (opts && opts.title) || null;
    GO.subtitle = (opts && opts.subtitle) || null;
    if (GO.timer) { try { clearTimeout(GO.timer); } catch(_){} GO.timer=null; }
    GO.pending = true;
    GO.timer = setTimeout(() => {
      GS.overMode = 'go_' + GO.cause;
      GS.over = true;
      GS.overText = '';
      GO.pending = false; GO.timer=null;
      SFX.achievement();
    }, Math.max(0, delayMs));
  }
  
  function determineEnding() {
    const cleared = Object.values(GS.cleared).filter(v=>v>=GS.needPerArea).length;
    const metteRel = RELATIONSHIPS.mette;
    const putinRel = RELATIONSHIPS.putin;
    const totalInventory = inventory.length;
    
    // Calculate relationship averages
    const metteAvg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
    const putinAvg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
    
    // Check for achievements (no time-based achievements)
    if (metteAvg >= 70 && putinAvg >= 70) GS.achievements.perfectDiplomat = true;
    if (totalInventory >= 10) GS.achievements.collector = true;
    if (tweetCount >= 5) GS.achievements.twitterAddict = true;
    
    // Count achievements for ending bonuses
    const achievementCount = Object.values(GS.achievements).filter(Boolean).length;
    
    // Multiple ending scenarios
    if (cleared >= 3) {
      // Perfect completion endings
      if (GS.achievements.perfectDiplomat) {
        return 'DIPLOMATIC MASTERPIECE!\nü§ù Greenland acquired through mutual respect.\n‚òÆÔ∏è World peace achieved!\nüéñÔ∏è Perfect Diplomat';
      } else if (achievementCount >= 3) {
        return 'TREMENDOUS SUCCESS!\nüéØ Greenland deal complete!\nüèÖ Multiple achievements unlocked!\n‚≠ê The Art of Excellence!';
      } else if (metteAvg >= 60 || putinAvg >= 60) {
        return 'TREMENDOUS SUCCESS!\nü§ù Greenland deal complete.\nüí™ Strong relationships forged!';
      } else {
        return 'DEAL CLOSED!\nüè¢ Greenland acquired through determination.\nüìò The Art of the Deal!';
      }
    } else if (cleared >= 2) {
      // Standard success endings
      if (GS.achievements.collector) {
        return 'COLLECTOR\'S TRIUMPH!\nüóÉÔ∏è Strategic resource mastery!\nüíé Tremendous acquisitions!\nüè™ Ultimate dealmaker!';
      } else if (metteAvg >= 50 && putinAvg >= 50) {
        return 'DIPLOMATIC VICTORY!\n‚öñÔ∏è Survived with honor intact.\nü§ù All relationships preserved!';
      } else {
        return 'You survived the day!\nüí™ A hard-fought victory.';
      }
    } else if (cleared >= 1) {
      // Partial success endings  
      if (GS.achievements.twitterAddict) {
        return 'SOCIAL MEDIA PRESIDENT!\nüì± Twitter mastery achieved!\nüì¢ Message delivered worldwide!\n‚ö†Ô∏è Minimal other progress...';
      } else if (metteAvg <= 20 && putinAvg <= 20) {
        return 'BRIDGES BURNED!\nüî• Survived, but diplomatic disaster.\nüòû Very sad relationships.\nüíî Tremendous damage done.';
      } else {
        return 'NARROW ESCAPE!\nüòÖ Minimal progress made.\nüìà Must try harder next time.';
      }
    } else {
      // Failure endings (no timer-based failure)
      return 'TOTAL FAILURE!\n‚ùå No progress made anywhere.\nüòû Very disappointing performance!\nüö´ Sad!';
    }
  }
  
  function checkWin(){ 
    const endingText = determineEnding();
    gameOver(endingText);
  }

  function spriteShadow(x,y,w=40,h=10,a=0.2){ ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y,w,h,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  // Colored speech bubbles by speaker: 'trump' | 'mette' | 'bear' | 'aide' | 'default'
  // Wrap helper: splits text at word boundaries to ~maxChars per line
  function wrapLines(text, maxChars){
    const chunks = String(text).split('\n');
    const out = [];
    chunks.forEach(chunk => {
      const words = chunk.trim().split(/\s+/).filter(Boolean);
      let line='';
      words.forEach(w=>{
        const test = line ? line + ' ' + w : w;
        if (test.length <= maxChars) line = test; else { if (line) out.push(line); line = w; }
      });
      if (line) out.push(line);
      if (words.length===0) out.push('');
    });
    return out;
  }

  function textBubble(text,x,y,right=false, speaker='default', yOffset=0){
    const pad = GAME_CONSTANTS.UI.BUBBLE_PADDING; 
    ctx.font=`${GAME_CONSTANTS.UI.BUBBLE_FONT_SIZE*CFG.SCALE}px/1.2 system-ui`;
    const lines = wrapLines(text, 30);
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT*CFG.SCALE;
    const w = Math.max(80, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8);
    const bx = right? x - w - GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET : x + GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET, 
          by = y - GAME_CONSTANTS.UI.BUBBLE_Y_OFFSET*CFG.SCALE + yOffset;
    // palette
    const palettes = {
      trump:  { fill:'rgba(255,165,0,.85)', stroke:'rgba(60,40,0,.9)', text:'#111', tail:'#ffbf47' },
      mette:  { fill:'rgba(90,60,140,.85)', stroke:'rgba(220,205,255,.9)', text:'#fff', tail:'rgba(90,60,140,.85)' },
      bear:   { fill:'rgba(240,240,240,.85)', stroke:'rgba(50,50,50,.7)', text:'#111', tail:'rgba(240,240,240,.85)' },
      aide:   { fill:'rgba(40,80,140,.85)',  stroke:'rgba(220,230,255,.9)', text:'#fff', tail:'rgba(40,80,140,.85)' },
      default:{ fill:'rgba(0,0,0,.7)',        stroke:'rgba(255,255,255,.85)', text:'#fff', tail:'rgba(0,0,0,.7)' }
    };
    const pal = palettes[speaker] || palettes.default;
    ctx.fillStyle=pal.fill; ctx.strokeStyle=pal.stroke;
    roundRect(bx,by,w,h,8); ctx.fill(); ctx.stroke();
    ctx.fillStyle=pal.text; lines.forEach((ln,i)=>ctx.fillText(ln, bx+pad, by+lineH*(i+0.7)));
    ctx.beginPath();
    ctx.fillStyle=pal.tail;
    if (right){ ctx.moveTo(x-10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+w-6,by+h/2-4); ctx.lineTo(bx+w-6,by+h/2+4); }
    else { ctx.moveTo(x+10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+6,by+h/2-4); ctx.lineTo(bx+6,by+h/2+4); }
    ctx.closePath(); ctx.fill();
  }

  // Helper: place bubble to avoid overlap with previously placed bubbles
  function placeBubble(text, x, y, right, placedRects){
    ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const pad=8;
    const lines = wrapLines(text, 30);
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT*CFG.SCALE;
    const w = Math.max(80, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8);
    const bx = right? x - w - 18 : x + 18;
    // Raise bubbles more the larger they are, so they don't sag downward
    let by = y - 46*CFG.SCALE - Math.max(0, (lines.length-1)) * (lineH*0.6);
    const spacing = 8*CFG.SCALE;
    let tries = 0;
    function overlaps(r1, r2){ return !(r1.x + r1.w < r2.x || r2.x + r2.w < r1.x || r1.y + r1.h < r2.y || r2.y + r2.h < r1.y); }
    let rect = {x:bx, y:by, w, h};
    while (placedRects.some(r => overlaps(rect, r)) && tries < 10){
      by -= (h + spacing);
      rect = {x:bx, y:by, w, h};
      tries++;
    }
    placedRects.push(rect);
    const base = y - 46*CFG.SCALE;
    return by - base; // yOffset for textBubble
  }

  // ---------- Spiller ----------
  const player = { x: 240, y: 0, w: 26, h: 44, facing: 1, speakingUntil: 0, say: '', baseSpeedMul:1, speedMul:1, goldenShoesOn:false, tanLevel:0, capOn:false, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, walkCycle:0, lastX:240, walking:false, selectedItem:null, goldBalance:0 };
  updatePlayerSpeedMul();
  
  // Interaction feedback system
  const interactions = new Map(); // Store active interaction effects
  
  function addInteractionFeedback(obj, type='press') {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    interactions.set(key, {
      obj: obj,
      type: type,
      start: nowMs(),
      duration: type === 'press' ? 200 : 300
    });
  }
  
  function getInteractionOffset(obj) {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    const interaction = interactions.get(key);
    if (!interaction) return { x: 0, y: 0 };
    
    const elapsed = nowMs() - interaction.start;
    if (elapsed > interaction.duration) {
      interactions.delete(key);
      return { x: 0, y: 0 };
    }
    
    const progress = elapsed / interaction.duration;
    if (interaction.type === 'press') {
      const pushDown = Math.sin(progress * Math.PI) * 3 * CFG.SCALE;
      return { x: 0, y: pushDown };
    }
    return { x: 0, y: 0 };
  }
  let phoneBlinkUntil = 0;
  let speedBoostUntil = 0;
  let introPlayed = false, introRunning = false;
  const entryHeli = { active:false, x:0, y:0, start:0, dur:1600, targetX:0, startY:0, targetY:0, vertical:true, line:'' };
  function say(who, txt, ms){ who.speakingUntil = nowMs() + (ms||CFG.BUBBLE_TIME); who.say = txt; }

  // ---------- Inventar ----------
  const invEl = document.getElementById('inv');
  if (invEl) {
    invEl.classList.add('hidden');
    invEl.setAttribute('aria-hidden','true');
  }
  const ITEM_META = {
    tan:  { id:'tan',  name:'Selvbruner', stats:{ karisma:+2, visdom:-1, stil:+1 } },
    shoes:{ id:'shoes', name:'Guldsneakers', stats:{ tempo:+100 } },
    maga: { id:'maga', name:'MAGA-cap',   stats:{ karisma:+5, visdom:-5 } },
    dynamite: { id:'dynamite', name:'Dynamit', stats:{ destruction:+999 } }
  };
  const MAX_SLOTS = 6;
  const inventory = []; // starts empty; filled via shop/pickups
  let collectedCoins = 0; // Global coin counter
  function addToInventory(id,name){
    const existing = inventory.find(i=>i.id===id);
    if (id==='dynamite'){
      if (existing) existing.qty = (existing.qty||0) + 5; else {
        const meta = ITEM_META[id] || {id,name,stats:null};
        inventory.push({id:meta.id, name:meta.name||name, stats:meta.stats||null, qty:5});
      }
    } else {
      if (existing) return;
      const meta = ITEM_META[id] || {id,name,stats:null};
      // Place new items in slot order: tan, shoes, maga, dynamite, then extras
      const order = ['tan','shoes','maga','dynamite'];
      const targetIndex = order.indexOf(meta.id);
      if (targetIndex >= 0){
        let insertAt = inventory.findIndex(it => (order.indexOf(it.id) > targetIndex) || order.indexOf(it.id) === -1);
        if (insertAt === -1) insertAt = inventory.length;
        inventory.splice(insertAt, 0, {id:meta.id, name:meta.name||name, stats:meta.stats||null});
      } else {
        inventory.push({id:meta.id, name:meta.name||name, stats:meta.stats||null});
      }
    }
    renderInv();
  }
  // Ensure default starting items are present (tan, cl, maga)
  function ensureDefaultInventory(){
    // default inventory now empty; shop handles purchases
  }
  // small icons for inventory
  function drawInvIcon(ctx, id){
    ctx.save();
    ctx.translate(19,14); // center-ish for 38x24 canvas
    ctx.scale(0.8,0.8);
    if (id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,6,16,10); ctx.fillStyle='#bbb'; ctx.fillRect(-6,2,12,4); ctx.fillStyle='#ddd'; ctx.fillRect(-2,-2,4,4); }
    else if (id==='shoes'){
      // Golden sneaker with blue cuff and red stripe
      ctx.fillStyle='#f5d36a'; ctx.fillRect(-14,6,28,10);
      ctx.fillStyle='#b88a1d'; ctx.fillRect(-14,14,28,3);
      ctx.fillStyle='#fff'; ctx.fillRect(-14,16,28,2);
      ctx.fillStyle='#ff3b2f'; ctx.fillRect(2,8,10,3);
      ctx.fillStyle='#1e4fbf'; ctx.fillRect(6,2,8,6);
      ctx.fillStyle='#ffd700'; ctx.fillRect(7,3,2,2); ctx.fillRect(11,3,2,2);
      ctx.fillRect(9,5,2,2);
    }
    else if (id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,6,24,8); ctx.fillRect(-10,0,20,6); ctx.fillStyle='#a00'; ctx.fillRect(2,2,4,2); }
    else if (id==='dynamite'){ 
      // Two narrow red sticks side by side with black bands
      ctx.fillStyle='#d32f2f'; ctx.fillRect(-8,0,6,16); // left stick
      ctx.fillStyle='#d32f2f'; ctx.fillRect(2,0,6,16); // right stick
      ctx.fillStyle='#333'; ctx.fillRect(-8,4,6,2); // left black band
      ctx.fillStyle='#333'; ctx.fillRect(2,4,6,2); // right black band
      ctx.fillStyle='#333'; ctx.fillRect(-8,10,6,2); // left bottom band
      ctx.fillStyle='#333'; ctx.fillRect(2,10,6,2); // right bottom band
    }
    else if (id && id.startsWith('stat')){ ctx.fillStyle='#d4af37'; ctx.fillRect(-6,-2,12,12); ctx.fillStyle='#8a6b2f'; ctx.fillRect(-8,10,16,4); }
    else { ctx.fillStyle='#999'; ctx.fillRect(-8,2,16,12); }
    ctx.restore();
  }
  function renderInv(){
    if (!invEl) return;
    invEl.innerHTML='';
    // desired slot order: known item types first, then extras, then placeholders to MAX_SLOTS
    const slotIds = Object.keys(ITEM_META);
    let rendered = 0;
    // render fixed placeholders or filled slots for known items
    slotIds.forEach(id => {
      const item = inventory.find(it=>it.id===id) || null;
      const isSelected = player.selectedItem === id;
      const d=document.createElement('div'); 
      d.className='slot' + (item? '' : ' empty');
      // Add selected highlight
      if (isSelected) {
        d.style.border = '2px solid #ffff00';
        d.style.backgroundColor = 'rgba(255,255,0,0.2)';
        d.style.boxShadow = '0 0 10px rgba(255,255,0,0.5)';
      }
      const c=document.createElement('canvas'); c.className='slotcvs';
      // draw all text inside the canvas for reliability
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d');
      ictx.setTransform(DPRui,0,0,DPRui,0,0);
      paintSlot(ictx, item);
      rendered++;
    });
    // render any extra, unknown items after the fixed slots
    inventory.filter(it=>!ITEM_META[it.id]).forEach(it => {
      const d=document.createElement('div'); d.className='slot';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, it);
      rendered++;
    });
    // fill remaining placeholders to MAX_SLOTS
    while (rendered < MAX_SLOTS){
      const d=document.createElement('div'); d.className='slot empty';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, null);
      rendered++;
    }
  }
  function paintSlot(g, item){
    // background glass
    g.fillStyle='rgba(255,255,255,.08)'; g.fillRect(0,0,62,50);
    // icon
    g.save(); g.translate(31,10); g.scale(0.6,0.6);
    if (item) {
      // reuse icon shapes
      if (item.id==='tan'){ g.fillStyle='#8b5e3c'; g.fillRect(-8,6,16,10); g.fillStyle='#bbb'; g.fillRect(-6,2,12,4); g.fillStyle='#ddd'; g.fillRect(-2,-2,4,4); }
      else if (item.id==='shoes'){
        g.fillStyle='#f5d36a'; g.fillRect(-16,4,32,12);
        g.fillStyle='#b88a1d'; g.fillRect(-16,14,32,4);
        g.fillStyle='#fff'; g.fillRect(-16,18,32,2);
        g.fillStyle='#ff3b2f'; g.fillRect(2,6,12,3);
        g.fillStyle='#1e4fbf'; g.fillRect(6,0,10,6);
        g.fillStyle='#ffd700'; g.fillRect(7,1,3,2); g.fillRect(12,1,3,2); g.fillRect(9,3,3,2);
        g.fillStyle='#d19b1a'; g.fillRect(-12,8,4,4); g.fillRect(-6,8,4,4); g.fillRect(20,8,4,4); // eyelets
      }
      else if (item.id==='maga'){ g.fillStyle='#c22'; g.fillRect(-12,6,24,8); g.fillRect(-10,0,20,6); g.fillStyle='#a00'; g.fillRect(2,2,4,2); }
      else if (item.id==='dynamite'){ 
        // Two red sticks (match in-world fallback)
        g.fillStyle='#d32f2f'; g.fillRect(-8,0,6,16); g.fillRect(2,0,6,16);
        g.fillStyle='#333'; g.fillRect(-8,4,6,2); g.fillRect(2,4,6,2);
        g.fillStyle='#333'; g.fillRect(-8,10,6,2); g.fillRect(2,10,6,2);
      }
      else { g.fillStyle='#999'; g.fillRect(-8,2,16,12); }
    } else {
      g.globalAlpha=.6; g.fillStyle='#bbb'; g.fillRect(-10,2,20,12); g.globalAlpha=1;
    }
    g.restore();
    // text lines
    g.fillStyle='#fff'; g.font='bold 8px system-ui'; g.textAlign='center';
    let name = item ? (item.name + (isEquipped(item.id)? ' ‚úì':'')) : 'Tom';
    if (item && item.id==='dynamite' && item.qty){ name += ' x'+item.qty; }
    g.fillText(name, 31, 28);
    // stats split across two lines
    const statsFull = item && item.stats ? statString(item.stats) : '‚Äî';
    const parts = statsFull.split(/\s+/);
    const mid = Math.ceil(parts.length/2);
    const line1 = parts.slice(0, mid).join(' ');
    const line2 = parts.slice(mid).join(' ');
    g.font='7px system-ui'; g.globalAlpha=.95; g.fillText(line1,31,36);
    if (line2){ g.globalAlpha=.9; g.font='6px system-ui'; g.fillText(line2,31,43); }
    g.globalAlpha=1; g.textAlign='left';
    g.globalAlpha=1; g.textAlign='left';
  }
  function statString(stats){
    return Object.entries(stats).map(([k,v])=> (v>=0? '+'+v : v)+' '+k).join(' ');
  }
  function toggleInventory(){
    if (!invEl) return;
    const nowHidden = invEl.classList.toggle('hidden');
    invEl.setAttribute('aria-hidden', nowHidden ? 'true' : 'false');
    if (!nowHidden){ try { invEl.scrollTop = 0; } catch(_){}
    }
    renderInv();
  }

  // equipped flags
  function isEquipped(id){
    if (id==='shoes') return !!player.goldenShoesOn;
    if (id==='tan') return (player.tanLevel||0) > 0;
    if (id==='maga') return !!player.capOn;
    return false;
  }

  // ---------- HUD ----------
  const hudEl = document.getElementById('hud');
  let hudToast = null;
  function renderHUD(){
    if (!hudEl) return;
    hudEl.innerHTML = '';
    // Lives first for prominence
    addLivesChip(GS.lives);
    // Gold bar counter with custom icon just under lives
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    addGoldBarChip(player.goldBalance || 0, totalCoins);
    addChip('üí∞ ' + (player.goldBalance || 0));
    // Cap icon
    if (player.capOn) addChip('üß¢');
    // Nobel medal
    if (GS.nobelAwarded) addChip('üèÖ Nobel');
    // Speed timer chip
    const now = nowMs();
    if (player.goldenShoesOn) addChip('üëü x2');
    if (speedBoostUntil > now){ const rem = Math.max(0, Math.ceil((speedBoostUntil - now)/1000)); addChip('Tempo '+rem+'s'); }
  }
  function addChip(text){ const s=document.createElement('span'); s.className='chip'; s.textContent=text; hudEl.appendChild(s); }
  
  function drawGoldBarHUDIcon(canvasEl, x, y) {
    const ctx = canvasEl.getContext('2d');
    ctx.save();
    ctx.translate(x, y);
    
    // HUD-sized gold bar with "GOLD" text (larger than in-game version)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(0, 4, 24, 12); // bottom part
    ctx.fillRect(20, 2, 4, 10); // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(0, 2, 20, 10);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(0, 2, 20, 5); // top surface
    ctx.fillRect(0, 0, 3, 3);  // left edge highlight
    
    // "GOLD" text embossed on HUD icon
    ctx.fillStyle='#b8860b'; // darker gold for text
    ctx.font='bold 8px system-ui';
    ctx.textAlign='center';
    ctx.fillText('GOLD', 10, 8);
    ctx.textAlign='left';
    
    ctx.restore();
  }
  
  function addGoldBarChip(count, total) {
    const s = document.createElement('span');
    s.className = 'chip';
    s.style.display = 'inline-flex';
    s.style.alignItems = 'center';
    s.style.gap = '4px';
    
    // Create canvas for gold bar icon
    const iconCanvas = document.createElement('canvas');
    iconCanvas.width = 24;
    iconCanvas.height = 14;
    iconCanvas.style.verticalAlign = 'middle';
    
    // Draw gold bar icon
    drawGoldBarHUDIcon(iconCanvas, 1, 1);
    
    s.appendChild(iconCanvas);
    s.appendChild(document.createTextNode(`${count}/${total}`));
    hudEl.appendChild(s);
  }

  function drawTrumpHeadHUDIcon(ctx, width, height) {
    ctx.save();
    ctx.clearRect(0, 0, width, height);
    ctx.imageSmoothingEnabled = false;

    const baseW = 32;
    const baseH = 30;
    const offsetX = (width - baseW) / 2;
    const offsetY = (height - baseH) / 2;
    ctx.translate(offsetX, offsetY);

    // Drop shadow for depth
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(8, 24, 18, 4);

    // Hair base and highlights
    ctx.fillStyle = '#f4c542';
    ctx.fillRect(6, 0, 20, 9);
    ctx.fillRect(4, 3, 4, 7);
    ctx.fillRect(24, 3, 4, 7);
    ctx.fillStyle = '#ffe578';
    ctx.fillRect(8, 1, 16, 3);
    ctx.fillStyle = '#d99d32';
    ctx.fillRect(6, 6, 20, 3);

    // Face
    ctx.fillStyle = '#ffdbb2';
    ctx.fillRect(8, 8, 16, 14);
    ctx.fillStyle = '#f7c99a';
    ctx.fillRect(8, 8, 16, 5);

    // Ears
    ctx.fillStyle = '#f7c99a';
    ctx.fillRect(6, 12, 2, 6);
    ctx.fillRect(24, 12, 2, 6);

    // Brows
    ctx.fillStyle = '#d2963c';
    ctx.fillRect(10, 12, 5, 1);
    ctx.fillRect(17, 12, 5, 1);

    // Eyes
    ctx.fillStyle = '#1f1f1f';
    ctx.fillRect(11, 14, 3, 2);
    ctx.fillRect(18, 14, 3, 2);
    ctx.fillStyle = '#fff';
    ctx.fillRect(12, 14, 1, 1);
    ctx.fillRect(19, 14, 1, 1);

    // Nose
    ctx.fillStyle = '#e7a873';
    ctx.fillRect(15, 16, 3, 5);

    // Mouth
    ctx.fillStyle = '#9a2b38';
    ctx.fillRect(13, 20, 8, 2);
    ctx.fillStyle = '#f3969c';
    ctx.fillRect(13, 20, 8, 1);

    // Chin shading
    ctx.fillStyle = '#e7b789';
    ctx.fillRect(10, 22, 12, 2);

    // Suit
    ctx.fillStyle = '#0d1f38';
    ctx.fillRect(6, 22, 20, 8);
    ctx.fillStyle = '#102849';
    ctx.fillRect(6, 22, 6, 8);
    ctx.fillRect(20, 22, 6, 8);

    // Shirt and tie
    ctx.fillStyle = '#f9f9ff';
    ctx.fillRect(12, 22, 8, 4);
    ctx.fillStyle = '#b91824';
    ctx.fillRect(15, 22, 4, 8);
    ctx.fillStyle = '#d12b38';
    ctx.fillRect(15, 22, 4, 4);

    ctx.restore();
  }

  function addLivesChip(lives){
    const s = document.createElement('span');
    s.className = 'chip life-chip';
    s.style.display = 'inline-flex';
    s.style.alignItems = 'center';
    s.style.gap = '8px';
    const icon = document.createElement('canvas');
    const iconW = 40;
    const iconH = 36;
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    icon.width = iconW * dpr;
    icon.height = iconH * dpr;
    icon.style.width = iconW + 'px';
    icon.style.height = iconH + 'px';
    const iconCtx = icon.getContext('2d');
    iconCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawTrumpHeadHUDIcon(iconCtx, iconW, iconH);
    s.appendChild(icon);
    const livesLabel = document.createElement('strong');
    livesLabel.textContent = 'x ' + (lives|0);
    s.appendChild(livesLabel);
    hudEl.appendChild(s);
  }

  // ---------- Scener ----------

  const GL = {
    state: { flagPlanted:false, bearGone:false, hasTweeted:false, glaciersBlown:false, hasSeenGlaciers:false },
    mine:  {x: 520, y: 0, w:36, h:24, type:'mine'},
    flag:  null,
    bear:  {x: 760, y: 0, w:70, h:40, type:'bear', alive:true, hp:2, speakingUntil:0, say:'', angry:false, chasing:false, speed:100, facing:1},
    mette: {x: 980, y: 0, w:26, h:44, type:'mette', speakingUntil:0, say:''},
    rig:   {x: 380, y: 0, w:30, h:40, type:'rig'},
    heli:  {x: 160, y: 0, w:120, h:42, type:'heli'},
    coins: [], // Mario-style collectible gold bars
    // Interactive glaciers in background
    glaciers: [
      {x: 120, y: 0, w:240, h:360, type:'glacier', blown:false},
      {x: 760, y: 0, w:300, h:420, type:'glacier', blown:false}
    ],
    // pickups (now provided via shop)
    items: [],
    shop: { x: 1120, y: 0, w: 260, h: 160, type:'shop' }
  };

  const OV = {
    door: {x: 140, y:0, w:40, h:80, type:'door'},
    aide: {x: 720, y:0, w:24, h:44, type:'aide', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    yes:  {x: 980, y:0, w:26, h:44, type:'yes', speakingUntil:0, say:''},
    buttons: [], // desk buttons
    coins: [], // Mario-style collectible gold bars
    screen: { active:null, feed:[] }, // wall screen state
    shelfLoot: [] // extra statues stolen from Kremlin to display
  };

  // Kremlin scene (Putin meeting)
  const KR = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    putin:{x: 680, y:0, w:24, h:44, type:'putin', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    statues: [], // will be set in resetKremlin
    ukraineFlag: null, // 'american' or 'russian' - which flag is planted on Ukraine
    camera: {x: 0, y: 0, angle: 0, sweepStart: 0, discovered: false}, // security camera
    coins: [], // Mario-style collectible gold bars
    nobelPending: false
  };

  // ---------- Epstein Files Scene ----------  
  const EP = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    papers: [],
    currentLine: 0,
    scrollSpeed: 1.0,
    scrollY: 0,
    timeElapsed: 0,
    missedTrumps: 0,
    foundTrumps: 0,
    gameActive: false,
    gameStartTime: 0,
    trumpLocations: [], // {x,y,width,height,docIndex,lineInDoc,kind:'trump'|'protected'}
    generatedDocs: false,
    totalTrumpTargets: 10,
    missesAllowed: 2,
    failedByProtected: false,
    protectedClicks: 0,
    protectedLimit: 1, // Fail after this many protected clicks
    timeLimitMs: 20000,
    protectedNames: ['Bill Clinton','Bill Gates'],
    toasts: [], // {x,y,text,color,start,ttl}
    crosses: [], // {x,y,w,h,start,ttl}
    assistUntil: 0,
    mt: new Map(), // measureText cache for this scene
    visibleDoc: 1,
    paused: false,
    finalArt: { redacted: false },
    finalArtRect: null,
    artHeightPx: 0,
    stopAtArt: true,
    holdAtArtMargin: 40, // px (scaled) from top of paper where art should stop
    atArtHold: false,
    endingPending: false
  };

  // ---------- Mar-a-Lago Mini-Putt Scene ----------
  const GOLF = {
    course: null,
    holeIndex: 0,
    strokes: [],
    ball: { x: 0, y: 0, r: 10, vx: 0, vy: 0 },
    state: 'idle', // 'intro' | 'aim' | 'rolling' | 'charging' | 'waiting' | 'banner' | 'scorecard'
    aim: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 },
    charge: { active: false, dirX: 0, dirY: 0, power: 0 },
    banner: null,
    penaltyFlashUntil: 0,
    scorecard: null,
    lastUpdate: 0,
    hole: null,
    courseName: 'Mar-a-Lago Mini-Putt',
    aimAngle: 0,
    aimPower: 0,
    aimPreviewLength: 70,
    previewSpeed: 0,
    _finishedHole: false,
    view: { scale: 1, ox: 0, oy: 0 },
    playerStand: { x: 0, y: 0 },
    bidenAvatar: { x: 0, y: 0 },
    overlays: new Map(),
    captions: [],
    captionCounter: 0,
    opts: { versus: true },
    totalStrokes: 0,
    strokesThisHole: 0,
    holeBooked: false,
    turn: 'player',
    introActive: false,
    introDismissReady: false,
    introShown: false,
    biden: null,
    bidenPlan: null,
    bidenTimer: null
  };

  const GOLF_MAX_DRAG = 260;
  const GOLF_MIN_SPEED = 140;
  const GOLF_MAX_SPEED = 780;
  const GOLF_POWER_EXP = 1.18;
  const CUP_SPEED_THRESH = 20; // px/s max speed to count as holed
  const MAGNET_RANGE = 18; // px beyond cup radius where pull begins
  const MAGNET_SPEED = 220; // apply magnet only below this speed
  const MAGNET_STRENGTH = 1200; // px/s^2 toward cup center
  const GOLF_PREVIEW_BASE = 70;
  const GOLF_PREVIEW_EXTRA = 190;
  const GOLF_KEY_CHARGE_RATE = 1.2; // per second normalised charge

  function isNum(v){ return typeof v === 'number' && !Number.isNaN(v); }

  function golfComputeTeePosition(){
    const hole = GOLF.hole;
    if (!hole) return { x: GOLF.ball.x, y: GOLF.ball.y };
    const teeRect = hole.teeRect || { x: (hole.spawn?.x||hole.tee?.x||150) - 20, y: (hole.spawn?.y||hole.tee?.y||150) - 20, w: 40, h: 40 };
    const spawn = hole.spawn || {};
    let x = isNum(spawn.x) ? spawn.x : teeRect.x + teeRect.w/2;
    let y = isNum(spawn.y) ? spawn.y : teeRect.y + teeRect.h/2;
    const minX = teeRect.x + GOLF.ball.r;
    const maxX = teeRect.x + teeRect.w - GOLF.ball.r;
    const minY = teeRect.y + GOLF.ball.r;
    const maxY = teeRect.y + teeRect.h - GOLF.ball.r;
    return {
      x: clamp(x, minX, maxX),
      y: clamp(y, minY, maxY)
    };
  }

  function golfResetBallToTee(opts){
    const penalty = opts && opts.penalty;
    const caption = opts && opts.caption;
    const hole = GOLF.hole;
    const spawn = hole?.spawn || hole?.tee || {};
    const teeRect = hole?.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const cx = teeRect.x + teeRect.w/2;
    const cy = teeRect.y + teeRect.h/2;
    GOLF.ball.x = cx;
    GOLF.ball.y = cy;
    GOLF.ball.vx = 0;
    GOLF.ball.vy = 0;
    GOLF.turn = 'player';
    GOLF.aimAngle = -Math.PI/2;
    GOLF.aimPower = 0;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE;
    GOLF.aim.active = false;
    if (!GOLF.introActive) GOLF.state = 'aim';
    if (penalty){
      GOLF.strokesThisHole += 1;
      GOLF.strokes[GOLF.holeIndex] = GOLF.strokesThisHole;
    }
    const label = caption || (penalty ? 'Drop (+1)' : 'TEE');
    if (label) addCaption(cx, cy - 24, label, 1100);
  }

  function golfUpdateAimFromPointer(px, py){
    const dx = GOLF.ball.x - px;
    const dy = GOLF.ball.y - py;
    const drag = Math.hypot(dx, dy);
    const power = Math.min(drag / GOLF_MAX_DRAG, 1);
    GOLF.aimAngle = Math.atan2(dy, dx);
    GOLF.aimPower = power;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE + power * GOLF_PREVIEW_EXTRA;
  }

  function golfStrike(angle, powerNorm){
    const ratio = clamp(powerNorm, 0, 1);
    const speed = GOLF_MIN_SPEED + Math.pow(ratio, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
    GOLF.ball.vx = Math.cos(angle) * speed;
    GOLF.ball.vy = Math.sin(angle) * speed;
    GOLF.state = 'rolling';
    GOLF.turn = 'player_rolling';
    golfAddStroke();
    GOLF.aimPower = 0;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE;
  }

  function loadGolfCourseFromDOM(id){
    const el = document.getElementById(id||'course-mar-a-lago');
    if (!el) return null;
    try {
      return JSON.parse(el.textContent.trim());
    } catch(err){
      console.warn('Failed to parse golf course data', err);
      return null;
    }
  }

  function golfResetHole(index){
    if (!GOLF.course || !GOLF.course.holes[index]) return;
    GOLF.holeIndex = index;
    GOLF.hole = GOLF.course.holes[index];
    if (typeof GOLF.strokes[index] !== 'number') GOLF.strokes[index] = 0;
    GOLF.strokesThisHole = 0;
    GOLF.holeBooked = false;
    if (GOLF.introActive){
      GOLF.state = 'intro';
      GOLF.introShown = true;
    } else if (GOLF.state !== 'scorecard') {
      GOLF.state = 'aim';
    }
    GOLF.turn = 'player';
    // Start position: spawn if inside teeRect, otherwise center of teeRect
    const spawn = GOLF.hole.spawn || GOLF.hole.tee || {};
    const teeRect = GOLF.hole.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const r = GOLF.ball.r || 10;
    const minX = teeRect.x + r, maxX = teeRect.x + teeRect.w - r;
    const minY = teeRect.y + r, maxY = teeRect.y + teeRect.h - r;
    const spawnValid = (typeof spawn.x==='number' && typeof spawn.y==='number' && spawn.x>=minX && spawn.x<=maxX && spawn.y>=minY && spawn.y<=maxY);
    const startX = spawnValid ? spawn.x : (teeRect.x + teeRect.w/2);
    const startY = spawnValid ? spawn.y : (teeRect.y + teeRect.h/2);
    GOLF.ball.x = startX;
    GOLF.ball.y = startY;
    GOLF.ball.vx = 0; GOLF.ball.vy = 0;
    addCaption(startX, startY - 24, 'TEE', 1100);

    const cup = GOLF.hole.cup || {x: startX + 60, y: startY - 60};
    GOLF.aimAngle = Math.atan2((cup.y||0) - startY, (cup.x||0) - startX);
    GOLF.state = GOLF.introActive ? 'intro' : 'aim';
    GOLF.aim.active = false;
    GOLF.charge.active = false;
    GOLF.charge.power = 0;
    // Stand positions (avatars stand near tee; balls roll independently)
    const standOffset = 84;
    const bounds = GOLF.hole.bounds || { x: 0, y: 0, w: VIRTUAL_W, h: VIRTUAL_H };
    const baseX = clamp(startX - standOffset, bounds.x + 32, bounds.x + bounds.w - 32);
    const trumpY = clamp(startY + 36, bounds.y + 36, bounds.y + bounds.h - 24);
    const bidenY = clamp(trumpY - 90, bounds.y + 36, bounds.y + bounds.h - 24);
    GOLF.playerStand = { x: baseX, y: trumpY };
    GOLF.bidenAvatar = { x: baseX, y: bidenY };
    GOLF._finishedHole = false;
    GOLF.banner = { text: `Hole ${GOLF.hole.id}`, until: nowMs()+2600, onDone: null };
    GOLF.lastUpdate = nowMs();
    if (GOLF.opts?.versus !== false){
      const prevBiden = GOLF.biden;
      const spawnB = GOLF.hole.spawn || GOLF.hole.tee;
      const teeRect = GOLF.hole.teeRect || {x: spawnB.x-24, y: spawnB.y-24, w: 48, h:48};
      GOLF.biden = {
        ball: { x: spawn.x + 28, y: spawn.y - 24, r: 7, vx: 0, vy: 0, moving: false },
        strokesHole: 0,
        total: (prevBiden?.total || 0),
        parTarget: (GOLF.hole.parMini || (GOLF.course?.par?.[index] || 3)) + 1,
        walking: false,
        sayNext: 0,
        waiting: false,
        _booked: false,
        _finishedHole: false,
        teeRect
      };
      GOLF.bidenPlan = planBidenStrokes(GOLF.hole, GOLF.biden.parTarget);
    } else {
      GOLF.biden = null;
      GOLF.bidenPlan = null;
    }
  }

  function golfStartCourse(opts){
    if (opts && typeof opts === 'object'){ GOLF.opts = Object.assign({versus:true}, opts); }
    else GOLF.opts = Object.assign({versus:true}, GOLF.opts||{});
    if (!GOLF.course){
      GOLF.course = loadGolfCourseFromDOM('course-mar-a-lago');
    }
    if (!GOLF.course){ return; }
    GOLF.courseName = GOLF.course.name || 'Mini-Putt';
    GOLF.strokes = new Array(GOLF.course.holes.length).fill(0);
    GOLF.totalStrokes = 0;
    GOLF.scorecard = null;
    GOLF.captions = [];
    GOLF.banner = null;
    if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer=null; }
    GOLF.biden = null;
    GOLF.turn = 'player';
    GOLF.introActive = true;
    GOLF.introDismissReady = false;
    GOLF.introShown = false;
    GOLF.state = 'intro';
    // Bind golf-specific pointer handlers once per scene start
    try { golfBindInput(); } catch(_){}
    golfResetHole(0);
    setTimeout(()=>{ GOLF.introDismissReady = true; }, 150);
    scene = 'golf';
    GS.over = false;
    GS.overMode = null;
    GS.overText = '';
  }

  // Golf pointer input binding lifecycle
  let golfInputHandlers = null;
  function golfBindInput(){
    if (golfInputHandlers) return; // already bound
    const onPointerDown = (e)=>{
      if (scene !== 'golf') return;
      const p = toCanvasCoords(e, cvs); 
      const mxs = p.x / DPR, mys = p.y / DPR;
      const mx = (mxs - (GOLF.view?.ox||0)) / (GOLF.view?.scale||1);
      const my = (mys - (GOLF.view?.oy||0)) / (GOLF.view?.scale||1);
      if (GOLF.state==='intro'){
        return;
      }
      if (GOLF.state === 'aim'){
        const d = Math.hypot(mx - GOLF.ball.x, my - GOLF.ball.y);
        if (d <= GOLF.ball.r * 2.4){
          GOLF.aim.active = true;
          GOLF.aim.startX = GOLF.ball.x; GOLF.aim.startY = GOLF.ball.y;
          GOLF.aim.currentX = mx; GOLF.aim.currentY = my;
          try { cvs.setPointerCapture(e.pointerId); } catch(_){ }
          e.preventDefault();
        }
      }
    };
    const onPointerMove = (e)=>{
      if (scene !== 'golf' || !GOLF.aim.active) return;
      const p = toCanvasCoords(e, cvs); const mxs = p.x / DPR, mys = p.y / DPR;
      const mx = (mxs - (GOLF.view?.ox||0)) / (GOLF.view?.scale||1);
      const my = (mys - (GOLF.view?.oy||0)) / (GOLF.view?.scale||1);
      GOLF.aim.currentX = mx; GOLF.aim.currentY = my;
      const dx = GOLF.aim.startX - GOLF.aim.currentX;
      const dy = GOLF.aim.startY - GOLF.aim.currentY;
      const dist = Math.hypot(dx, dy);
      const power = Math.min(dist / GOLF_MAX_DRAG, 1);
      GOLF.aimAngle = Math.atan2(dy, dx);
      GOLF.aimPower = power;
      GOLF.previewSpeed = GOLF_MIN_SPEED + Math.pow(power, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
    };
    const onPointerUp = (e)=>{
      if (scene !== 'golf') return;
      if (GOLF.state === 'aim' && GOLF.aim.active){
        GOLF.aim.active = false;
        const dx = GOLF.aim.startX - GOLF.aim.currentX;
        const dy = GOLF.aim.startY - GOLF.aim.currentY;
        const dist = Math.hypot(dx, dy);
        if (dist > 6){
          const power = Math.min(dist / GOLF_MAX_DRAG, 1);
          const angle = Math.atan2(dy, dx);
          GOLF.previewSpeed = GOLF_MIN_SPEED + Math.pow(power, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
          golfStrike(angle, power);
        } else {
          GOLF.aimAngle = Math.atan2(GOLF.aim.currentY - GOLF.ball.y, GOLF.aim.currentX - GOLF.ball.x);
        }
      } else if (GOLF.state === 'charging'){
        golfHandleKeyUp({code:'Space'}, ' ');
      }
      try { cvs.releasePointerCapture(e.pointerId); } catch(_){ }
    };
    const onPointerCancel = (e)=>{
      if (scene !== 'golf') return;
      GOLF.aim.active = false;
      if (GOLF.state === 'charging'){ GOLF.state = 'aim'; GOLF.charge.active=false; }
      try { cvs.releasePointerCapture(e.pointerId); } catch(_){ }
    };
    cvs.addEventListener('pointerdown', onPointerDown);
    cvs.addEventListener('pointermove', onPointerMove);
    cvs.addEventListener('pointerup', onPointerUp);
    cvs.addEventListener('pointercancel', onPointerCancel);
    golfInputHandlers = { onPointerDown, onPointerMove, onPointerUp, onPointerCancel };
  }
  function golfUnbindInput(){
    if (!golfInputHandlers) return;
    cvs.removeEventListener('pointerdown', golfInputHandlers.onPointerDown);
    cvs.removeEventListener('pointermove', golfInputHandlers.onPointerMove);
    cvs.removeEventListener('pointerup', golfInputHandlers.onPointerUp);
    cvs.removeEventListener('pointercancel', golfInputHandlers.onPointerCancel);
    golfInputHandlers = null;
    // Ensure stable state
    GOLF.aim.active = false;
    if (GOLF.state === 'charging'){ GOLF.state = 'aim'; GOLF.charge.active = false; }
  }

  function golfAdvanceHole(){
    const next = GOLF.holeIndex + 1;
    if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer = null; }
    if (GOLF.biden && !GOLF.biden._booked && GOLF.biden.strokesHole >= GOLF.biden.parTarget){
      GOLF.biden.total += GOLF.biden.strokesHole;
      GOLF.biden._booked = true;
    }
    if (next >= (GOLF.course?.holes.length||0)){
      const finalize = () => {
        GOLF.state = 'scorecard';
        const total = GOLF.strokes.reduce((a,b)=>a+b,0);
        const parTotal = (GOLF.course?.par||[]).reduce((a,b)=>a+b,0);
        GOLF.scorecard = {
          total,
          par: parTotal,
          joe: GOLF.biden ? GOLF.biden.total : 0,
          diff: total - (parTotal||0),
          shownAt: nowMs()
        };
      };
      golfShowBanner('Course complete!', 2000, finalize);
      GOLF.state = 'banner';
    } else {
      golfResetHole(next);
    }
  }

  function golfSurfaceAt(x,y){
    // Default to fairway-like friction
    const DEFAULT_FRICTION = 0.989;
    if (!GOLF.hole) return DEFAULT_FRICTION;
    const { surfaces } = GOLF.hole;
    if (Array.isArray(surfaces)){
      for (let i=0;i<surfaces.length;i++){
        const surf = surfaces[i];
        if (surf && surf.poly && pointInPolygon(x,y,surf.poly)){
          if (typeof surf.friction === 'number') return surf.friction;
          // Map common surface types to tuned friction values
          const t = (surf.type||'').toLowerCase();
          if (t === 'fairway') return 0.989;
          if (t === 'sand') return 0.965;
          if (t === 'carpet' || t === 'fringe') return 0.975;
          if (t === 'marble' || t === 'green') return 0.992;
          if (t === 'rough') return 0.962;
          if (t === 'trees' || t === 'forest') return 0.91;
          if (t === 'water') return 0.935;
          return DEFAULT_FRICTION;
        }
      }
    }
    return DEFAULT_FRICTION;
  }

  function golfInPenalty(x,y){
    if (!GOLF.hole || !Array.isArray(GOLF.hole.penalties)) return null;
    for (const pen of GOLF.hole.penalties){
      if (pen && pen.poly && pointInPolygon(x,y, pen.poly)) return pen;
    }
    return null;
  }

  function golfClampBallWithinBounds(){
    if (!GOLF.hole || !GOLF.hole.bounds) return;
    const b = GOLF.hole.bounds;
    const r = GOLF.ball.r;
    GOLF.ball.x = clamp(GOLF.ball.x, b.x + r, b.x + b.w - r);
    GOLF.ball.y = clamp(GOLF.ball.y, b.y + r, b.y + b.h - r);
  }

  function golfProjectOnSegment(px, py, ax, ay, bx, by){
    const vx = bx - ax, vy = by - ay;
    const len2 = vx*vx + vy*vy || 1;
    let t = ((px-ax)*vx + (py-ay)*vy)/len2;
    t = clamp(t, 0, 1);
    return { x: ax + vx*t, y: ay + vy*t, t };
  }

  function golfReflect(normalX, normalY){
    const dot = GOLF.ball.vx*normalX + GOLF.ball.vy*normalY;
    if (dot < 0){
      const bounce = -1.8*dot;
      GOLF.ball.vx += normalX * bounce;
      GOLF.ball.vy += normalY * bounce;
    }
  }

  function golfHandleCollisions(prevX, prevY){
    if (!GOLF.hole) return;
    const r = GOLF.ball.r;
    const walls = GOLF.hole.walls || [];
    for (let i=0;i<walls.length;i++){
      const seg = walls[i];
      if (!seg || seg.length<2) continue;
      const [ax,ay] = seg[0];
      const [bx,by] = seg[1];
      const proj = golfProjectOnSegment(GOLF.ball.x, GOLF.ball.y, ax, ay, bx, by);
      const dx = GOLF.ball.x - proj.x;
      const dy = GOLF.ball.y - proj.y;
      const distSq = dx*dx + dy*dy;
      if (distSq <= (r*r)+0.01){
        const dist = Math.sqrt(distSq)||1;
        const overlap = r - dist + 0.5;
        const nx = dx / dist;
        const ny = dy / dist;
        GOLF.ball.x += nx * overlap;
        GOLF.ball.y += ny * overlap;
        golfReflect(nx, ny);
      }
    }
    golfClampBallWithinBounds();
  }

  function golfResolveSegments(ball, segments, bounce){
    if (!segments) return;
    for (const seg of segments){
      if (!seg) continue;
      const ax = seg.x1 ?? seg[0]?.[0];
      const ay = seg.y1 ?? seg[0]?.[1];
      const bx = seg.x2 ?? seg[1]?.[0];
      const by = seg.y2 ?? seg[1]?.[1];
      if ([ax,ay,bx,by].some(v=>typeof v!=='number')) continue;
      const proj = golfProjectOnSegment(ball.x, ball.y, ax, ay, bx, by);
      const dx = ball.x - proj.x;
      const dy = ball.y - proj.y;
      const distSq = dx*dx + dy*dy;
      if (distSq <= (ball.r*ball.r) + 0.01){
        const dist = Math.sqrt(distSq) || 1;
        const overlap = ball.r - dist + 0.4;
        const nx = dx / dist;
        const ny = dy / dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;
        const dot = ball.vx*nx + ball.vy*ny;
        if (dot < 0){
          ball.vx -= (1 + (bounce||1))*dot*nx;
          ball.vy -= (1 + (bounce||1))*dot*ny;
        }
      }
    }
  }

  function golfAddStroke(){
    const idx = GOLF.holeIndex;
    GOLF.strokesThisHole += 1;
    GOLF.strokes[idx] = GOLF.strokesThisHole;
  }

  // Drop ball back to tee center with optional penalty (+1 by default)
  function dropToTee(penalty=1){
    const hole = GOLF.hole;
    const spawn = hole?.spawn || hole?.tee || {};
    const teeRect = hole?.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const cx = teeRect.x + teeRect.w/2;
    const cy = teeRect.y + teeRect.h/2;
    GOLF.ball.x = cx;
    GOLF.ball.y = cy;
    GOLF.ball.vx = 0; GOLF.ball.vy = 0;
    if (penalty && penalty>0){
      for (let i=0;i<penalty;i++) golfAddStroke();
      GOLF.penaltyFlashUntil = nowMs() + 900;
      addCaption(cx, cy - 24, `Drop (+${penalty})`, 1100);
    } else {
      addCaption(cx, cy - 24, 'TEE', 1100);
    }
    GOLF.turn = 'player';
    GOLF.state = 'aim';
  }

  function golfLaunchShot(dirX, dirY, power){
    if (GOLF.turn !== 'player') return;
    const len = Math.hypot(dirX, dirY) || 1;
    if (len < 0.01){
      GOLF.state = 'aim';
      return;
    }
    const max = 720;
    const impulse = clamp(power, 40, max);
    const velocity = impulse * 0.12;
    const nx = dirX / len;
    const ny = dirY / len;
    GOLF.ball.vx = nx * velocity;
    GOLF.ball.vy = ny * velocity;
    GOLF.aimAngle = Math.atan2(GOLF.ball.vy, GOLF.ball.vx);
    GOLF.state = 'rolling';
    golfAddStroke();
    GOLF.turn = 'player_rolling';
  }

  function golfShowBanner(text, duration, onDone){
    GOLF.banner = { text, until: nowMs() + (duration||1800), onDone: onDone||null };
  }

  function golfGetOverlay(){
    if (!GOLF.hole || !GOLF.hole.overlay) return null;
    const key = GOLF.hole.overlay;
    if (GOLF.overlays.has(key)) return GOLF.overlays.get(key);
    const img = new Image();
    img.onload = ()=>{ img.__broken = false; };
    img.onerror = ()=>{ img.__broken = true; };
    img.src = key;
    GOLF.overlays.set(key, img);
    return img;
  }

  const BIDEN_LINES = [
    'Trump is a threat to our democracy.',
    'I‚Äôm the only one who can beat Trump.',
    'This is a battle for the soul of the nation.',
    'We must stand up to lies and defend the truth.',
    'Our democracy only works when we all do our part.'
  ];

  function addCaption(x, y, text, duration){
    const expires = nowMs() + (duration||1200);
    GOLF.captions.push({ id: ++GOLF.captionCounter, x, y, text, expires });
  }

  function planBidenStrokes(hole, parTarget){
    const targets = [];
    if (!hole) return targets;
    const teeRect = hole.teeRect || {x: (hole.spawn?.x||hole.tee?.x||150)-20, y: (hole.spawn?.y||hole.tee?.y||150)-20, w:40, h:40};
    const teeC = { x: teeRect.x + teeRect.w/2, y: teeRect.y + teeRect.h/2 };
    const cup = hole.cup || {x: teeC.x+100, y: teeC.y-60};
    const rails = Array.isArray(hole.rails) ? hole.rails : [];
    const xs = rails.flatMap(r => [r.x1??r[0]?.[0], r.x2??r[1]?.[0]]).filter(v=>typeof v==='number');
    const ys = rails.flatMap(r => [r.y1??r[0]?.[1], r.y2??r[1]?.[1]]).filter(v=>typeof v==='number');
    const mid = {
      x: xs.length ? (Math.min(...xs)+Math.max(...xs))/2 : (teeC.x+cup.x)/2,
      y: ys.length ? (Math.min(...ys)+Math.max(...ys))/2 : (teeC.y+cup.y)/2
    };
    const approach = { x: cup.x - 60, y: cup.y + 40 };
    const list = [teeC, mid, approach, cup];
    while (list.length < parTarget) list.splice(list.length-1, 0, { x:(mid.x+approach.x)/2, y:(mid.y+approach.y)/2 });
    while (list.length > parTarget) list.splice(1,1);
    list[list.length-1] = cup;
    return list.slice(1);
  }

  function scheduleBidenStroke(delay){
    if (!GOLF.biden || GOLF.opts?.versus === false) return;
    if (GOLF.turn !== 'biden' && GOLF.turn !== 'biden_wait') return;
    if (GOLF.bidenTimer) { clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer=null; }
    if (GOLF.biden.strokesHole >= GOLF.biden.parTarget) return;
    GOLF.biden.waiting = true;
    GOLF.bidenTimer = setTimeout(()=>{
      GOLF.bidenTimer = null;
      if (!GOLF.biden || GOLF.biden.strokesHole >= GOLF.biden.parTarget) return;
      const hole = GOLF.hole;
      const B = GOLF.biden;
      const target = GOLF.bidenPlan[Math.min(B.strokesHole, GOLF.bidenPlan.length-1)] || hole.cup || {x:B.ball.x+40,y:B.ball.y-40};
      const dx = target.x - B.ball.x;
      const dy = target.y - B.ball.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = Math.min(520, Math.max(140, dist * 2.0));
      const nx = dx / dist;
      const ny = dy / dist;
      B.ball.vx = nx * speed;
      B.ball.vy = ny * speed;
      B.ball.moving = true;
      B.waiting = false;
      B.strokesHole++;
      GOLF.turn = 'biden_rolling';
      const line = BIDEN_LINES[B.sayNext++ % BIDEN_LINES.length];
      const capX = GOLF.bidenAvatar?.x ?? target.x;
      const capY = (GOLF.bidenAvatar?.y ?? target.y) - 56;
      addCaption(capX, capY, line, 1600);
    }, delay || 800);
  }

  function golfUpdate(dt){
    if (scene !== 'golf') return;
    const now = nowMs();
    if (GOLF.banner && now > GOLF.banner.until){
      const done = GOLF.banner.onDone;
      GOLF.banner = null;
      if (typeof done === 'function') done();
    }

    if (GOLF.state === 'scorecard' || GOLF.state === 'intro'){ return; }

    // Keyboard charge handling
    if (GOLF.state === 'charging'){
      GOLF.charge.power = Math.min(GOLF.charge.power + dt * 420, 720);
      return;
    }

    if (GOLF.state === 'rolling'){
      const prevX = GOLF.ball.x;
      const prevY = GOLF.ball.y;
      GOLF.ball.x += GOLF.ball.vx * dt;
      GOLF.ball.y += GOLF.ball.vy * dt;
      golfHandleCollisions(prevX, prevY);
      // Resolve against rails (barriers) with elastic reflection
      try { const hole = GOLF.hole || {}; golfResolveSegments(GOLF.ball, hole.rails || hole.walls || [], 1.0); } catch(_){ }

      const friction = golfSurfaceAt(GOLF.ball.x, GOLF.ball.y);
      const decay = Math.pow(friction, dt * 60);
      GOLF.ball.vx *= decay;
      GOLF.ball.vy *= decay;
      // General damping
      GOLF.ball.vx *= 0.995;
      GOLF.ball.vy *= 0.995;

      const speed = Math.hypot(GOLF.ball.vx, GOLF.ball.vy);
      const penalty = golfInPenalty(GOLF.ball.x, GOLF.ball.y);
      if (penalty){
        dropToTee(1);
        return;
      }

      const cup = GOLF.hole.cup;
      if (cup && !GOLF._finishedHole){
        const d = Math.hypot(GOLF.ball.x - cup.x, GOLF.ball.y - cup.y);
        // Magnet effect: gentle pull toward cup within range at low speed
        if (d <= (cup.r||14) + MAGNET_RANGE && speed < MAGNET_SPEED){
          const nx = (cup.x - GOLF.ball.x) / (d||1);
          const ny = (cup.y - GOLF.ball.y) / (d||1);
          const strength = (1 - Math.max(0, (d - (cup.r||14)) / MAGNET_RANGE)) * MAGNET_STRENGTH;
          GOLF.ball.vx += nx * strength * dt;
          GOLF.ball.vy += ny * strength * dt;
        }
        if (d <= (cup.r||14) && speed < CUP_SPEED_THRESH){
          GOLF.ball.x = cup.x;
          GOLF.ball.y = cup.y;
          GOLF.ball.vx = 0; GOLF.ball.vy = 0;
          GOLF._finishedHole = true;
          if (!GOLF.holeBooked){
            GOLF.totalStrokes += GOLF.strokesThisHole;
            GOLF.holeBooked = true;
          }
          GOLF.turn = 'player';
          const strokes = GOLF.strokes[GOLF.holeIndex];
          const par = (GOLF.course?.par||[])[GOLF.holeIndex] || 3;
          const diff = strokes - par;
          const label = diff < 0 ? `${Math.abs(diff)} under par!` : diff === 0 ? 'Par!' : `${diff} over par`;
          golfShowBanner(label, 1600, ()=>golfAdvanceHole());
          if (GOLF.opts?.versus !== false && GOLF.biden){ GOLF.biden._finishedHole = true; }
          GOLF.state = 'banner';
          return;
        }
      }

      if (speed < 6){
        GOLF.ball.vx = 0;
        GOLF.ball.vy = 0;
        if (GOLF.turn === 'player_rolling'){
          if (GOLF.opts?.versus !== false && GOLF.biden){
            GOLF.turn = 'biden';
            GOLF.state = 'waiting';
            scheduleBidenStroke(900 + Math.random()*400);
          } else {
            GOLF.turn = 'player';
            GOLF.state = 'aim';
          }
        } else {
          GOLF.state = 'aim';
        }
      }
      return;
    }

    if (GOLF.opts?.versus !== false && GOLF.biden){
      const hole = GOLF.hole;
      const B = GOLF.biden;
      const bb = B.ball;
      if (bb.moving){
        bb.x += bb.vx * dt;
        bb.y += bb.vy * dt;
        const fr = golfSurfaceAt(bb.x, bb.y);
        const decay = Math.pow(fr, dt * 60);
        bb.vx *= decay;
        bb.vy *= decay;
        bb.vx *= 0.995;
        bb.vy *= 0.995;
        golfResolveSegments(bb, hole.rails || hole.walls || [], 1.0);
        const pen = golfInPenalty(bb.x, bb.y);
        if (pen){
          const wp = GOLF.bidenPlan[Math.max(0, B.strokesHole-1)] || {x: hole.teeRect.x + hole.teeRect.w/2, y: hole.teeRect.y + hole.teeRect.h/2};
          bb.x = wp.x;
          bb.y = wp.y;
          bb.vx = 0;
          bb.vy = 0;
          bb.moving = false;
        }
        if (B.strokesHole >= B.parTarget && !B._finishedHole){
          const cup = hole.cup;
          if (cup){
            const d = Math.hypot(bb.x - cup.x, bb.y - cup.y);
            const bbSpeed = Math.hypot(bb.vx, bb.vy);
            if (d < Math.max(15, (cup.r||14)+6) && bbSpeed < CUP_SPEED_THRESH){
              bb.x = cup.x;
              bb.y = cup.y;
              bb.vx = 0;
              bb.vy = 0;
              bb.moving = false;
              B._finishedHole = true;
            }
          }
        }
        if (Math.hypot(bb.vx, bb.vy) < 12){
          bb.vx = 0; bb.vy = 0; bb.moving = false;
        }
        if (!bb.moving && B.strokesHole >= B.parTarget && !B._booked){
          B.total += B.strokesHole;
          B._booked = true;
          GOLF.turn = 'player';
          if (!GOLF.holeBooked) GOLF.state = 'aim';
        }
      }
      if (!bb.moving && GOLF.turn.startsWith('biden')){
        GOLF.turn = 'player';
        if (!GOLF.holeBooked) GOLF.state = 'aim';
      }
    }

    if (GOLF.state === 'banner'){ return; }
  }

  function golfDraw(){
    if (scene !== 'golf') return;
    ctx.save();
    // Light sand background
    ctx.fillStyle = '#efe8d2';
    ctx.fillRect(0,0,W,H);
    
    // Compute and apply viewport transform to center bounds
    (function(){
      const b = (GOLF.hole && GOLF.hole.bounds) || {x:0,y:0,w:960,h:540};
      const pad = 0; // already sized to virtual
      const zoom = 0.5; // shrink course to 50%
      const baseScale = Math.min((W - pad*2) / (b.w||1), (H - pad*2) / (b.h||1));
      const scale = baseScale * zoom;
      const ox = (W - (b.w * scale)) * 0.5 - b.x * scale;
      const oy = (H - (b.h * scale)) * 0.5 - b.y * scale;
      GOLF.view = { scale, ox, oy };
      ctx.translate(ox, oy);
      ctx.scale(scale, scale);
    })();
    if (GOLF.hole && Array.isArray(GOLF.hole.surfaces)){
      GOLF.hole.surfaces.forEach(s=>{
        if (!s || !s.poly) return;
        const color = SURFACE_COLORS[s.type] || '#4c8640';
        ctx.fillStyle = color;
        fillSurface(ctx, s.poly);
      });
    }
    if (GOLF.hole && GOLF.hole.bounds){
      const img = golfGetOverlay();
      if (img && img.complete && !img.__broken && (img.naturalWidth||0) > 0){
        try {
          ctx.drawImage(img, GOLF.hole.bounds.x, GOLF.hole.bounds.y, GOLF.hole.bounds.w, GOLF.hole.bounds.h);
        } catch(_){}
      }
      // Optional debug frame around bounds (disabled)
    }
    if (GOLF.hole && Array.isArray(GOLF.hole.penalties)){
      ctx.fillStyle = 'rgba(30,90,200,0.28)';
      GOLF.hole.penalties.forEach(pen=>{
        if (!pen || !pen.poly) return;
        ctx.beginPath();
        pen.poly.forEach(([x,y],idx)=> idx?ctx.lineTo(x,y):ctx.moveTo(x,y));
        ctx.closePath();
        ctx.fill();
      });
    }
    // Draw rails (barriers) as visible lines
    if (GOLF.hole && Array.isArray(GOLF.hole.rails)){
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = '#9b6a2f';
      ctx.lineWidth = 4;
      for (const seg of GOLF.hole.rails){
        if (!seg) continue;
        const ax = seg.x1 ?? seg[0]?.[0];
        const ay = seg.y1 ?? seg[0]?.[1];
        const bx = seg.x2 ?? seg[1]?.[0];
        const by = seg.y2 ?? seg[1]?.[1];
        if ([ax,ay,bx,by].some(v=>typeof v!== 'number')) continue;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      }
      ctx.restore();
    }
    if (GOLF.hole && GOLF.hole.cup){
      const cup = GOLF.hole.cup;
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(cup.x, cup.y, (cup.r||14), 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(cup.x, cup.y, (cup.r||14)*0.55, 0, Math.PI*2);
      ctx.fill();
    }

    // Tee center marker (small cross + dot)
    if (GOLF.hole){
      const spawn = GOLF.hole.spawn || GOLF.hole.tee || {};
      const teeRect = GOLF.hole.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
      const cx = teeRect.x + teeRect.w/2;
      const cy = teeRect.y + teeRect.h/2;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,180,255,0.9)';
      ctx.fillStyle = 'rgba(0,180,255,0.7)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx - 6, cy); ctx.lineTo(cx + 6, cy);
      ctx.moveTo(cx, cy - 6); ctx.lineTo(cx, cy + 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Aim preview
    if (GOLF.state === 'aim') {
      if (GOLF.aim.active) {
        // Slingshot: tr√¶k v√¶k fra bolden ‚Üí linjen peger i flyveretningen
        ctx.setLineDash([8, 12]);
        ctx.strokeStyle = 'rgba(255,235,59,0.9)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(GOLF.ball.x, GOLF.ball.y);

        // Spejl musens punkt omkring bolden
        const toX = GOLF.ball.x + (GOLF.ball.x - GOLF.aim.currentX);
        const toY = GOLF.ball.y + (GOLF.ball.y - GOLF.aim.currentY);
        // Opdater vinkel i preview (peger fra bold mod spejlet punkt)
        GOLF.aimAngle = Math.atan2(toY - GOLF.ball.y, toX - GOLF.ball.x);

        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        // Passiv sigte n√•r man ikke tr√¶kker ‚Äì bruger GOLF.aimAngle
        const length = 80;
        const ex = GOLF.ball.x + Math.cos(GOLF.aimAngle) * length;
        const ey = GOLF.ball.y + Math.sin(GOLF.aimAngle) * length;
        ctx.setLineDash([4, 10]);
        ctx.strokeStyle = 'rgba(255,235,59,0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(GOLF.ball.x, GOLF.ball.y);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Ball (player)
    ctx.fillStyle = '#f8f8f8';
    if (GOLF.penaltyFlashUntil > nowMs()) ctx.fillStyle = '#ff8a80';
    ctx.beginPath();
    ctx.arc(GOLF.ball.x, GOLF.ball.y, GOLF.ball.r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='#222'; ctx.lineWidth=1;
    ctx.stroke();

    // Player avatar stands near tee (ball rolls independently)
    drawTrumpGolfStanding(ctx, GOLF.playerStand.x, GOLF.playerStand.y);

    if (GOLF.opts?.versus !== false && GOLF.biden){
      const bb = GOLF.biden.ball;
      ctx.fillStyle = '#a7c3ff';
      ctx.beginPath();
      ctx.arc(bb.x, bb.y, bb.r, 0, Math.PI*2);
      ctx.fill();
      drawBidenGolfStanding(ctx, GOLF.bidenAvatar.x, GOLF.bidenAvatar.y, 1.08);
    }

    // Charge meter
    if (GOLF.state === 'charging'){
      const w = 160, h = 16;
      const x = W/2 - w/2, y = H - 80;
      ctx.fillStyle='rgba(0,0,0,0.6)';
      ctx.fillRect(x-6,y-6,w+12,h+12);
      ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2;
      ctx.strokeRect(x,y,w,h);
      const pct = GOLF.charge.power / 720;
      ctx.fillStyle='#ffeb3b';
      ctx.fillRect(x+2,y+2,(w-4)*pct,h-4);
      ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='center';
      ctx.fillText('Space: release to putt', W/2, y-10);
      ctx.textAlign='left';
    }

    // Score and hole info
    if (GOLF.course){
      ctx.fillStyle='rgba(0,0,0,0.55)';
      ctx.fillRect(24,24,220,74);
      ctx.fillStyle='#fff';
      ctx.font='bold 16px system-ui';
      ctx.fillText(`${GOLF.courseName}`, 36, 48);
      const par = (GOLF.course.par||[])[GOLF.holeIndex] || 3;
      ctx.font='13px system-ui';
      ctx.fillText(`Hole ${GOLF.hole?.id||GOLF.holeIndex+1} ¬∑ Par ${par}`, 36, 70);
      const playerCurrent = GOLF.totalStrokes + (GOLF.holeBooked ? 0 : GOLF.strokesThisHole);
      const joeCurrent = (GOLF.opts?.versus !== false && GOLF.biden)
        ? (GOLF.biden.total + (GOLF.biden._booked ? 0 : GOLF.biden.strokesHole))
        : null;
      const scoreLine = joeCurrent != null ? `You: ${playerCurrent}  |  Joe: ${joeCurrent}` : `Strokes: ${playerCurrent}`;
      ctx.fillText(scoreLine, 36, 90);
    }

    if (GOLF.state === 'waiting' && GOLF.turn.startsWith('biden')){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const boxW = 260, boxH = 46;
      const bx = W/2 - boxW/2;
      const by = H - 150;
      ctx.fillRect(bx, by, boxW, boxH);
      ctx.fillStyle = '#fff';
      ctx.font = '13px system-ui';
      ctx.textAlign='center';
      ctx.fillText('Sleepy Joe is lining up his shot‚Ä¶', bx + boxW/2, by + 26);
      drawBidenIntroHead(ctx, bx + boxW - 70, by - 6, 1.1);
      ctx.textAlign='left';
    }

    const now = nowMs();
    GOLF.captions = GOLF.captions.filter(c => c.expires > now);
    GOLF.captions.forEach(c => {
      const alpha = Math.max(0, (c.expires - now)/400);
      ctx.save();
      ctx.globalAlpha = Math.min(1, alpha);
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.font = '600 12px system-ui';
      const text = c.text;
      const width = Math.min(360, 12 + ctx.measureText(text).width);
      ctx.fillRect(c.x - width/2, c.y - 30, width, 22);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, c.x, c.y - 19);
      ctx.restore();
    });

    if (GOLF.banner){
      ctx.fillStyle='rgba(0,0,0,0.7)';
      const bw = 320, bh = 50;
      ctx.fillRect(W/2-bw/2, 40, bw, bh);
      ctx.fillStyle='#fff'; ctx.font='bold 20px system-ui'; ctx.textAlign='center';
      ctx.fillText(GOLF.banner.text, W/2, 72);
      ctx.textAlign='left';
    }

    if (GOLF.state === 'scorecard' && GOLF.scorecard){
      ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
      const cardW = Math.min(W*0.6, 520), cardH = Math.min(H*0.6, 360);
      const cx = (W-cardW)/2, cy = (H-cardH)/2;
      ctx.fillStyle='#fefefe'; ctx.fillRect(cx, cy, cardW, cardH);
      ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.strokeRect(cx, cy, cardW, cardH);
      ctx.fillStyle='#111'; ctx.textAlign='center';
      ctx.font='bold 22px system-ui';
      ctx.fillText('Scorecard', W/2, cy+40);
      ctx.font='15px system-ui';
      const headers = ['Hole','Par','Strokes'];
      headers.forEach((txt,i)=> ctx.fillText(txt, cx + (i+1)*cardW/4, cy+72));
      const parArr = GOLF.course.par || [];
      GOLF.course.holes.forEach((hole, idx)=>{
        const rowY = cy + 110 + idx*28;
        ctx.fillText(`${hole.id||idx+1}`, cx + cardW/4, rowY);
        ctx.fillText(`${parArr[idx]||3}`, cx + cardW/2, rowY);
        ctx.fillText(`${GOLF.strokes[idx]||0}`, cx + 3*cardW/4, rowY);
      });
      const totalY = cy + cardH - 90;
      const you = GOLF.scorecard.total || 0;
      const joe = GOLF.scorecard.joe || 0;
      const parTotal = GOLF.scorecard.par || 0;
      const diff = you - parTotal;
      const diffText = `${diff>0?'+':''}${diff}`;
      ctx.font='bold 16px system-ui';
      ctx.fillText(`Totals ‚Äî You: ${you} (${diffText})  |  Joe: ${joe}`, W/2, totalY);
      const win = you <= joe;
      ctx.font='14px system-ui';
      ctx.fillText(win ? 'You proved you‚Äôre the best president ever. Self-esteem ramps to 11.' : 'You obviously lied ‚Äî all your lies fall apart.', W/2, totalY+30);
      ctx.font='13px system-ui';
      ctx.fillText('Press Enter to exit', W/2, totalY+56);
      ctx.textAlign='left';
      ctx.restore();
      return;
    }

    if (GOLF.state === 'intro'){
      const bounds = GOLF.hole?.bounds || { x: 0, y: 0, w: VIRTUAL_W, h: VIRTUAL_H };
      const scale = GOLF.view?.scale || 1;
      const ox = GOLF.view?.ox || 0;
      const oy = GOLF.view?.oy || 0;
      const centerX = ox + (bounds.x + bounds.w/2) * scale;
      const centerY = oy + (bounds.y + bounds.h/2) * scale;
      const w = Math.min(520, W-120);
      const h = Math.min(260, H-140);
      const x = centerX - w/2;
      const y = centerY - h/2;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#f8f1d2';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = '#c59a31'; ctx.lineWidth=4;
      ctx.strokeRect(x, y, w, h);
      drawTrumpIntroHead(ctx, x + 50, y + 40, 1.6);
      drawBidenIntroHead(ctx, x + w - 110, y + 40, 1.6);
      ctx.fillStyle = '#2a2a2a';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign='center';
      ctx.fillText('Trump vs. Sleepy Joe', x + w/2, y + 78);
      ctx.font = '15px system-ui';
      ctx.fillText('Du m√• ikke tabe denne duel.', x + w/2, y + 110);
      ctx.font = '14px system-ui';
      ctx.fillText('Tr√¶k fra tee v√¶k fra hullet for at sigte og v√¶lge kraft.', x + w/2, y + 144);
      ctx.fillText('Slip for at skyde. Tastatur: piletaster + mellemrum.', x + w/2, y + 168);
      ctx.fillText('Sleepy Joe sl√•r efter dig ‚Äì hold f√∏ringen.', x + w/2, y + 192);
      ctx.font = 'bold 14px system-ui';
      ctx.fillText('Tryk p√• en tast for at begynde.', x + w/2, y + h - 34);
      ctx.textAlign='left';
      ctx.restore();
      return;
    }

    ctx.restore();
  }

  function golfHandleKeyDown(e, key){
    if (scene !== 'golf') return false;
    if (GOLF.state === 'intro'){
      if (!GOLF.introDismissReady) return true;
      GOLF.introActive = false;
      GOLF.state = 'aim';
      GOLF.turn = 'player';
      return true;
    }
    if (GOLF.state === 'scorecard'){
      if (key==='enter' || e.code==='Enter'){
        GOLF.state = 'aim';
        GOLF.scorecard = null;
        GOLF.banner = null;
        switchScene('greenland');
        return true;
      }
      return false;
    }
    if (key==='r'){
      if (GOLF.state !== 'scorecard'){
        dropToTee(1);
      }
      return true;
    }
    if (key==='escape' || key==='esc'){
      GOLF.banner = null;
      if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer=null; }
      switchScene('greenland');
      return true;
    }
    if (GOLF.state === 'banner' && GOLF.banner && (key==='enter' || e.code==='Enter')){
      GOLF.banner.until = nowMs();
      return true;
    }
    if (GOLF.state === 'aim' && GOLF.turn === 'player'){
      if (key==='arrowleft'){ GOLF.aimAngle -= 0.12; return true; }
      if (key==='arrowright'){ GOLF.aimAngle += 0.12; return true; }
      if (key===' ' || e.code==='Space'){
        GOLF.state = 'charging';
        GOLF.charge.active = true;
        GOLF.charge.power = 0;
        GOLF.charge.dirX = Math.cos(GOLF.aimAngle);
        GOLF.charge.dirY = Math.sin(GOLF.aimAngle);
        return true;
      }
    } else if (GOLF.state === 'charging' && GOLF.turn === 'player'){
      if (key==='arrowleft'){ GOLF.aimAngle -= 0.08; GOLF.charge.dirX = Math.cos(GOLF.aimAngle); GOLF.charge.dirY = Math.sin(GOLF.aimAngle); return true; }
      if (key==='arrowright'){ GOLF.aimAngle += 0.08; GOLF.charge.dirX = Math.cos(GOLF.aimAngle); GOLF.charge.dirY = Math.sin(GOLF.aimAngle); return true; }
    }
    return false;
  }

  function golfHandleKeyUp(e, key){
    if (scene !== 'golf') return false;
    if (GOLF.state === 'charging' && GOLF.turn === 'player' && (key===' ' || e.code==='Space')){
      GOLF.state = 'rolling';
      GOLF.charge.active = false;
      // Normaliser tastetryk-opladning til [0,1]
      const powerNorm = Math.min(1, Math.max(0, GOLF.charge.power / 720));
      golfStrike(GOLF.aimAngle, powerNorm);
      return true;
    }
    return false;
  }

  function drawTrumpGolfStanding(ctx, x, y){
    const prevWalking = player.walking;
    const prevFacing = player.facing;
    const prevX = player.x;
    const prevY = player.y;
    const scale = 1.08;
    try {
      player.walking = false;
      player.facing = 1;
      player.x = 0;
      player.y = 0;
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      drawTrump(0, 0, player.facing);
      ctx.restore();
    } finally {
      player.walking = prevWalking;
      player.facing = prevFacing;
      player.x = prevX;
      player.y = prevY;
    }
  }

  function drawBidenGolfStanding(ctx, x, y, scale){
    const s = scale || 1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    ctx.translate(0, -46);
    // Shoes & legs
    ctx.fillStyle = '#1f1f1f';
    ctx.fillRect(-12, 42, 10, 10);
    ctx.fillRect(2, 42, 10, 10);
    ctx.fillStyle = '#1f3b7a';
    ctx.fillRect(-12, 30, 10, 12);
    ctx.fillRect(2, 30, 10, 12);
    // Suit
    ctx.fillStyle = '#2051a6';
    ctx.fillRect(-18, 6, 36, 30);
    // Shirt + tie
    ctx.fillStyle = '#e3ecff';
    ctx.fillRect(-12, 10, 24, 18);
    ctx.fillStyle = '#64b5f6';
    ctx.fillRect(-2, 10, 4, 23);
    // Head
    ctx.fillStyle = '#f1d2b3';
    ctx.fillRect(-12, -6, 24, 16);
    ctx.fillStyle = '#c0c6cf';
    ctx.fillRect(-14, -12, 28, 8);
    // Sunglasses
    ctx.fillStyle = '#111';
    ctx.fillRect(-10, -1, 8, 4);
    ctx.fillRect(2, -1, 8, 4);
    ctx.fillRect(-2, 0, 4, 2);
    // Mouth
    ctx.fillStyle = '#c25a5a';
    ctx.fillRect(-6, 6, 12, 2);
    ctx.restore();
  }

  const SURFACE_COLORS = {
    fairway: '#5ba64d',
    green: '#8dd35f',
    fringe: '#7fbc54',
    rough: '#3d7934',
    water: '#3c7bd6',
    sand: '#f2deb0',
    trees: '#2e7d32'
  };

  // Optional Text-to-Speech helper with robust fallback captions
  (function initTTS(){
    const TTS = { ready:false, voice:null };
    function pickVoice(){
      try {
        const voices = window.speechSynthesis?.getVoices?.() || [];
        if (!voices.length) return;
        // Prefer en-US, else first
        TTS.voice = voices.find(v=>/en-US/i.test(v.lang)) || voices[0] || null;
        TTS.ready = !!TTS.voice;
      } catch(_){ TTS.ready=false; TTS.voice=null; }
    }
    try { window.speechSynthesis?.addEventListener?.('voiceschanged', pickVoice); } catch(_){ }
    try { pickVoice(); } catch(_){ }
    window.speakLine = function(text, opts){
      // Always show caption fallback
      try { addCaption((opts&&opts.x)||W/2, (opts&&opts.y)||H/2, String(text||''), 1200); } catch(_){ }
      // Try TTS
      try {
        if (!('speechSynthesis' in window)) return false;
        const u = new SpeechSynthesisUtterance(String(text||''));
        if (TTS.voice) u.voice = TTS.voice;
        window.speechSynthesis.speak(u);
        return true;
      } catch(_){ return false; }
    };
  })();

  function fillSurface(ctx, poly){
    ctx.beginPath();
    poly.forEach(([px,py], idx)=> idx ? ctx.lineTo(px,py) : ctx.moveTo(px,py));
    ctx.closePath();
    ctx.fill();
  }

  let trumpHeadSprite = null;
  let bidenHeadSprite = null;

  function ensureTrumpHeadSprite(){
    if (trumpHeadSprite) return trumpHeadSprite;
    const c = document.createElement('canvas');
    c.width = 40; c.height = 36;
    const g = c.getContext('2d');
    drawTrumpHeadHUDIcon(g, c.width, c.height);
    trumpHeadSprite = c;
    return c;
  }

  function ensureBidenHeadSprite(){
    if (bidenHeadSprite) return bidenHeadSprite;
    const c = document.createElement('canvas');
    c.width = 40; c.height = 36;
    const g = c.getContext('2d');
    g.fillStyle = '#2b4f9c';
    g.fillRect(4, 14, 32, 18);
    g.fillStyle = '#f6d6b0';
    g.fillRect(12, 4, 16, 14);
    g.fillStyle = '#c8b890';
    g.fillRect(12, 0, 16, 6);
    g.fillStyle = '#fff';
    g.fillRect(16, 9, 6, 2);
    g.fillRect(22, 9, 6, 2);
    g.fillStyle = '#2b4f9c';
    g.fillRect(16, 11, 4, 1);
    g.fillRect(22, 11, 4, 1);
    g.fillStyle = '#d14a4a';
    g.fillRect(18, 15, 8, 2);
    bidenHeadSprite = c;
    return c;
  }

  function drawTrumpIntroHead(ctx, x, y, scale){
    const sprite = ensureTrumpHeadSprite();
    ctx.drawImage(sprite, x, y, sprite.width*scale, sprite.height*scale);
  }

  function drawBidenIntroHead(ctx, x, y, scale){
    const sprite = ensureBidenHeadSprite();
    ctx.drawImage(sprite, x, y, sprite.width*scale, sprite.height*scale);
  }

  // ---------- Glacier explosion system ----------
  let glacierExplosion = {
    active: false,
    waterLevel: 0,
    explosions: [],
    iceChunks: []
  };

  function resetStateDefaults(){
    GL.state = { flagPlanted:false, bearGone:false, hasTweeted:false };
    shopTutorialShown = false;
    if (invEl){
      invEl.classList.add('hidden');
      invEl.setAttribute('aria-hidden','true');
    }
  }

  function resetGreenland(){
    const g = H - world.floor;
    player.x = GAME_CONSTANTS.WORLD.PLAYER_START_X*CFG.SCALE; player.y = g;
    Object.assign(GL.mine,  {x:GAME_CONSTANTS.WORLD.GREENLAND.MINE_X*CFG.SCALE, y:g});
    Object.assign(GL.rig,   {x:GAME_CONSTANTS.WORLD.GREENLAND.RIG_X*CFG.SCALE, y:g});
    Object.assign(GL.heli,  {x:GAME_CONSTANTS.WORLD.GREENLAND.HELI_X*CFG.SCALE, y:g-GAME_CONSTANTS.WORLD.HELI_Y_OFFSET*CFG.SCALE});
    Object.assign(GL.bear,  {x:GAME_CONSTANTS.WORLD.GREENLAND.BEAR_X*CFG.SCALE, y:g, alive:true, hp:4, speakingUntil:0, angry:false, chasing:false, speed:GAME_CONSTANTS.PHYSICS.BEAR_SPEED, facing:1});
    Object.assign(GL.mette, {x:GAME_CONSTANTS.WORLD.GREENLAND.METTE_X*CFG.SCALE, y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28});
    Object.assign(GL.shop, { x: 1120*CFG.SCALE, y: g, type:'shop' });
    // Default items start in inventory; keep others available as pickups
    GL.items.forEach(it => {
      if (it.id==='tan' || it.id==='shoes' || it.id==='maga') it.collected = true;
      else it.collected = false;
    });
    GL.flag=null;
    // Reset glaciers - place them on ground level so Trump can interact
    GL.glaciers.forEach((glacier, i) => {
      const baseX = [200, 900][i];
      glacier.x = baseX*CFG.SCALE; 
      glacier.y = g; // Place bottom on ground
      glacier.blown = false;
    });
    GL.state.glaciersBlown = false;
    GL.state.hasSeenGlaciers = false;
    // Initialize floating gold bars (require jumping to collect) - lowered to be reachable
    GL.coins = [
      {x:250*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'},
      {x:450*CFG.SCALE, y:g - 45*CFG.SCALE, collected:false, type:'coin'},
      {x:650*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'},
      {x:850*CFG.SCALE, y:g - 42*CFG.SCALE, collected:false, type:'coin'},
      {x:200*CFG.SCALE, y:g - 30*CFG.SCALE, collected:false, type:'coin'},
      {x:750*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'},
      {x:550*CFG.SCALE, y:g - 43*CFG.SCALE, collected:false, type:'coin'},
      {x:350*CFG.SCALE, y:g - 37*CFG.SCALE, collected:false, type:'coin'},
      {x:950*CFG.SCALE, y:g - 33*CFG.SCALE, collected:false, type:'coin'},
      {x:150*CFG.SCALE, y:g - 41*CFG.SCALE, collected:false, type:'coin'},
      // Bonus MAGA hat gold bars (require super jump)
      {x:400*CFG.SCALE, y:g - 60*CFG.SCALE, collected:false, type:'coin'},
      {x:800*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}
    ];
    // Reset glacier explosion state
    glacierExplosion.active = false;
    glacierExplosion.waterLevel = 0;
    glacierExplosion.explosions = [];
    glacierExplosion.iceChunks = [];
    if (!introPlayed) scheduleHeliIntro('Touchdown in Greenland ‚Äî tremendous ice! Helicopter goes anywhere.');
    // init clouds
    CLOUDS = [];
    const n = 6; for (let i=0;i<n;i++){
      CLOUDS.push({ x: Math.random()*W, y: 40*CFG.SCALE + Math.random()*120*CFG.SCALE, w: 80*CFG.SCALE + Math.random()*100*CFG.SCALE, h: 24*CFG.SCALE, vx: (10+Math.random()*20)*CFG.SCALE, a: 0.15+Math.random()*0.1 });
    }
    // Position and ensure pickups
    // Ensure default inventory items are present
    ensureDefaultInventory();
  }
  function resetOval(){
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; player.y = g;
    Object.assign(OV.door,  {x:140*CFG.SCALE, y:g});
    Object.assign(OV.aide,  {x:720*CFG.SCALE, y:g, speakingUntil:0});
    Object.assign(OV.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    Object.assign(OV.yes,   {x:980*CFG.SCALE, y:g, speakingUntil:0});
    // yes-men members state for blink/nod
    // Two women (index 0 and 2) and one man (index 1)
    OV.yes.members = [
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:false },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true }
    ];
    // Initialize desk buttons positioned on desk top
    const deskTopY = H - world.floor + 30*CFG.SCALE - 36*CFG.SCALE; // from drawOvalDesk
    const deskLeft = 420*CFG.SCALE - 8*CFG.SCALE; const deskRight = deskLeft + (340*CFG.SCALE + 16*CFG.SCALE);
    const cols = 7; OV.buttons = [];
    const palette = ['#c62828','#1565c0','#2e7d32','#6a1b9a','#ef6c00','#00838f','#ad1457'];
    for (let i=0;i<cols;i++){
      const x = deskLeft + (i+0.7)*(deskRight-deskLeft)/(cols+0.5);
      const w = (20 + Math.random()*12)*CFG.SCALE; const h=(10+Math.random()*6)*CFG.SCALE;
      OV.buttons.push({x, y:deskTopY, w, h, color: palette[i%palette.length], type:'button', label: ''});
    }
    if (OV.buttons.length){
      const b0 = OV.buttons[0];
      b0.w *= 1.6; b0.h *= 1.4; b0.color = '#c62828'; b0.type='button'; // nuclear visually big red
    }
    // Initialize floating gold bars in Oval Office - lowered to be reachable
    OV.coins = [
      {x:300*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'},
      {x:500*CFG.SCALE, y:g - 45*CFG.SCALE, collected:false, type:'coin'},
      {x:700*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'},
      {x:900*CFG.SCALE, y:g - 43*CFG.SCALE, collected:false, type:'coin'},
      {x:400*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'},
      {x:800*CFG.SCALE, y:g - 42*CFG.SCALE, collected:false, type:'coin'},
      // Bonus MAGA hat gold bar (require super jump)
      {x:600*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}
    ];
  }
  function resetKremlin(){
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; player.y = g;
    Object.assign(KR.door,  {x:120*CFG.SCALE, y:g});
    Object.assign(KR.putin, {x: (W - 220*CFG.SCALE), y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28});
    Object.assign(KR.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    // Initialize security camera
    Object.assign(KR.camera, {x: W/2, y: H/3, angle: Math.PI/4, sweepStart: nowMs(), discovered: false, flashUntil: 0});
    KR.statues = [
      {id:'stat1', name:'Guldstatue I', x:(420*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:1},
      {id:'stat2', name:'Guldstatue II', x:(560*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:2},
      {id:'stat3', name:'Guldstatue III', x:(700*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:3}
    ];
    // Initialize floating gold bars in Kremlin - reduced to only 3 regular bars, lowered to be reachable
    KR.coins = [
      {x:400*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'}, // Near center/table
      {x:700*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'}, // Near Putin area
      {x:200*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'}, // Corner position
      // Bonus MAGA hat gold bar (require super jump)
      {x:500*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}  // High above table
    ];
  }
  
  // ---------- Epstein Scene Functions ----------
  const DUMMY_NAMES = [
    'John Anderson', 'Sarah Mitchell', 'Robert Johnson', 'Emily Davis', 'Michael Brown',
    'Jessica Wilson', 'David Martinez', 'Ashley Taylor', 'Christopher Lee', 'Amanda White',
    'James Thompson', 'Nicole Garcia', 'Daniel Rodriguez', 'Melissa Clark', 'Matthew Lopez',
    'Stephanie Hill', 'Kevin Green', 'Lauren Adams', 'Brian Baker', 'Christina Nelson',
    'Ryan Carter', 'Megan Phillips', 'Justin Turner', 'Rachel Collins', 'Tyler Evans',
    'Samantha Stewart', 'Brandon Morris', 'Victoria Reed', 'Jonathan Cook', 'Heather Bell',
    'Nicholas Wright', 'Courtney Murphy', 'Aaron Rivera', 'Danielle Cooper', 'Jeremy King'
  ];
  // Variations of Trump's name used in Epstein scene redaction
  const TRUMP_NAME_VARIATIONS = [
    'Donald Trump', 'Donald J. Trump', 'Donald John Trump', 'D. Trump',
    'Mr. Trump', 'President Trump', 'POTUS Trump', 'DJ Trump',
    'The Donald', 'Donald'
  ];
  
  const DOC_TEMPLATES = [
    "Meeting scheduled with {name} on Tuesday at 3:00 PM regarding the Atlantic City project.",
    "{name} called to discuss the upcoming real estate acquisition in Manhattan.",
    "Confidential: {name} was present at the Mar-a-Lago dinner party on November 15th.",
    "Flight manifests show {name} traveled to Nassau on private aircraft N218DT.",
    "{name} contacted the office requesting a private meeting with senior leadership.",
    "Internal memo: {name} has been cleared for access to the VIP guest list.",
    "Phone records indicate multiple calls between {name} and the executive office.",
    "{name} was photographed at the charity gala fundraiser at Trump International.",
    "Security clearance approved for {name} - access level: Executive Floor only.",
    "Travel expenses reimbursement for {name}: $15,000 for Caribbean business trip."
  ];

  function generateDocument() {
    const lines = [];
    const numLines = 15 + Math.floor(Math.random() * 8); // 15-23 lines per document
    for (let i = 0; i < numLines; i++) {
      const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
      const dummyName = DUMMY_NAMES[Math.floor(Math.random() * DUMMY_NAMES.length)];
      lines.push({
        text: template.replace('{name}', dummyName),
        containsTrump: false,
        protectedName: false,
        redacted: false
      });
    }
    return lines;
  }
  
  function resetEpstein() {
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; 
    player.y = g;
    
    // Reset epstein game state
    Object.assign(EP, {
      papers: [],
      currentLine: 0,
      scrollSpeed: 0.5,
      scrollY: 0,
      timeElapsed: 0,
      missedTrumps: 0,
      foundTrumps: 0,
      gameActive: false,
      gameStartTime: 0,
      trumpLocations: [],
      generatedDocs: false,
      protectedClicks: 0,
      failedByProtected: false,
      assistUntil: 0,
      toasts: [],
      crosses: [],
      visibleDoc: 1,
      paused: false,
      finalArt: { redacted: false },
      finalArtRect: null,
      artHeightPx: 0
    });
    
    // Generate documents - base content
    for (let i = 0; i < 12; i++) {
      EP.papers.push(generateDocument());
    }
    EP.generatedDocs = true;

    // Distribute exactly N Trump targets more evenly across documents
    let placedTrump = 0;
    const maxAttempts = 4000;
    let attempts = 0;
    const nDocs = EP.papers.length;
    for (let i = 0; i < EP.totalTrumpTargets && attempts < maxAttempts; i++) {
      // Evenly map index to document range, then add a small random jitter of ¬±1 doc
      const baseDoc = Math.floor((i * nDocs) / Math.max(1, EP.totalTrumpTargets));
      const jitter = Math.max(0, Math.min(nDocs-1, baseDoc + (Math.random()<0.5?-1:1)));
      const candidates = [baseDoc, jitter].filter((v,idx,arr)=>v>=0 && v<nDocs && arr.indexOf(v)===idx);
      let placed = false;
      for (const d of candidates){
        for (let tries=0; tries<40; tries++){
          const doc = EP.papers[d];
          const li = Math.floor(Math.random() * doc.length);
          const line = doc[li];
          if (line.containsTrump || line.protectedName) continue;
          const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
          const variant = TRUMP_NAME_VARIATIONS[Math.floor(Math.random() * TRUMP_NAME_VARIATIONS.length)];
          line.text = template.replace('{name}', variant);
          line.containsTrump = true;
          placedTrump++; placed = true; break;
        }
        if (placed) break;
      }
      if (!placed) attempts++;
    }

    // Ensure last document contains at least one Trump line
    if (nDocs > 0) {
      const last = EP.papers[nDocs-1];
      const hasTrump = last.some(l => l.containsTrump);
      if (!hasTrump) {
        for (let tries=0; tries<200; tries++){
          const li = Math.floor(Math.random()*last.length);
          const line = last[li];
          if (!line.containsTrump && !line.protectedName){
            const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
            const variant = TRUMP_NAME_VARIATIONS[Math.floor(Math.random() * TRUMP_NAME_VARIATIONS.length)];
            line.text = template.replace('{name}', variant);
            line.containsTrump = true;
            placedTrump++;
            break;
          }
        }
      }
    }
    
    // Insert protected names (Bill Clinton, Bill Gates) ‚Äî e.g., 3 each
    const protectedCounts = { 'Bill Clinton': 3, 'Bill Gates': 3 };
    for (const [pname, count] of Object.entries(protectedCounts)){
      let placed = 0, tries = 0;
      while (placed < count && tries++ < maxAttempts) {
        const d = Math.floor(Math.random() * EP.papers.length);
        const doc = EP.papers[d];
        const li = Math.floor(Math.random() * doc.length);
        const line = doc[li];
        if (line.containsTrump || line.protectedName) continue;
        const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
        line.text = template.replace('{name}', pname);
        line.protectedName = true;
        placed++;
      }
    }

    // Instruction card
    openInfoCard(
      `Trump er NATURLIGVIS ikke n√¶vnt i Epstein-papirerne.\nOverstreg de 10 fejltagelser, s√• demokraternes konspirationsteorier ikke spredes!\n\nüéØ Klik p√• R√òDE (Donald Trump)\nüõë Undg√• BL√Ö (Clinton/Gates)\n‚ö†Ô∏è ${EP.missesAllowed+1}+ miss = nederlag\n‚è∏Ô∏è P for pause/genoptag\n\nTryk en vilk√•rlig tast for at begynde`,
      () => { EP.gameActive = true; EP.gameStartTime = nowMs(); closeInfoCard(); }
    );
    
    // Position door for exit
    Object.assign(EP.door, {x: 120*CFG.SCALE, y: g});
  }
  
  function updateEpsteinGame() {
    if (!EP.gameActive) return;
    if (EP.paused) return;
    
    const currentTime = nowMs();
    EP.timeElapsed = currentTime - (EP.gameStartTime || currentTime);
    
    // Increase scroll speed from higher start to higher end based on scroll progress
    const paperY = H * 0.1;
    const lineHeight = 20 * CFG.SCALE;
    // compute total content height (30px top + headers + lines + gaps + final art)
    let totalHeight = 30 * CFG.SCALE; 
    for (let d = 0; d < EP.papers.length; d++) {
      totalHeight += lineHeight * 1.5; // header
      totalHeight += EP.papers[d].length * lineHeight; // lines
      totalHeight += lineHeight; // gap
    }
    // Include final art height if known (fallback to estimate)
    totalHeight += (EP.artHeightPx || 320 * CFG.SCALE);
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    const scrolled = Math.max(0, Math.min(totalHeight, (paperY + 30 * CFG.SCALE) - startY));
    const k = totalHeight > 0 ? (scrolled / totalHeight) : 0;
    EP.scrollSpeed = (1.2 + k * 2.8) * 1.25; // +25% tempo across the sequence
    // Adaptive assist: slow slightly for a few seconds after a miss
    if (EP.assistUntil && nowMs() < EP.assistUntil) EP.scrollSpeed *= 0.85;
    
    // Update scroll position - reduced base speed, with precise hold at final art if requested
    const scrollDelta = EP.scrollSpeed * 0.75 * CFG.SCALE;
    let nextScroll = EP.scrollY + scrollDelta;
    if (EP.stopAtArt && EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
      const targetTop = paperY + (EP.holdAtArtMargin || 40) * CFG.SCALE;
      const artTopNow = EP.finalArtRect.y; // already includes current scrollY
      const artTopNext = artTopNow - scrollDelta; // after applying delta, art moves up by delta
      if (artTopNext <= targetTop) {
        // Clamp so after updating, art sits exactly at targetTop
        nextScroll = EP.scrollY + (artTopNow - targetTop);
        EP.atArtHold = true;
      } else {
        EP.atArtHold = false;
      }
    } else {
      EP.atArtHold = false;
    }
    EP.scrollY = nextScroll;
    
    // Check for missed Trump names
    checkMissedTrumps();
    
    // End conditions
    if (EP.failedByProtected || (EP.protectedClicks > (EP.protectedLimit||0))) { endEpsteinGame('protected_click'); return; }
    if (EP.missedTrumps > EP.missesAllowed) { endEpsteinGame('misses'); return; }
    // No auto-finish; we stop at the drawing and wait for click
  }
  
  function drawEpsteinScene() {
    // Desktop background
    ctx.fillStyle = '#8B4513'; // Dark wood desk
    ctx.fillRect(0, 0, W, H);
    
    // Paper area (white background)
    const paperX = W * 0.2;
    const paperY = H * 0.1; 
    const paperW = W * 0.6;
    const paperH = H * 0.8;
    
    ctx.fillStyle = '#f8f8f8'; // Off-white paper
    ctx.fillRect(paperX, paperY, paperW, paperH);
    
    // Paper shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(paperX + 4, paperY + 4, paperW, paperH);
    
    // Draw document lines
    if (EP.papers.length > 0) {
      ctx.save();
      
      // Clip to paper area
      ctx.beginPath();
      ctx.rect(paperX, paperY, paperW, paperH);
      ctx.clip();
      
      drawDocumentContent(paperX, paperY, paperW, paperH);
      
      ctx.restore();
    }
    // Doc progress label removed per request
    
    // Draw HUD
    drawEpsteinHUD();

    // Paused overlay
    if (EP.gameActive && EP.paused) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${24*CFG.SCALE}px system-ui`;
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', W/2, H/2);
      ctx.restore();
    }

    // Draw toasts overlay (cross/arrow overlay removed for cleaner UX)
    if (EP.toasts && EP.toasts.length){
      const nowt = nowMs();
      EP.toasts = EP.toasts.filter(t => (nowt - t.start) < t.ttl);
      EP.toasts.forEach(t => {
        const k = (nowt - t.start)/t.ttl; const a = 1 - k; const y = t.y - 12*CFG.SCALE*k;
        ctx.save(); ctx.globalAlpha = Math.max(0, Math.min(1,a)); ctx.fillStyle = t.color || '#fff'; ctx.font = `${12*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText(t.text, t.x, y); ctx.restore();
      });
    }
    
    // Update trump locations for click detection
    updateTrumpLocations(paperX, paperY, paperW, paperH);

    if (mouse.active) {
      let overTrump = false;
      for (let i = 0; i < EP.trumpLocations.length; i++) {
        const hit = EP.trumpLocations[i];
        if (hit.kind === 'trump' && mouse.x >= hit.x && mouse.x <= hit.x + hit.width && mouse.y >= hit.y && mouse.y <= hit.y + hit.height) {
          overTrump = true;
          break;
        }
      }
      let overArt = false;
      if (!overTrump && EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
        const r = EP.finalArtRect;
        if (mouse.x >= r.x && mouse.x <= r.x + r.w && mouse.y >= r.y && mouse.y <= r.y + r.h) {
          overArt = true;
        }
      }
      setCanvasCursor((overTrump || overArt) ? 'pointer' : 'default');
    } else {
      setCanvasCursor('default');
    }
    
    // Debug: Draw click areas (optional - remove later)
    if (CFG.DEBUG) {
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 1;
      EP.trumpLocations.forEach(trump => {
        ctx.strokeRect(trump.x, trump.y, trump.width, trump.height);
      });
    }
    
    // Draw door when game is not active
    if (!EP.gameActive) {
      drawDoor(EP.door.x, EP.door.y);
    }
    
    // Update game logic
    updateEpsteinGame();
  }
  
  function drawDocumentContent(paperX, paperY, paperW, paperH) {
    const lineHeight = 20 * CFG.SCALE;
    const fontSize = Math.floor(13 * CFG.SCALE);
    const leftMargin = paperX + 20 * CFG.SCALE;
    
    ctx.fillStyle = '#222';
    ctx.font = `${fontSize}px monospace`; // Monospace for document feel
    ctx.textAlign = 'left';
    
    let yPos = paperY + 30 * CFG.SCALE - EP.scrollY;
    let lineIndex = 0;
    
    // Clear trump locations for this frame
    EP.trumpLocations = [];
    
    // Draw all document lines
    EP.papers.forEach((document, docIndex) => {
      // Compute doc bounds to update visibleDoc (for HUD label)
      const docStartY = yPos;
      const docHeight = (lineHeight * 1.5) + (document.length * lineHeight) + lineHeight;
      const docEndY = docStartY + docHeight;
      const centerY = paperY + paperH/2;
      if (centerY >= docStartY && centerY < docEndY) {
        EP.visibleDoc = docIndex + 1;
      }
      // Document header
      ctx.fillStyle = '#666';
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillText(`--- CLASSIFIED DOCUMENT ${docIndex + 1} ---`, leftMargin, yPos);
      yPos += lineHeight * 1.5;
      lineIndex++;
      
      ctx.fillStyle = '#222';
      ctx.font = `${fontSize}px monospace`;
      
      document.forEach((line, idx) => {
        if (yPos > paperY - lineHeight && yPos < paperY + paperH + lineHeight) {
          if (line.redacted) {
            // Draw redaction (animated black bar if recently redacted)
            ctx.fillStyle = '#000';
            const textWidth = ctx.measureText(line.text).width;
            let p = 1;
            if (line.redactAt) {
              p = Math.max(0, Math.min(1, (nowMs() - line.redactAt) / 300));
            }
            ctx.fillRect(leftMargin, yPos - fontSize * 0.7, textWidth * p, fontSize);
          } else {
            // Normal text
            if (line.containsTrump || line.protectedName) {
              // Highlight targets
              const isTrump = !!line.containsTrump;
              const bg = isTrump ? '#ffcccc' : '#cce5ff';
              const tx = isTrump ? '#d32f2f' : '#1565c0';
              ctx.fillStyle = bg; // background
              // Measure with bold font to match draw
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.fillRect(leftMargin - 2, yPos - fontSize * 0.8, textWidth + 4, fontSize * 1.1);
              ctx.fillStyle = tx;
              ctx.fillText(line.text, leftMargin, yPos);
              ctx.font = `${fontSize}px monospace`; // Reset font

              // Assist highlight: briefly outline Trump targets after a miss
              if (isTrump && EP.assistUntil && nowMs() < EP.assistUntil) {
                const t = nowMs();
                const pulse = 0.5 + 0.5 * Math.sin((t/200) % (Math.PI*2));
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = `rgba(211,47,47,${0.6 + 0.4*pulse})`;
                ctx.lineWidth = 2 + 2*pulse;
                ctx.strokeRect(leftMargin - 4, yPos - fontSize * 0.9, textWidth + 8, fontSize * 1.3);
                ctx.restore();
              }
            } else {
              ctx.fillStyle = '#222';
              ctx.fillText(line.text, leftMargin, yPos);
            }
            
            // Store click targets for detection (Trump + protected) with generous padding
            if ((line.containsTrump || line.protectedName) && !line.redacted) {
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.font = `${fontSize}px monospace`;
              const kind = line.containsTrump ? 'trump' : 'protected';
              // Dynamic padding grows with speed to keep clicks easy at high tempo
              let padX = (40 + (EP.scrollSpeed||1)*30) * CFG.SCALE;
              let padY = (18 + (EP.scrollSpeed||1)*12) * CFG.SCALE;
              // Clamp hitbox growth to sensible bounds
              padX = Math.max(20*CFG.SCALE, Math.min(padX, 220*CFG.SCALE));
              padY = Math.max(10*CFG.SCALE, Math.min(padY, 90*CFG.SCALE));
              EP.trumpLocations.push({
                x: (leftMargin - 2) - padX,
                y: (yPos - fontSize * 0.8) - padY,
                width: (textWidth + 4) + 2*padX,
                height: (fontSize * 1.1) + 2*padY,
                lineIndex: lineIndex,
                docIndex: docIndex,
                lineInDoc: idx,
                kind
              });
            }
          }
        }
        
        yPos += lineHeight;
        lineIndex++;
      });
      
      yPos += lineHeight; // Space between documents
    });

    // Final art piece (Birthday drawing homage) as last item
    const artMarginY = 20 * CFG.SCALE;
    const artW = paperW * 0.72;
    const artH = Math.min(paperH * 0.78, 360 * CFG.SCALE);
    const artX = paperX + (paperW - artW) / 2;
    const artY = yPos + artMarginY;
    EP.finalArtRect = { x: artX, y: artY, w: artW, h: artH };
    EP.artHeightPx = (artMarginY + artH + lineHeight);

    // Draw the art (or its redaction)
    drawBirthdayArt(artX, artY, artW, artH, !!(EP.finalArt && EP.finalArt.redacted));
  }

  // Draw 8-bit style birthday drawing (uses uploaded image if configured)
  function drawBirthdayArt(x, y, w, h, redacted) {
    if (redacted) {
      ctx.fillStyle = '#000';
      ctx.fillRect(x, y, w, h);
      return;
    }

    // If a custom image has been provided via GRAPHICS, render it scaled
    const url = GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art;
    if (url) {
      const img = GRAPHICS.images.get('birthday_art');
      if (img && img.complete) {
        // Draw PNG/JPEG using fit mode and no smoothing for crisp edges
        ctx.save();
        try { ctx.imageSmoothingEnabled = false; } catch(_){ }
        const iw = img.naturalWidth || img.width || 1;
        const ih = img.naturalHeight || img.height || 1;
        const fit = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art_fit) || 'contain';
        const sContain = Math.min(Math.max(0.0001, w/iw), Math.max(0.0001, h/ih));
        const sCover   = Math.max(Math.max(0.0001, w/iw), Math.max(0.0001, h/ih));
        // 'height' prefers filling height fully without cropping, otherwise falls back to contain
        const sHeight  = (iw * (h/ih) <= w) ? (h/ih) : sContain;
        const s = fit === 'cover' ? sCover : (fit === 'height' ? sHeight : sContain);
        const dw = iw * s;
        const dh = ih * s;
        const dx = x + (w - dw)/2;
        const dy = y + (h - dh)/2;
        // Clip to the art rect so cover mode crops inside the box
        ctx.save();
        ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip();
        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.restore();
        ctx.restore();
        return;
      }
      GRAPHICS.loadImage('birthday_art', url);
    }
    // If Lottie JSON is provided and lottie-web available, render via hidden canvas and blit
    if (LOTTIE_ART && LOTTIE_ART.json && window.bodymovin) {
      LOTTIE_ART.resize(w, h);
      if (LOTTIE_ART.ready && LOTTIE_ART.canvasEl) {
        ctx.drawImage(LOTTIE_ART.canvasEl, x, y, w, h);
        return;
      }
    }

    // Vector fallback matching the uploaded 8-bit angular outline
    const cx = x + w/2;
    const stroke = Math.max(8, Math.round(12 * CFG.SCALE));
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.lineWidth = stroke;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.strokeStyle = '#3b3b3b';

    // Helper to draw a polyline from normalized points [0..1]
    function poly(points){
      ctx.beginPath();
      ctx.moveTo(x + points[0][0]*w, y + points[0][1]*h);
      for (let i=1;i<points.length;i++) ctx.lineTo(x + points[i][0]*w, y + points[i][1]*h);
      ctx.stroke();
    }

    // Left vertical notch then angular shoulder/torso outline
    const left = [
      [0.38, 0.06], [0.38, 0.16], [0.30, 0.24], [0.06, 0.30],
      [0.06, 0.38], [0.10, 0.46], [0.18, 0.62], [0.26, 0.80], [0.24, 0.88], [0.20, 0.96]
    ];
    const right = left.map(([nx, ny]) => [1-nx, ny]);
    poly(left);
    poly(right);

    // Angular chest marks
    poly([[0.34, 0.42],[0.31, 0.46],[0.36, 0.48]]);
    poly([[0.66, 0.42],[0.69, 0.46],[0.64, 0.48]]);

    // Stylized signature and long flourish
    const sx = 0.38, sy = 0.90, ex = 0.85;
    poly([[sx, sy],[sx+0.01, sy-0.08],[sx+0.03, sy+0.04],[sx+0.05, sy-0.06],[sx+0.07, sy+0.05],[sx+0.09, sy-0.07],[sx+0.11, sy+0.06]]);
    poly([[sx+0.11, sy+0.12],[ex, sy+0.12]]);

    ctx.restore();
  }
  
  function drawEpsteinHUD() {
    // Move HUD to left side to avoid overlap with gold bar chips
    const baseX = 20, baseY = 20;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(baseX, baseY, 200, 160);
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${16 * CFG.SCALE}px system-ui`;
    ctx.textAlign = 'left';
    // No time constraint shown
    ctx.fillText(`Speed: ${EP.scrollSpeed.toFixed(1)}x`, baseX + 10, baseY + 25);
    ctx.fillText(`Found: ${EP.foundTrumps}/${EP.totalTrumpTargets}`, baseX + 10, baseY + 50);
    ctx.fillText(`Missed: ${EP.missedTrumps}/${EP.missesAllowed}`, baseX + 10, baseY + 75);
    ctx.fillText(`Penalties: ${EP.protectedClicks||0}`, baseX + 10, baseY + 100);
    // Progress bars
    const barX = baseX + 10, barW = 180, barH = 8;
    // Found progress
    const foundK = Math.max(0, Math.min(1, (EP.foundTrumps||0) / (EP.totalTrumpTargets||1)));
    ctx.fillStyle = '#333'; ctx.fillRect(barX, baseY + 110, barW, barH);
    ctx.fillStyle = '#4caf50'; ctx.fillRect(barX, baseY + 110, barW*foundK, barH);
    // Scroll progress
    // recompute total content height like in updateEpsteinGame
    const paperYHUD = H * 0.1;
    const lineH = 20 * CFG.SCALE;
    let totalH = 30 * CFG.SCALE;
    for (let d = 0; d < EP.papers.length; d++) { totalH += lineH*1.5 + EP.papers[d].length*lineH + lineH; }
    const startYHUD = paperYHUD + 30 * CFG.SCALE - EP.scrollY;
    const scrolledHUD = Math.max(0, Math.min(totalH, (paperYHUD + 30 * CFG.SCALE) - startYHUD));
    const scrollK = totalH>0 ? (scrolledHUD/totalH) : 0;
    ctx.fillStyle = '#333'; ctx.fillRect(barX, baseY + 125, barW, barH);
    ctx.fillStyle = '#03a9f4'; ctx.fillRect(barX, baseY + 125, barW*scrollK, barH);
    
  }
  
  function updateTrumpLocations(paperX, paperY, paperW, paperH) {
    // Locations are rebuilt each frame inside drawDocumentContent.
    // This function intentionally kept for future use.
  }
  
  function checkMissedTrumps() {
    // Compute from document structure rather than transient locations,
    // so lines that scrolled off-screen still count as missed.
    const paperY = H * 0.1;
    const lineHeight = 20 * CFG.SCALE;
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    
    for (let d = 0; d < EP.papers.length; d++) {
      const doc = EP.papers[d];
      // y at start of this document header
      let y = startY;
      for (let pd = 0; pd < d; pd++) {
        y += lineHeight * 1.5; // header
        y += EP.papers[pd].length * lineHeight; // lines
        y += lineHeight; // gap
      }
      
      // header of current doc
      y += lineHeight * 1.5;
      
      for (let li = 0; li < doc.length; li++) {
        const line = doc[li];
        if (line.containsTrump && !line.redacted) {
          const lineY = y + li * lineHeight;
          if (lineY < paperY - 150) { // missed threshold above paper
            line.redacted = true;
            EP.missedTrumps++;
            SFX.error();
            triggerShake(5 * CFG.SCALE, 200);
            // Assist for a few seconds after a miss
            EP.assistUntil = nowMs() + 3500;
            // Miss toast near top-left of paper
            EP.toasts.push({ x: W*0.2 + 60*CFG.SCALE, y: H*0.1 + 20*CFG.SCALE, text: 'Missed', color: '#ff5555', start: nowMs(), ttl: 800 });
          }
        }
      }
    }
    // Note: EP.trumpLocations is still used for click detection; it is rebuilt during draw.
  }
  
  function endEpsteinGame(reason) {
    EP.gameActive = false;
    if (reason === 'success') {
      const text = 'Selvf√∏lgelig er jeg ikke n√¶vnt ‚Äî never met the guy';
      addSafe('epstein', 'documents-redacted');
      SFX.achievement();
      GS.overMode = 'epstein_success';
      gameOver(text);
      return;
    }

    if (reason === 'protected_click' || reason === 'protected' || reason === 'misses' || reason === 'timeout') {
      SFX.error();
      GS.overMode = 'epstein_fail';
      GS.over = true;
      GS.overText = '';
      return;
    }

    // Fallback
    GS.overMode = 'epstein_fail';
    GS.over = true;
    GS.overText = 'DOKUMENTGENNEMGANG SLUT.';
  }
  
  function handleEpsteinClick(mouseX, mouseY) {
    if (!EP.gameActive) {
      // If game is not active, check for door exit
      const doorDist = Math.hypot(mouseX - EP.door.x, mouseY - EP.door.y);
      if (doorDist < 80 * CFG.SCALE) {
        // Exit back to helicopter menu
        openChoice("Leave document review?\n1) Continue redacting\n2) Back to helicopter", k=>{
          closeChoice();
          if (k==='2') switchScene('greenland');
        });
      }
      return;
    }

    // Check click on final art (big redaction square)
    if (EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
      const r = EP.finalArtRect;
      if (mouseX >= r.x && mouseX <= r.x + r.w && mouseY >= r.y && mouseY <= r.y + r.h) {
        EP.finalArt = EP.finalArt || {};
        EP.finalArt.redacted = true;
        SFX.success();
        EP.toasts.push({ x: r.x + r.w/2, y: r.y - 8*CFG.SCALE, text: 'Image redacted', color: '#6cff6c', start: nowMs(), ttl: 1200 });
        // Delay ending by ~1.2s so player sees the redaction
        if (!EP.endingPending){
          EP.endingPending = true;
          const result = (EP.foundTrumps >= EP.totalTrumpTargets) ? 'success' : 'misses';
          setTimeout(() => { try { endEpsteinGame(result); } catch(_){} }, 1200);
        }
        return;
      }
    }

    // Check if click is on a target area (Trump or protected)
    for (let i = 0; i < EP.trumpLocations.length; i++) {
      const trump = EP.trumpLocations[i];
      
      if (mouseX >= trump.x && mouseX <= trump.x + trump.width &&
          mouseY >= trump.y && mouseY <= trump.y + trump.height) {
        
        // Locate the actual line
        const document = EP.papers[trump.docIndex];
        const line = document[trump.lineInDoc];
        
        if (!line || line.redacted) continue;
        
        if (trump.kind === 'protected') {
          // Protected click: count penalty, keep playing, and show toast (do NOT redact)
          EP.protectedClicks = (EP.protectedClicks||0) + 1;
          SFX.error();
          triggerShake(6*CFG.SCALE, 300);
          hudToast = 'Penalty: Overstreg ikke bl√• (Clinton/Gates)';
          // Removed blue cross/arrow overlay
          EP.trumpLocations.splice(i, 1);
          if (EP.protectedClicks > (EP.protectedLimit||0)) { endEpsteinGame('protected_click'); }
          return;
        } else if (trump.kind === 'trump') {
          // Successfully redacted Trump line
          line.redacted = true;
          line.redactAt = nowMs();
          EP.foundTrumps++;
          SFX.success();
          spawnSparks(mouseX, mouseY, 8);
          EP.toasts.push({ x: mouseX, y: mouseY - 10*CFG.SCALE, text: '+1 Redacted', color: '#6cff6c', start: nowMs(), ttl: 700 });
          EP.trumpLocations.splice(i, 1);
          return;
        }
      }
    }
    
    // No Trump name clicked - maybe add small penalty sound
    SFX.click();
  }
  function switchScene(to){
    // Unbind golf inputs if leaving golf
    if (scene === 'golf') { try { golfUnbindInput(); } catch(_){} }
    scene = to;
    if (scene==='greenland') { resetGreenland(); }
    else if (scene==='oval') { resetOval(); playEntryHeli('Back at the Resolute Desk ‚Äî the best!', 160*CFG.SCALE); }
    else if (scene==='kremlin') { resetKremlin(); playEntryHeli('Very strong handshake incoming.', 160*CFG.SCALE); }
    else if (scene==='epstein') { resetEpstein(); }
    // Adjust UI position per scene (avoid bottom-left overlap in Epstein)
    try {
      const ui = document.querySelector('.ui');
      if (ui){
        if (scene==='epstein') {
          ui.style.top = '12px';
          ui.style.bottom = 'auto'; // override class bottom to avoid stretching
        } else {
          ui.style.bottom = '12px';
          ui.style.top = 'auto';
        }
      }
    } catch(_){ }
  }
  resetGreenland();
  // ensure inventory renders placeholders on load (no preloaded items)
  renderInv();
  renderHUD();

  // Reset handler consolidated in main keydown listener above

  // ---------- Interaktioner ----------
  function nearestGL(){
    const arr = [GL.mine, GL.mette, GL.rig, GL.shop, GL.heli, ...(GL.bear.alive ? [GL.bear] : []), ...GL.items.filter(it=>!it.collected), ...GL.glaciers.filter(g=>!g.blown), ...GL.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestOV(){
    const arr = [OV.door, OV.heli, OV.yes, ...OV.buttons, ...OV.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestKR(){
    const arr = [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected), ...KR.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }

  function interact(){
    if (scene==='greenland'){
      const obj = nearestGL(); if (!obj) return;
      addInteractionFeedback(obj); // Add visual feedback
      if (player.selectedItem==='dynamite'){
        if (obj && (obj.type==='mette' || obj.type==='bear' || obj.type==='rig' || obj.type==='glacier')){ beginPlant(obj); return; }
        // plant at ground near player's feet if no special target
        const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
        beginPlant({type:'ground', x:px, y:g});
        return;
      }
      else if (obj.type==='mine'){
        if (!GL.flag){ GL.flag = {x:GL.mine.x - 60*CFG.SCALE, y:H - world.floor}; GL.state.flagPlanted=true; say(player,"Planter frihed üá∫üá∏ (satire)",1500); }
        else say(player,"Flag er allerede her.",1000);
      }
      else if (obj.type==='shop'){
        openShop();
      }
      else if (obj.type==='bear'){
        if (!GL.bear.alive){ say(player,"‚Ä¶den er v√¶k.",900); return; }
        if (CFG.NON_VIOLENT){
          say(player,"S√∏d bj√∏rn. Tag en fisk üêü",1400); say(GL.bear,"Brumm?",1000);
          addSafe('greenland', 'bear-peace');
        } else {
          const oldHP = GL.bear.hp || 4;
          GL.bear.hp = Math.max(0, oldHP-1);
          
          // When HP reaches 0 - bear gets ANGRY and starts chasing!
          if (GL.bear.hp === 0) {
            say(GL.bear,"ROAAAAR! üò°",1500);
            say(player,"Uh oh... that bear looks MAD!",2000);
            spawnBlood(player.x, player.y-20*CFG.SCALE, 15);
            
            // Bear becomes angry and starts chasing
            GL.bear.angry = true;
            GL.bear.chasing = true;
            GL.bear.speed = 300; // Super fast when angry
            
            // Sound effects for angry bear
            ensureAudioInit();
            SFX.error();
            setTimeout(SFX.heartbeat, 500);
            
            // Camera shake for dramatic effect
            triggerShake(8*CFG.SCALE, 600);
            
            // Visual feedback - angry sparks
            for (let i = 0; i < 15; i++) {
              spawnSparks(GL.bear.x, GL.bear.y - 20*CFG.SCALE, 8);
            }
            
          } else {
            say(GL.bear,"Ufff!",800);
          }
          
          spawnBlood(GL.bear.x+8*CFG.SCALE, GL.bear.y-16*CFG.SCALE, 10);
          // knockback physics
          GL.bear.vy = (GL.bear.vy||0) - 280*CFG.SCALE;
          GL.bear.vx = (GL.bear.vx||0) + 60*CFG.SCALE;
          
          // Bear no longer dies, just gets angry when HP reaches 0
          // Remove the death logic since bear stays alive but angry
        }
      }
      else if (obj.type==='glacier'){
        const hasDynamite = inventory.find(i => i.id === 'dynamite');
        const dynamiteSelected = player.selectedItem === 'dynamite';
        
        if (!GL.state.hasSeenGlaciers) {
          // First interaction - complaint about view
          say(player, "These massive ice walls are blocking my BEAUTIFUL view! Need something explosive to clear them.", 2500);
          GL.state.hasSeenGlaciers = true;
        } else if (!hasDynamite) {
          // Subsequent interactions without dynamite in inventory
          say(player, "Still need something to blast through these glaciers! Where's my dynamite?", 2000);
        } else if (!dynamiteSelected) {
          // Has dynamite but not selected - more provocative
          say(player, "Look in the inventory, dummy!", 1500);
        } else { beginPlant(obj); }
      }
      else if (obj.type==='mette'){
        // Absurd Trump lines vs. diplomatic Mette lines
        const TRUMP_ABSURD = [
          'Historic offer: I buy Greenland, you get lifetime promo code DENMARK15. Best deal since Alaska‚Äîmaybe bigger.',
          'We‚Äôll trademark "cold." Anyone using cold pays a small fee.',
          'I invented snow. Look it up. Before me: just rain, but sad.',
          'I\'ll rename this island to Trumplandia (working title). Flexible on fonts.',
          'I‚Äôll build a wall around the ice to keep the earth cold. Global warming solved.'
        ];
        const METTE_DIPLO = [
          'Tak for interessen. I rigsf√¶llesskabets rammer og med Gr√∏nlands selvstyre er ejerskab ikke et spor. Vi kan dr√∏fte langsigtede partnerskaber om klima, forskning og sikkerhed.',
          'Hvis tonen virkede kontant, beklager jeg. Beslutninger om land og ressourcer tr√¶ffes med gr√∏nlandske myndigheder og borgere ‚Äî i respekt for Selvstyreloven og "free, prior and informed consent".',
          'Enhver aktivitet foruds√¶tter milj√∏vurderinger, h√∏ringer og robuste governance‚Äëmodeller, koordineret med Arktisk R√•d, NATO‚Äëpartnere og ber√∏rte lokalsamfund.',
          'Med al respekt: suver√¶nitet og naturressourcer afg√∏res ikke per dekret. Der kr√¶ves procedurer og evt. folkeafstemning. Det er en gradvis, gennemsigtig proces.'
        ];
        const trumpResponse = TRUMP_ABSURD[Math.floor(Math.random()*TRUMP_ABSURD.length)];
        const line = METTE_DIPLO[Math.floor(Math.random()*METTE_DIPLO.length)];
        // Light relationship nudge only
        adjustRelationship('mette', {respect:-1, trust:-1}, 'absurd-offer');
        // Show Trump first, then Mette after ~1.4s
        // Keep Trump's bubble visible until Mette's bubble has also finished
        const delayMs = 1400, metteDur = 3200, trumpDur = delayMs + metteDur + 300;
        say(player, trumpResponse, trumpDur);
        setTimeout(() => { try { say(GL.mette, line, metteDur); } catch(_){} }, delayMs);
        GL.mette.nextBlink = nowMs() + 2000 + Math.random()*3000;
        GL.mette.blinkUntil = 0;
      }
      else if (obj.type==='rig'){
        GL.rig.burstUntil = nowMs() + 900;
        // emit oil burst from the top and falling to ground
        const topX = GL.rig.x, topY = GL.rig.y - 90*CFG.SCALE - 12*CFG.SCALE;
        spawnOil(topX, topY, 24);
        say(player,'Huge energy play. Beautiful, clean oil!',1600);
      }
      else if (obj.type==='heli'){
        addSafe('greenland', 'heli-travel');
          openChoice("Board helicopter?\n1) Bliv p√• Gr√∏nland\n2) Flyv til The White House\n3) Flyv til Moskva (m√∏de)\n4) Epstein files\n5) Flyv til Mar-a-Lago (mini-putt)", k=>{
          closeChoice();
          if (k==='2'){ switchScene('oval'); }
          if (k==='3'){ switchScene('kremlin'); }
          if (k==='4'){ switchScene('epstein'); }
          if (k==='5'){ try { SFX.whoosh(); } catch(_){} startGolf('course-mar-a-lago'); }
        });
      }
      else if (obj.type==='pickup'){
        obj.collected=true;
        addToInventory(obj.id, obj.name);
        say(player, `Samlet: ${obj.name}`, 1000);
        addSafe('greenland', obj.id);
      }
    } else {
      if (scene==='oval'){
        const obj = nearestOV(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (player.selectedItem==='dynamite'){
          // Allow planting in Oval: plant on ground near player
          const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
          beginPlant({type:'ground', x:px, y:g});
          return;
        }
        if (obj.type==='door'){
          openChoice("Forlade The Oval Office?\n1) Bliv her\n2) Tilbage til Gr√∏nland", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
          });
        }
        // aide disabled in this scene layout
        else if (obj.type==='yes'){
          praiseChoir();
          addSafe('oval', 'praise-choir');
        }
        else if (obj.type==='button'){
          const i = OV.buttons.indexOf(obj);
          // Add visual press effect
          obj.pressed = true;
          setTimeout(() => { if (obj) obj.pressed = false; }, 200);
          
          // Sound effects
          ensureAudioInit();
          if (i === 0) {
            SFX.error(); // Dramatic sound for nuclear button
            setTimeout(SFX.explosion, 500);
          } else {
            SFX.buttonPress();
          }
          
          if (i===0){ launchMissile(); return; }
          else if (i===1){
            // Dedicated tariff button
            const country = pickRandomCountry(); 
            const deltas = [5,10,15,20,25];
            const delta = deltas[Math.floor(Math.random()*deltas.length)];
            say(player,'Raise tariffs on '+country+' +'+delta+'%. Tremendous!',1600);
            OV.screen.active = { type:'tariff', country, delta, start:nowMs(), until: nowMs()+2200 };
          } else {
            // Playful policies for other buttons
            const policies = [
              { title:'DROP HEALTHCARE', value:'Coverage -100%', dir:'down', caption:'Program terminated', bg:'rgba(183,28,28,0.9)' },
              { title:'DELETE INCOME TAX', value:'Taxes 0%', dir:'down', caption:'More money! Tremendous!', bg:'rgba(27,94,32,0.9)' },
              { title:'PRIVATIZE EDUCATION', value:'Tuition ‚Üë', dir:'up', caption:'Market knows best', bg:'rgba(183,28,28,0.9)' },
              { title:'CUT SCIENCE BUDGET', value:'-30%', dir:'down', caption:'Who needs data?', bg:'rgba(183,28,28,0.9)' },
              { title:'BAN WINDMILLS', value:'Bird strikes ‚Üì', dir:'down', caption:'They cause cancer!', bg:'rgba(27,94,32,0.9)' },
              { title:'MANDATORY GOLF', value:'Morale ‚Üë', dir:'up', caption:'National sport now', bg:'rgba(27,94,32,0.9)' },
              { title:'EXECUTIVE TIME', value:'+100%', dir:'up', caption:'Important thinking', bg:'rgba(33,33,33,0.9)' },
              { title:'SPACE WALL', value:'Budget ‚Üë', dir:'up', caption:'To the moon!', bg:'rgba(183,28,28,0.9)' },
              { title:'CANCEL DST', value:'Clocks confused', dir:'up', caption:'Time is a construct', bg:'rgba(255,160,0,0.9)' },
              { title:'SELL PARKS', value:'Entry fees ‚Üë', dir:'up', caption:'Beautiful deals', bg:'rgba(183,28,28,0.9)' },
              { title:'ALL CAPS TWEETS', value:'Volume ‚Üë', dir:'up', caption:'SO MUCH WINNING', bg:'rgba(33,33,33,0.9)' }
            ];
            const pol = policies[Math.floor(Math.random()*policies.length)];
            say(player, pol.title+'. The best policy!', 1600);
            OV.screen.active = { type:'policy', ...pol, start:nowMs(), until: nowMs()+2200 };
          }
          praiseChoir();
          addSafe('oval', `button-${i}`);
        }
        else if (obj.type==='heli'){
          ensureAudioInit();
          SFX.helicopter();
          addSafe('oval', 'heli-travel');
          openChoice("Board helicopter?\n1) Bliv her\n2) Flyv til Gr√∏nland\n3) Flyv til Moskva (m√∏de)\n4) Epstein files\n5) Flyv til Mar-a-Lago (mini-putt)", k=>{
            closeChoice();
            if (k==='2') { SFX.whoosh(); switchScene('greenland'); }
            if (k==='3') { SFX.whoosh(); switchScene('kremlin'); }
            if (k==='4') { SFX.whoosh(); switchScene('epstein'); }
            if (k==='5') { SFX.whoosh(); startGolf('course-mar-a-lago'); }
          });
        }
      } else if (scene==='kremlin'){
        const obj = nearestKR(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (player.selectedItem==='dynamite'){
          // Special: allow planting on Putin for a satirical ending, else plant on ground
          if (obj.type==='putin') { beginPlant(obj); return; }
          const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
          beginPlant({type:'ground', x:px, y:g});
          return;
        }
        if (obj.type==='door'){
          openChoice("Forlade m√∏det?\n1) Bliv her\n2) Tilbage til Gr√∏nland", k=>{ closeChoice(); if (k==='2') switchScene('greenland'); });
        }
        else if (obj.type==='putin'){
          startHandshake();
        }
        else if (obj.type==='statue'){
          // Check if Trump is caught by security camera
          if (isStatueUnderSurveillance(obj)) {
            // BUSTED! Discovery system activates
            triggerSecurityDiscovery(obj);
            return; // Don't collect the statue
          }
          
          obj.collected=true;
          addToInventory(obj.id, obj.name);
          // Bonus: display stolen statue on Oval Office shelves
          if (!OV.shelfLoot) OV.shelfLoot = [];
          OV.shelfLoot.push({ variant: obj.variant||1, time: nowMs() });
          addSafe('kremlin', obj.id);
          const boast=[
            'Only I could get this deal.',
            'They love me here. Tremendous!',
            'Beautiful piece. I deserve it.',
            'Everyone says it belongs with me.'
          ];
          say(player, boast[Math.floor(Math.random()*boast.length)], 1400);
        }
        else if (obj.type==='heli'){
          addSafe('kremlin', 'heli-travel');
          openChoice("Board helicopter?\n1) Bliv her\n2) Flyv til Gr√∏nland\n3) Flyv til The White House\n4) Epstein files\n5) Flyv til Mar-a-Lago (mini-putt)", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
            if (k==='3') switchScene('oval');
            if (k==='4') switchScene('epstein');
            if (k==='5') { try { SFX.whoosh(); } catch(_){} startGolf('course-mar-a-lago'); }
          });
        }
      } else if (scene==='epstein') {
        // Epstein scene interactions (door exit when game is over)
        if (!EP.gameActive) {
          const obj = {type: 'door', x: EP.door.x, y: EP.door.y};
          const d = Math.hypot(player.x - obj.x, player.y - obj.y);
          if (d < CFG.INTERACT_DIST*CFG.SCALE) {
            openChoice("Leave document review?\n1) Stay here\n2) Back to helicopter", k=>{
              closeChoice();
              if (k==='2') switchScene('greenland');
            });
          }
        }
      }
    }
  }
  // Interact handler consolidated in main keydown listener above

  // ---------- Tweet logic ----------
  function doTweet(){
    const text = nextTweet();
    GL.state.hasTweeted = true;
    const wrapped = wrapTwoLines(text, 220*CFG.SCALE);
    const msg = wrapped.length>1 ? ('Tweet: "'+wrapped[0]+'\n'+wrapped[1]+'"') : ('Tweet: "'+wrapped[0]+'"');
    say(player, msg, 2400);
    tweetCount++;
    phoneBlinkUntil = nowMs() + 600;
    
    // Adjust relationships based on tweet context in different scenes
    if (scene === 'kremlin') {
      adjustRelationship('putin', {trust: -2, fear: 1}, 'tweeting_in_kremlin');
      SFX.tweet();
      // Putin might react to aggressive tweeting
      if (tweetCount > 3 && RELATIONSHIPS.putin.trust < 30) {
        setTimeout(() => {
          KR.putin.speakingUntil = nowMs() + 1500;
          KR.putin.say = 'Perhaps less... social media?';
        }, 1000);
      }
    } else if (scene === 'greenland') {
      adjustRelationship('mette', {respect: -1, trust: -2}, 'public_tweeting');
      SFX.tweet();
    }
  }
  function wrapTwoLines(text, maxW){
    ctx.save(); ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const words = String(text).split(/\s+/);
    let line1='', line2='';
    for (const w of words){
      const test = line1 ? line1+' '+w : w;
      if (ctx.measureText(test).width <= maxW) line1 = test;
      else { line2 = line2 ? line2+' '+w : w; }
    }
    if (!line1 && line2){ line1=line2; line2=''; }
    ctx.restore();
    return line2 ? [line1, line2] : [line1];
  }

  const SHOP_ITEMS = [
    {
      id: 'tan',
      label: 'Selvbruner',
      price: 3,
      allowDuplicates: true,
      buyLine: 'Selvbruner +1',
      onPurchase(){
        addToInventory('tan');
        player.tanLevel = Math.min(5, (player.tanLevel || 0) + 1);
      }
    },
    {
      id: 'shoes',
      label: 'Guldsneakers',
      price: 8,
      allowDuplicates: false,
      buyLine: 'Guldsko p√•! Tempo x2.',
      onPurchase(){
        player.goldenShoesOn = true;
        updatePlayerSpeedMul();
        renderHUD();
      }
    },
    {
      id: 'maga',
      label: 'MAGA-cap',
      price: 5,
      allowDuplicates: false,
      buyLine: 'Ny MAGA-cap ‚Äì total patrioteffekt!',
      onPurchase(){
        player.capOn = true;
      }
    },
    {
      id: 'dynamite',
      label: 'Dynamit (x5)',
      price: 6,
      allowDuplicates: true,
      buyLine: 'Boom! Fem styk dynamit.',
      onPurchase(){
        addToInventory('dynamite');
      }
    }
  ];

  let shopTutorialShown = false;
  function handleShopFirstPurchase(){
    if (shopTutorialShown) return false;
    shopTutorialShown = true;
    if (invEl && invEl.classList.contains('hidden')) {
      toggleInventory();
    }
    say(player, 'press B to see my beautiful stuff', 2200);
    return true;
  }

  function openShop(){
    if (choiceOverlay) return;
    const balance = player.goldBalance || 0;
    const lines = SHOP_ITEMS.map((item, idx) => `${idx + 1}) ${item.label} ‚Äì ${item.price} guld`);
    const exitIndex = SHOP_ITEMS.length + 1;
    lines.push(`${exitIndex}) Forlad boden`);
    const header = `Roadside Shop\nGuld: ${balance}\n`;
    openChoice(header + lines.join('\n'), key => {
      if (key === String(exitIndex) || key === 'escape') {
        closeChoice();
        return;
      }
      const choice = parseInt(key, 10) - 1;
      if (Number.isNaN(choice) || choice < 0 || choice >= SHOP_ITEMS.length) {
        say(player, 'Forst√•r ikke valget.', 900);
        return;
      }
      const item = SHOP_ITEMS[choice];
      if ((player.goldBalance || 0) < item.price){
        say(player, 'Ikke nok guld.', 1100);
        return;
      }
      if (!item.allowDuplicates && hasItem(item.id)){
        say(player, 'Du har allerede den genstand.', 1100);
        return;
      }
      closeChoice();
      player.goldBalance = (player.goldBalance || 0) - item.price;
      if (!item.allowDuplicates && !hasItem(item.id)) addToInventory(item.id);
      if (item.onPurchase) item.onPurchase();
      const tutorial = handleShopFirstPurchase();
      if (!tutorial) {
        say(player, item.buyLine || 'Tak for k√∏bet!', 1300);
      }
      renderHUD();
    });
  }
  function hasItem(id){ return inventory.some(it=>it.id===id); }
  
  function checkCoinRewards(){
    if (collectedCoins === 10 && !player.speedBoost10) {
      player.speedBoost10 = true;
      player.baseSpeedMul = (player.baseSpeedMul || 1) * 1.25;
      updatePlayerSpeedMul();
      say(player, 'Speed boost! +25%', 2000);
    }
    if (collectedCoins === 18 && !player.healthBoost18) {
      player.healthBoost18 = true;
      // Add health regeneration or other bonus
      say(player, 'Health boost unlocked!', 2000);
    }
    // Check if all gold bars collected (total across all scenes: 12+7+4=23)
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    if (collectedCoins >= totalCoins && !player.masterCollector) {
      player.masterCollector = true;
      say(player, 'Gold Rush Master! All gold bars found!', 3000);
    }
  }
  function useInventoryKey(k){
    // map 1,2,3 to ITEM_META order
    const order = Object.keys(ITEM_META);
    const idx = parseInt(k,10)-1;
    const id = order[idx];
    if (!id) return;
    if (!hasItem(id)) { say(player, 'Ingen '+(ITEM_META[id].name||id)+' i inventaret', 900); return; }
    if (id==='tan') { 
      player.tanLevel = Math.min(5, (player.tanLevel||0)+1); 
      say(player,'Selvbruner +1',1000); 
      // Small celebratory sparkles around the head
      spawnSparks(player.x, player.y - 44*CFG.SCALE, 10);
      renderInv(); 
      return; 
    }
    if (id==='shoes') {
      player.goldenShoesOn = !player.goldenShoesOn;
      say(player, player.goldenShoesOn ? 'Guld-sko p√•! Tempo x2.' : 'Guld-sko af.', 1000);
      if (!player.goldenShoesOn) {
        // ensure base speed multiplier remains >0
        if (!player.baseSpeedMul) player.baseSpeedMul = 1;
      }
      updatePlayerSpeedMul();
      renderInv(); renderHUD();
      return;
    }
    if (id==='maga') { player.capOn = !player.capOn; say(player, player.capOn? 'Hat p√•.' : 'Hat af.',900); renderInv(); return; }
    if (id==='dynamite') { 
      player.selectedItem = 'dynamite'; 
      say(player,'Dynamit valgt! Klar til spr√¶ngning!',1200); 
      renderInv(); 
      // Clear selection after 10 seconds
      setTimeout(() => {
        if (player.selectedItem === 'dynamite') {
          player.selectedItem = null;
          say(player, 'Dynamit ikke l√¶ngere valgt', 800);
          renderInv();
        }
      }, 10000);
      return; 
    }
  }
  function nextTweet(){
    const lines = [];
    if (scene==='greenland'){
      if (!GL.state.flagPlanted && !GL.state.bearGone) lines.push('Great day in Greenland. Beautiful ice!');
      if (GL.state.flagPlanted) lines.push('We planted a small flag. Very legal & very cool.');
      if (GL.state.bearGone && CFG.NON_VIOLENT) lines.push('Made peace with a polar bear. Tremendous diplomacy.');
      if (GL.state.bearGone && !CFG.NON_VIOLENT) lines.push('Protected the people from a very dangerous bear!');
    } else {
      lines.push('Working hard in the Oval!');
    }
    if (hasItem('maga')) lines.push('Wearing my favorite hat. Crowds go wild!');
    if (hasItem('shoes')) lines.push('Guld-skoene er p√•. Hurtigere end nogensinde!');
    if (hasItem('tan')) lines.push('Natural tan. Best you‚Äôve ever seen.');
    const presets = [
      'So much winning!',
      'The Fake News won‚Äôt report this!',
      'MAKE GREENLAND GREAT AGAIN!',
      'Covfefe.',
    ];
    lines.push(presets[tweetCount % presets.length]);
    return lines.slice(0,2).join(' ');
  }

  // ---------- Mouse: hover + click-to-interact ----------
  // DPR-correct pointer ‚Üí canvas coordinates
  function toCanvasCoords(e, c){
    const r = c.getBoundingClientRect();
    const cx = (e.touches?.[0]?.clientX ?? e.clientX);
    const cy = (e.touches?.[0]?.clientY ?? e.clientY);
    return {
      x: (cx - r.left) * (c.width / r.width),
      y: (cy - r.top) * (c.height / r.height)
    };
  }
  const mouse = { x:0, y:0, active:false };
  let mouseMoveThrottle = 0;
  cvs.addEventListener('mousemove', e=>{
    const now = performance.now();
    if (now - mouseMoveThrottle < (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MOUSE_THROTTLE_MS || 16)) return; // ~60fps throttle
    mouseMoveThrottle = now;
    
    const p = toCanvasCoords(e, cvs);
    // World coords use CSS pixels; ctx is scaled by DPR ‚Üí divide back
    mouse.x = p.x / DPR;
    mouse.y = p.y / DPR;
    mouse.active = true;
    // Golf-specific drag logic is handled by golf pointer handlers

    // Enhanced drawing during drag
    if (isDrawing && borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h){
        addDrawingPoint(mouse.x, mouse.y, now);
      }
    }
  }, { passive: true });
  cvs.addEventListener('mouseleave', ()=>{ 
    mouse.active=false; 
    isDrawing=false; 
    // Golf pointer capture handles cancellation
  });
  
  // Enhanced drawing events
  cvs.addEventListener('mousedown', e=>{
    // Allow left-click to trigger standard interact when appropriate
    if (e.button === 0 && !borderDraw && scene !== 'golf' && !choiceOverlay && !infoCard && !flagOverlay) {
      interact();
    }

    // Golf-specific press handled by golf pointer handlers

    if (borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      const p = toCanvasCoords(e, cvs);
      const mx = p.x / DPR, my = p.y / DPR;
      if (mx>=card.x && mx<=card.x+card.w && my>=card.y && my<=card.y+card.h){
        isDrawing = true;
        lastDrawPoint = {x: mx, y: my, time: nowMs()};
        if (borderDraw.points.length === 0) {
          borderDraw.points.push({x:mx, y:my});
        }
        e.preventDefault();
      }
    }
  });
  
  cvs.addEventListener('mouseup', e=>{
    // Golf release handled by golf pointer handlers
    isDrawing = false;
    lastDrawPoint = null;
  });

  // simple auto-walk tween
  let walkTween = null; // {sx,tx,start,dur}
  function startWalkTo(xTarget, dur, onDone){
    walkTween = { sx: player.x, tx: xTarget, start: nowMs(), dur: Math.max(100, dur), onDone };
    player.facing = Math.sign(xTarget - player.x) || player.facing;
  }
  function stepWalkTween(t){
    if (!walkTween) {
      // Not walking with tween
      if (player.walking && !keys.has('arrowleft') && !keys.has('arrowright') && !keys.has('arrowup') && !keys.has('arrowdown')) {
        player.walking = false;
        player.walkCycle = 0;
      }
      return false;
    }
    const k = Math.min(1, (t - walkTween.start)/walkTween.dur);
    // ease in-out
    const e = k<0.5? 2*k*k : -1 + (4 - 2*k)*k;
    const oldX = player.x;
    player.x = walkTween.sx + (walkTween.tx - walkTween.sx)*e;
    
    // Walking animation during tween
    const dt = 1/60; // Approximate delta time for animation
    if (Math.abs(player.x - oldX) > 0.1) {
      player.walking = true;
      player.walkCycle += dt * 8;
    }
    
    if (k>=1){ 
      const cb=walkTween.onDone; 
      walkTween=null; 
      player.walking = false; 
      player.walkCycle = 0; 
      cb && cb(); 
    }
    return true;
  }
  // Planting dynamite (immediate)
  let PLANTED = []; // [{x,y,start,ttl}]
  let lastPlantAt = 0;
  const PLANT_COOLDOWN_MS = 900;
  function beginPlant(obj){
    // Immediate plant (no hold)
    const nowt = nowMs();
    if ((nowt - lastPlantAt) < PLANT_COOLDOWN_MS) return; // throttle accidental repeats
    lastPlantAt = nowt;
    PLANT = null;
    completePlantImmediate(obj);
  }
  function completePlant(){
    if (!PLANT) return; const obj = PLANT.obj; PLANT=null; completePlantImmediate(obj);
  }
  function completePlantImmediate(obj){
    SFX.buttonPress();
    // show placed sticks briefly at ground near target
    PLANTED.push({ x: obj.x, y: obj.y - 12*CFG.SCALE, start: nowMs(), ttl: 900, lastSparkAt: 0 });
    // consume dynamite from inventory
    const dyn = inventory.find(i=>i.id==='dynamite');
    if (dyn){ dyn.qty = Math.max(0, (dyn.qty||1)-1); if (dyn.qty===0){ const idx=inventory.indexOf(dyn); if (idx!==-1) inventory.splice(idx,1); player.selectedItem=null; } renderInv(); }
    ensureAudioInit();
    spawnSparks(obj.x, obj.y - 20*CFG.SCALE, 12);
    if (obj.type==='mette'){
      say(GL.mette, 'Eksplosiver er ikke et forhandlingsspor. Lad os tale proces.', 2400);
    } else if (obj.type==='bear'){
      GL.bear.angry=true; GL.bear.chasing=true; GL.bear.speed=300; SFX.error();
    } else if (obj.type==='rig'){
      const topX = GL.rig.x, topY = GL.rig.y - 90*CFG.SCALE - 12*CFG.SCALE; spawnFlame(topX, topY, 24);
    } else if (obj.type==='glacier'){
      say(player, 'Perfect! Let\'s blow these ice walls for a TREMENDOUS view!', 1800);
      setTimeout(()=>{
        GL.glaciers.forEach(g=>g.blown=true); GL.state.glaciersBlown=true; startGlacierExplosion();
      }, 600);
    } else if (obj.type==='putin'){
      // Drastic option: blowing up Putin ‚Üí tongue-in-cheek "world peace" ending
      ensureAudioInit(); SFX.explosion(); triggerShake(10*CFG.SCALE, 600);
      KR.putin.speakingUntil = nowMs() + 1200; KR.putin.say = '‚Ä¶';
      setTimeout(()=>{ try { gameOverCause('kremlin', {delayMs:0, title:'World Peace?', subtitle:'Historic day in geopolitics'}); } catch(_){} }, 500);
    } else if (obj.type==='ground'){
      // small local pop only
      triggerShake(2*CFG.SCALE, 200);
    }
  }
  function nearestToPoint(objs, x, y){
    let best=null, bd=1e9; for (const o of objs){ const d=Math.hypot(x-o.x,y-o.y); if (d<bd){bd=d; best=o;} }
    return {obj:best, dist:bd};
  }
  cvs.addEventListener('click', e=>{
    // Handle intro screen clicks
    if (scene === 'intro') {
      startGame();
      return;
    }
    
    if (choiceOverlay) return;
    if (infoCard) return;
    if (flagOverlay) return;
    // Border drawing now handled by mousedown/drag system
    if (borderDraw){
      return;
    }
    
    // Handle Epstein scene clicks
    if (scene === 'epstein') {
      handleEpsteinClick(mouse.x, mouse.y);
      return;
    }
    if (scene === 'golf'){
      return;
    }
    const objs = scene==='greenland' ? [GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)]
                   : scene==='oval' ? [OV.door, OV.aide, OV.heli, OV.yes, ...OV.buttons]
                   : [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected)];
    const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
    if (!obj) return;
    const maxClickDist = GAME_CONSTANTS.UI.CLICK_DISTANCE*CFG.SCALE;
    if (dist > maxClickDist) return; // click too far from any object
    // Special-case heli: allow interaction when standing at the side/cabin area
    const need = CFG.INTERACT_DIST*CFG.SCALE - 2;
    let canInteract = false;
    if (obj.type==='heli'){
      canInteract = heliProximity(obj, player.x, player.y) <= 8*CFG.SCALE;
    } else {
      const pd = Math.hypot(player.x-obj.x, player.y-obj.y);
      canInteract = pd <= need;
    }
    if (canInteract){ interact(); return; }
    // auto-walk to just within range then interact
    const side = Math.sign(obj.x - player.x) || 1;
    const targetX = clamp(obj.x - side*need, 40*CFG.SCALE, W-40*CFG.SCALE);
    const dx = Math.abs(targetX - player.x);
    const dur = Math.min(900, (dx / (CFG.SPEED*CFG.SCALE)) * 1000 + 150);
    startWalkTo(targetX, dur, () => interact());
  });

  // ---------- Jump ----------
  let jumpTween = null; // {start,dur,height}
  function doJump(){
    if (choiceOverlay) return;
    if (infoCard) return;
    if (flagOverlay) return;
    if (jumpTween) return;
    // MAGA hat gives super jump!
    const jumpHeight = player.capOn ? 50*CFG.SCALE : 26*CFG.SCALE;
    jumpTween = { start: nowMs(), dur: 520, height: jumpHeight };
  }

  function animateExit(who, dir=+1, dist=220){
    const s = nowMs(), d=1400, sx=who.x, sy=who.y;
    function step(t){ const k=Math.min(1,(t-s)/d); who.x = sx + dir*k*dist*CFG.SCALE; who.y = sy - Math.sin(k*Math.PI)*20*CFG.SCALE; if (k<1) requestAnimationFrame(step); }
    requestAnimationFrame(step);
  }

  // slight nudge/knockback tween
  function nudge(who, dx, dy, dur=120){
    const s = nowMs(); const sx=who.x, sy=who.y;
    function step(t){ const k=Math.min(1,(t-s)/dur); const e = 1-Math.cos(k*Math.PI); who.x = sx + dx*e; who.y = sy + dy*e; if (k<1) requestAnimationFrame(step); }
    requestAnimationFrame(step);
  }

  
  function startGlacierExplosion() {
    glacierExplosion.active = true;
    glacierExplosion.waterLevel = 0;
    
    // Create multiple explosion points
    GL.glaciers.forEach(glacier => {
      glacierExplosion.explosions.push({
        x: glacier.x,
        y: glacier.y,
        time: nowMs(),
        duration: 1000
      });
      
      // Create ice chunks falling from each glacier
      for (let i = 0; i < 15; i++) {
        glacierExplosion.iceChunks.push({
          x: glacier.x + (Math.random() - 0.5) * glacier.w * CFG.SCALE,
          y: glacier.y - glacier.h * CFG.SCALE/2,
          vx: (Math.random() - 0.5) * 300 * CFG.SCALE,
          vy: -Math.random() * 100 * CFG.SCALE,
          size: 4 + Math.random() * 8,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 10,
          life: 3000 + Math.random() * 2000
        });
      }
    });
    
    // Camera shake for dramatic effect
    triggerShake(15 * CFG.SCALE, 1200);
    
    // Sound effects
    ensureAudioInit();
    SFX.error(); // Explosion sound
    setTimeout(SFX.heartbeat, 300);
    setTimeout(SFX.heartbeat, 600);
    
    // Start water rising after a delay
    setTimeout(() => {
      startWaterRising();
    }, 2000);
  }
  
  function startWaterRising() {
    // Water level will rise and then cap. Now treated as fatal mistake ‚Üí game over after short delay
    const riseInterval = setInterval(() => {
      glacierExplosion.waterLevel += H / 600; // slower rise
      const maxWater = H * 0.6;
      if (glacierExplosion.waterLevel >= maxWater) {
        glacierExplosion.waterLevel = maxWater;
        clearInterval(riseInterval);
      }
    }, 16);
    // Show dramatic water for a moment, then end the game
    setTimeout(() => { try { gameOverCause('ice'); } catch(_){} }, 1500);
  }

  // ---------- Simple blood particles ----------
  // Object pooling for better performance
  const fx = { blood: [], sparks: [], downwash: [], oil: [], flame: [], confetti: [] };
  const particlePools = {
    blood: [],
    sparks: [],
    downwash: [],
    oil: [],
    flame: []
  };
  
  function getParticle(type) {
    return particlePools[type].pop() || {};
  }
  
  function returnParticle(type, particle) {
    // Reset particle properties
    Object.keys(particle).forEach(key => delete particle[key]);
    particlePools[type].push(particle);
  }
  const NUKE = { active:false, x:0, y:0, start:0, dur:3200, startY:0, endY:0 };
  const SHAKE = { start:0, dur:0, amp:0, until:0 };
  function triggerShake(amp, dur){ SHAKE.start=nowMs(); SHAKE.dur=dur; SHAKE.amp=amp; SHAKE.until=SHAKE.start+dur; }
  function launchMissile(){
    NUKE.active=true; NUKE.start=nowMs(); NUKE.dur=3200; NUKE.x = W/2;
    NUKE.startY = H + 200*CFG.SCALE; NUKE.endY = -260*CFG.SCALE; NUKE.y = NUKE.startY;
    triggerShake(8*CFG.SCALE, 700);
  }
  function spawnBlood(x,y,count=8){
    for (let i=0;i<count;i++){
      const particle = getParticle('blood');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*60-30)*CFG.SCALE;
      particle.vy = (-Math.random()*60-10)*CFG.SCALE;
      particle.life = 400 + Math.random()*300;
      particle.size = 3 + Math.floor(Math.random()*2);
      fx.blood.push(particle);
    }
  }
  
  function spawnSparks(x,y,count=12){
    for (let i=0;i<count;i++){
      const particle = getParticle('sparks');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*120-60)*CFG.SCALE;
      particle.vy = (-Math.random()*140-40)*CFG.SCALE;
      particle.life = 300 + Math.random()*300;
      particle.size = 2 + Math.floor(Math.random()*2);
      fx.sparks.push(particle);
    }
  }
  function spawnOil(x,y,count=18){
    for (let i=0;i<count;i++){
      const particle = getParticle('oil');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*60-30)*CFG.SCALE;
      particle.vy = (-Math.random()*120-80)*CFG.SCALE;
      particle.life = 900 + Math.random()*600;
      particle.size = 3 + Math.floor(Math.random()*3);
      particle.landed = false;
      fx.oil.push(particle);
    }
  }
  function spawnFlame(x,y,count=10){
    for (let i=0;i<count;i++){
      const particle = getParticle('flame');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*80-40)*CFG.SCALE;
      particle.vy = (40+Math.random()*80)*CFG.SCALE; // tail downward
      particle.life = 300 + Math.random()*250;
      particle.size = 2 + Math.floor(Math.random()*3);
      particle.color = Math.random()<0.5 ? '#ff9800' : '#ffd54f';
    fx.flame.push(particle);
    }
  }
  function spawnConfetti(x,y,count=40){
    const colors = ['#e91e63','#9c27b0','#3f51b5','#03a9f4','#009688','#8bc34a','#ffeb3b','#ff9800'];
    for (let i=0;i<count;i++){
      fx.confetti.push({
        x, y,
        vx: (Math.random()*240-120)*CFG.SCALE,
        vy: (-Math.random()*280-80)*CFG.SCALE,
        life: 900 + Math.random()*900,
        size: 2 + Math.floor(Math.random()*3),
        color: colors[Math.floor(Math.random()*colors.length)],
        rot: Math.random()*Math.PI*2,
        rotSpeed: (Math.random()*2-1)*2
      });
    }
  }
  function spawnDownwash(x,y,scene){
    const count = 4 + Math.floor(Math.random()*3);
    const color = scene==='greenland' ? 'rgba(255,255,255,0.6)' : 'rgba(200,200,200,0.5)';
    for (let i=0;i<count;i++){
      fx.downwash.push({
        x: x + (Math.random()*40-20), y: y + (Math.random()*6-3),
        vx: (Math.random()*60-30)*CFG.SCALE,
        vy: (-Math.random()*40-20)*CFG.SCALE,
        life: 300 + Math.random()*300,
        size: 3 + Math.floor(Math.random()*3),
        color
      });
    }
  }

  // ---------- Choice overlay ----------
  function openChoice(text, onKey){
    choiceOverlay = { text, onKey };
  }
  function closeChoice(){ choiceOverlay = null; }

  // ---------- Info card overlay ----------
  let infoCard = null; // {text, onKey} - styled like flag overlay card
  function openInfoCard(text, onKey){
    infoCard = { text, onKey };
  }
  function closeInfoCard(){ infoCard = null; }
  // Start Nobel drop if ready when closing any info card
  const _origCloseInfoCard = closeInfoCard;
  closeInfoCard = function(){
    infoCard = null;
    if (nobelDrop && nobelDrop.ready && !nobelDrop.active && !GS.nobelAwarded){
      nobelDrop.active = true; nobelDrop.y = -80*CFG.SCALE; nobelDrop.vy = 0; nobelDrop.swingPhase = 0; nobelDrop.swingAmp = 0.6;
    }
  };

  function drawInfoCard() {
    if (!infoCard) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw card background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw text content centered in card
    const lines = infoCard.text.split('\n');
    ctx.fillStyle='#333'; 
    ctx.font=`bold ${16*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    
    const lineHeight = 22*CFG.SCALE;
    const totalTextHeight = lines.length * lineHeight;
    const startY = card.y + (card.h - totalTextHeight) / 2 + lineHeight;
    
    lines.forEach((line, i) => {
      ctx.fillText(line, card.x + card.w/2, startY + i * lineHeight);
    });
    
    ctx.textAlign='left';
  }

  // ---------- Tug-of-war mini-game ----------
  let tug = null; // {pos,lastKey,start,dur}
  function startHandshake(){ 
    openInfoCard("HANDTRYKS-KAMP MED PUTIN\n\nHvem har det kraftigste handtryk?\nDig eller Putin?\nDen staerkeste faar Ukraine!\n\nTryk A og D hurtigt for at vinde!\n\n1) Start kampen!\n2) Du kan ikke fortryde", k => {
      closeInfoCard();
      // Begge options starter spillet - ingen vej tilbage!
      startTug();
    });
  }
  function startTug(){
    if (tug) return;
    tug = { pos:0, lastKey:'', start: nowMs(), dur: 4500 };
  }
  function handleTugKey(k){
    if (!tug) return;
    if ((k==='a' || k==='d') && k!==tug.lastKey){ tug.pos += 0.18; tug.lastKey = k; }
  }

  // ---------- Border drawing overlay (Kremlin) ----------
  // borderDraw already declared above
  function startBorderDraw(mode){
    borderDraw = { active:true, points:[], mode: mode==='putin' ? 'putin' : 'trump', gen:false };
  }
  function stopBorderDraw(save){
    if (save && borderDraw){
      // normalize and store in KR.border
      const card = getBorderCardRect();
      const pts = borderDraw.points.map(p=>({ x: (p.x - card.x)/card.w, y: (p.y - card.y)/card.h }));
      KR.border = pts;
      reactToBorder(pts, borderDraw.mode);
    }
    borderDraw = null;
  }
  function getBorderCardRect(){
    const w = Math.min(620*CFG.SCALE, W*0.8), h = w*0.6;
    return { x: W/2 - w/2, y: H/2 - h/2, w, h };
  }

  // ---------- Flag planting system ----------
  function plantFlag(flagType) {
    KR.ukraineFlag = flagType;
    flagOverlay = { 
      flagType, 
      startTime: nowMs(),
      animationStart: nowMs(),
      animationDuration: 2000 // 2 seconds for animation
    };
  }

  function closeFlagOverlay() {
    flagOverlay = null;
    // Award Nobel immediately after exiting the map if pending and American flag planted
    if (KR.nobelPending && KR.ukraineFlag === 'american' && !GS.nobelAwarded) {
      KR.nobelPending = false;
      awardNobel();
    }
  }

  // Nobel medal drop FX state
  let nobelDrop = { active:false, ready:false, y:-80, vy:0, swingPhase:0, swingAmp:0.6 };
  function awardNobel(){
    ensureAudioInit();
    SFX.achievement();
    // Start falling medal from above immediately
    nobelDrop.ready = false;
    nobelDrop.active = true; 
    nobelDrop.y = -80*CFG.SCALE; 
    nobelDrop.vy = 0; 
    nobelDrop.swingPhase = 0; 
    nobelDrop.swingAmp = 0.6; 
  }

  function drawFlagOverlay() {
    if (!flagOverlay) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.fillStyle='rgba(0,0,0,0)';
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw map background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw world map
    if (MAP_IMG_READY){
      ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
    } else {
      ctx.save(); 
      ctx.translate(card.x, card.y);
      drawEnhancedWorldMap(ctx, card.w, card.h);
      ctx.restore();
    }
    
    // Draw flag on Ukraine
    drawFlagOnUkraine(card, flagOverlay.flagType);
    
    // Show message inside bottom frame with white text
    ctx.fillStyle='#fff'; 
    ctx.font=`bold ${18*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    const message = flagOverlay.flagType === 'american' ? 'UKRAINE ER NU AMERIKANSK TERRITORIUM!' : 'UKRAINE FORBLIVER UNDER RUSSISK INDFLYDELSE!';
    ctx.fillText(message, W/2, card.y + card.h - 25*CFG.SCALE);
    // Instruction inside the frame at the bottom
    ctx.fillStyle='#333'; 
    ctx.font=`${14*CFG.SCALE}px system-ui`;
    ctx.fillText('Tryk Enter for at forts√¶tte', W/2, card.y + card.h - 6*CFG.SCALE);
    ctx.textAlign='left';
  }

  function drawFlagOnUkraine(card, flagType) {
    // Ukraine position on map (relative to card) - updated for new cropped map
    const ukraineX = card.x + card.w * 0.50;
    const ukraineY = card.y + card.h * 0.50;
    
    // Animation calculations
    const elapsed = nowMs() - flagOverlay.animationStart;
    const progress = Math.min(1, elapsed / flagOverlay.animationDuration);
    
    // Easing function with bounce
    const easeOutBounce = (t) => {
      if (t < 1/2.75) {
        return 7.5625 * t * t;
      } else if (t < 2/2.75) {
        return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
      } else if (t < 2.5/2.75) {
        return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
      } else {
        return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
      }
    };
    
    const animatedProgress = easeOutBounce(progress);
    
    // Animation: flag drops from above and scales in
    const startY = ukraineY - 60; // Start position (above Ukraine)
    const currentY = startY + (ukraineY - startY) * animatedProgress;
    const scale = 0.3 + (0.7 * animatedProgress); // Start small, grow to normal
    
    // Draw flag with animation
    const flagWidth = 16 * scale;
    const flagHeight = 12 * scale;
    
    ctx.save();
    // Add slight rotation during fall
    const rotation = (1 - animatedProgress) * 0.3;
    ctx.translate(ukraineX, currentY);
    ctx.rotate(rotation);
    
    if (flagType === 'american') {
      // American flag (simplified)
      ctx.fillStyle='#b22234'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight);
      ctx.fillStyle='#ffffff'; // white stripes
      for (let i = 1; i < flagHeight; i += 2) {
        ctx.fillRect(-flagWidth/2, -flagHeight/2+i, flagWidth, 1);
      }
      ctx.fillStyle='#3c3b6e'; // blue canton
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth/2, flagHeight/2);
    } else if (flagType === 'russian') {
      // Russian flag (simplified)
      ctx.fillStyle='#ffffff'; // white
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight/3);
      ctx.fillStyle='#0039a6'; // blue  
      ctx.fillRect(-flagWidth/2, -flagHeight/2+flagHeight/3, flagWidth, flagHeight/3);
      ctx.fillStyle='#d52b1e'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2+2*flagHeight/3, flagWidth, flagHeight/3);
    }
    
    ctx.restore();
  }
  
  function drawEnhancedWorldMap(ctx, w, h) {
    // Ocean background
    ctx.fillStyle='#4a90e2'; 
    ctx.fillRect(0, 0, w, h);
    
    // Cropped/zoomed view focusing on Europe-Russia-Ukraine area
    // Scale and position everything larger and more centered
    
    // EU (much larger, positioned left)
    ctx.fillStyle='#6c5ce7';
    ctx.beginPath();
    ctx.moveTo(w*0.15, h*0.35);
    ctx.bezierCurveTo(w*0.05, h*0.25, w*0.25, h*0.20, w*0.40, h*0.30);
    ctx.bezierCurveTo(w*0.45, h*0.40, w*0.42, h*0.55, w*0.35, h*0.65);
    ctx.bezierCurveTo(w*0.25, h*0.70, w*0.15, h*0.60, w*0.15, h*0.35);
    ctx.closePath();
    ctx.fill();
    
    // Ukraine (much larger and more central)
    ctx.fillStyle='#ffd32a';
    ctx.beginPath();
    ctx.moveTo(w*0.40, h*0.40);
    ctx.lineTo(w*0.55, h*0.35);
    ctx.lineTo(w*0.65, h*0.45);
    ctx.lineTo(w*0.60, h*0.60);
    ctx.lineTo(w*0.45, h*0.65);
    ctx.lineTo(w*0.35, h*0.55);
    ctx.closePath();
    ctx.fill();
    
    // Russia (large mass, positioned right and top)
    ctx.fillStyle='#d63031';
    ctx.beginPath();
    ctx.moveTo(w*0.55, h*0.10);
    ctx.bezierCurveTo(w*0.45, h*0.05, w*0.70, h*0.02, w*0.95, h*0.15);
    ctx.bezierCurveTo(w*1.00, h*0.25, w*0.95, h*0.50, w*0.85, h*0.60);
    ctx.bezierCurveTo(w*0.70, h*0.65, w*0.60, h*0.55, w*0.55, h*0.40);
    ctx.bezierCurveTo(w*0.50, h*0.25, w*0.55, h*0.10, w*0.55, h*0.10);
    ctx.closePath();
    ctx.fill();

    // China/Asia (smaller, positioned far right)
    ctx.fillStyle='#fdcb6e';
    ctx.beginPath();
    ctx.moveTo(w*0.80, h*0.45);
    ctx.bezierCurveTo(w*0.85, h*0.40, w*0.95, h*0.42, w*0.98, h*0.55);
    ctx.bezierCurveTo(w*0.95, h*0.70, w*0.85, h*0.72, w*0.80, h*0.65);
    ctx.bezierCurveTo(w*0.75, h*0.55, w*0.78, h*0.50, w*0.80, h*0.45);
    ctx.closePath();
    ctx.fill();
    
    // Africa
    ctx.fillStyle='#e17055';
    ctx.beginPath();
    ctx.moveTo(w*0.48, h*0.45);
    ctx.bezierCurveTo(w*0.45, h*0.40, w*0.50, h*0.38, w*0.55, h*0.42);
    ctx.bezierCurveTo(w*0.58, h*0.55, w*0.55, h*0.70, w*0.50, h*0.72);
    ctx.bezierCurveTo(w*0.45, h*0.65, w*0.46, h*0.50, w*0.48, h*0.45);
    ctx.closePath();
    ctx.fill();
    
    // Australia/Oceania
    ctx.fillStyle='#00b894';
    ctx.beginPath();
    ctx.ellipse(w*0.82, h*0.65, w*0.08, h*0.05, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Greenland (highlighted!)
    ctx.fillStyle='#00cec9';
    ctx.beginPath();
    ctx.ellipse(w*0.25, h*0.12, w*0.04, h*0.06, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle='#00b894';
    ctx.lineWidth=2;
    ctx.stroke();
    
    // Add country labels
    ctx.fillStyle='#2d3436';
    ctx.font = `bold ${Math.floor(h*0.04)}px system-ui`;
    ctx.textAlign='center';
    ctx.fillText('üá∫üá∏ USA', w*0.22, h*0.45);
    ctx.fillText('üá∑üá∫ RUSSIA', w*0.70, h*0.25);
    ctx.fillText('üá®üá≥ CHINA', w*0.78, h*0.45);
    ctx.fillText('üá™üá∫ EU', w*0.50, h*0.32);
    ctx.fillText('üá¨üá±', w*0.25, h*0.08);
    
    // Add strategic markers
    ctx.fillStyle='#e84393';
    // Nuclear symbols
    drawNuclearSymbol(ctx, w*0.22, h*0.35, h*0.02); // USA
    drawNuclearSymbol(ctx, w*0.70, h*0.30, h*0.02); // Russia
    drawNuclearSymbol(ctx, w*0.78, h*0.40, h*0.02); // China
  }
  
  function drawNuclearSymbol(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle='#e84393';
    // Nuclear trefoil symbol
    for(let i = 0; i < 3; i++) {
      ctx.save();
      ctx.rotate(i * Math.PI * 2/3);
      ctx.beginPath();
      ctx.arc(0, -size*0.7, size*0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    // Center circle
    ctx.beginPath();
    ctx.arc(0, 0, size*0.3, 0, Math.PI * 2);
    ctx.fillStyle='#2d3436';
    ctx.fill();
    ctx.restore();
  }
  function smoothBorder() {
    if (!borderDraw || borderDraw.points.length < 3) return;
    
    // Simple smoothing using average of neighboring points
    const original = [...borderDraw.points];
    for (let i = 1; i < original.length - 1; i++) {
      const prev = original[i-1];
      const curr = original[i];
      const next = original[i+1];
      
      // Average position with neighbors (weighted toward current)
      borderDraw.points[i] = {
        x: (prev.x * 0.2 + curr.x * 0.6 + next.x * 0.2),
        y: (prev.y * 0.2 + curr.y * 0.6 + next.y * 0.2)
      };
    }
  }
  
  function addDrawingPoint(x, y, time) {
    if (!borderDraw || !borderDraw.points) return;
    
    // Check if we should add this point based on distance and time
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      const timeDiff = time - lastDrawPoint.time;
      const speed = dist / Math.max(timeDiff, 1) * 1000; // pixels per second
      
      // Skip point if too close or moving too fast (likely erratic)
      if (dist < drawingSettings.smoothingDistance) return;
      if (speed > drawingSettings.maxDrawingSpeed && borderDraw.points.length > 2) return;
    }
    
    // Add point with smooth interpolation if gap is large
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      if (dist > drawingSettings.smoothingDistance * 3) {
        // Add intermediate points for smooth curves
        const steps = Math.floor(dist / drawingSettings.smoothingDistance);
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const ix = lastDrawPoint.x + (x - lastDrawPoint.x) * t;
          const iy = lastDrawPoint.y + (y - lastDrawPoint.y) * t;
          borderDraw.points.push({x: ix, y: iy});
        }
      }
    }
    
    borderDraw.points.push({x, y});
    lastDrawPoint = {x, y, time};
    
    // Limit total points to prevent performance issues
    if (borderDraw.points.length > 200) {
      // Remove every other point to reduce complexity while maintaining shape
      borderDraw.points = borderDraw.points.filter((_, i) => i % 2 === 0);
    }
  }
  
  function analyzeBorderLive(pts, card) {
    // Real-time analysis for drawing feedback
    let len=0, turns=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        if (Math.abs(a-b)>0.8) turns++;
      }
      
      // Normalized coordinates for aggression check
      const normalX = (pts[i].x - card.x) / card.w;
      if (normalX > 0.6) aggression++;
    }
    
    const lengthDesc = len < 200 ? 'Short' : len < 500 ? 'Medium' : 'Long';
    const strategyDesc = turns < 3 ? 'Direct' : turns < 8 ? 'Diplomatic' : 'Complex';
    const aggressionDesc = aggression < 2 ? 'Peaceful' : aggression < 5 ? 'Assertive' : 'Aggressive';
    
    return { lengthDesc, strategyDesc, aggressionDesc };
  }
  
  function reactToBorder(pts, mode){
    // Enhanced border analysis
    let len=0, turns=0, straightness=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        const angleDiff = Math.abs(a-b);
        if (angleDiff>0.8) turns++;
        straightness += angleDiff;
      }
      
      // Check for aggressive land grabs (going into enemy territory)
      if (mode==='trump' && pts[i].x > 0.6) aggression++;
      if (mode==='putin' && pts[i].x < 0.4) aggression++;
    }
    
    const complexity = turns + straightness*10;
    const landGrab = aggression / pts.length;
    
    // Enhanced reactions based on border characteristics
    let trumpLines, putinLines;
    
    if (landGrab > 0.3) {
      trumpLines = ['Tremendous expansion!', 'Best deals, huge territory!', 'Making borders great again!'];
      putinLines = ['Very aggressive move.', 'Bold territorial claim.', 'Interesting strategy.'];
    } else if (complexity < 5) {
      trumpLines = ['Simple and effective!', 'Clean lines, perfect!', 'Straight to the point!'];
      putinLines = ['Efficient boundaries.', 'Practical approach.', 'Minimalist style.'];
    } else if (complexity > 20) {
      trumpLines = ['Complex negotiations!', 'Artistic borders!', 'Very detailed work!'];
      putinLines = ['Complicated boundaries.', 'Intricate design.', 'Many considerations.'];
    } else {
      trumpLines = ['Fair and balanced!', 'Perfect compromise!', 'Diplomatic borders!'];
      putinLines = ['Reasonable solution.', 'Balanced approach.', 'Acceptable terms.'];
    }
    
    const line = (mode==='trump' ? trumpLines : putinLines)[Math.floor(Math.random() * 3)];
    
    if (mode==='trump') {
      say(player, line, 1800);
    } else { 
      KR.putin.speakingUntil=nowMs()+1800; 
      KR.putin.say=line;
    }
    
    // Store border metrics for potential future use
    KR.borderMetrics = { length: len, complexity, aggression: landGrab, mode };
  }

  // ---------- Tegn elementer ----------
  function drawTrump(x,y,dir=1){
    // Draw either custom sprite or fallback
    const usedImg = GRAPHICS.drawOrFallback(ctx, 'trump', drawTrumpFallback, x, y, dir);
    if (!usedImg) drawTrumpFallback(x, y, dir);
    // Overlay Nobel medal if awarded
    if (GS.nobelAwarded) drawNobelMedal(x, y);
  }
  
  function drawTrumpFallback(x,y,dir=1){
    // slight head/torso nod
    const nod = Math.sin(nowMs()/1100 + (player.nodPhase||0)) * 0.6*CFG.SCALE;
    // subtle swim bob when submerged
    let bob = 0;
    if (scene==='greenland' && glacierExplosion && glacierExplosion.active && glacierExplosion.waterLevel>0){
      const waterLine = H - glacierExplosion.waterLevel;
      const headY = y - 44*CFG.SCALE + nod - 38*CFG.SCALE;
      if (headY > waterLine) bob = Math.sin(nowMs()/600)*1.5*CFG.SCALE;
    }
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod + bob); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    const wearingGoldSneakers = !!player.goldenShoesOn;
    function paintLegRect(xPos, yPos, w, h){
      const pantHeight = wearingGoldSneakers ? Math.max(0, h - 4) : h;
      if (pantHeight > 0){
        ctx.fillStyle='#2b2b2b';
        ctx.fillRect(xPos, yPos, w, pantHeight);
      }
      if (wearingGoldSneakers){
        const shoeY = yPos + pantHeight;
        const shoeH = Math.max(0, h - pantHeight);
        if (shoeH > 0){
          ctx.fillStyle='#f5d36a';
          ctx.fillRect(xPos, shoeY, w, shoeH);
          if (shoeH >= 2 && w >= 4){
            ctx.fillStyle='#1e4fbf';
            ctx.fillRect(xPos + 1, shoeY, Math.max(1, w - 2), 1);
            if (shoeH >= 3){
              ctx.fillStyle='#ff3b2f';
              ctx.fillRect(xPos + 1, shoeY + 1, Math.max(1, w - 2), 1);
            }
          }
          ctx.fillStyle='#b88a1d';
          ctx.fillRect(xPos, shoeY + shoeH - 1, w, 1);
        }
      }
    }

    // Walking animation for legs
    if (player.walking && Math.floor(player.walkCycle) % 2 === 0) {
      // Walking pose 1 - left leg forward
      paintLegRect(-10,34,9,10); // left leg normal
      paintLegRect(2,36,9,8);    // right leg back/up
    } else if (player.walking) {
      // Walking pose 2 - right leg forward  
      paintLegRect(-10,36,9,8);  // left leg back/up
      paintLegRect(2,34,9,10);   // right leg normal
    } else {
      // Standing still - normal pose
      paintLegRect(-10,34,9,10); 
      paintLegRect(2,34,9,10);
    }
    ctx.fillStyle='#7a5328'; ctx.fillRect(-12,6,24,26);
    ctx.fillStyle='#d8e6ff'; ctx.fillRect(-8,10,16,18);
    ctx.fillStyle='#e02424'; ctx.fillRect(-2,14,4,14);
    ctx.fillStyle=skinColor(); ctx.fillRect(-9,-2,18,12);
    // eyes (blink)
    if (!(player.blinkUntil && nowMs() < player.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
    } else {
      ctx.fillStyle='#111'; ctx.fillRect(-6,3,2,1); ctx.fillRect(4,3,2,1);
    }
    // hair or cap
    if (player.capOn){
      ctx.fillStyle='#c22'; ctx.fillRect(-10,-6,20,6); ctx.fillRect(-12,-2,24,2);
    } else {
      ctx.fillStyle='#f3a32d'; ctx.fillRect(-10,-6,20,6);
    }
    // item in hand: dynamite if selected, otherwise phone (blinking)
    const blinking = nowMs() < phoneBlinkUntil && Math.floor(nowMs()/100)%2===0;
    if (player.selectedItem === 'dynamite'){
      ctx.fillStyle='#d32f2f';
      if (dir<0){ ctx.fillRect(-20,12,6,14); ctx.fillRect(-12,12,6,14); ctx.fillStyle='#333'; ctx.fillRect(-20,16,6,2); ctx.fillRect(-12,16,6,2); }
      else { ctx.fillStyle='#d32f2f'; ctx.fillRect(10,12,6,14); ctx.fillRect(18,12,6,14); ctx.fillStyle='#333'; ctx.fillRect(10,16,6,2); ctx.fillRect(18,16,6,2); }
    } else {
      ctx.fillStyle='#111';
      if (dir<0){
        ctx.fillRect(-20,12,10,16);
        ctx.fillStyle = blinking ? '#6ff' : '#09f';
        ctx.fillRect(-17,16,4,8);
      } else {
        ctx.fillRect(10,12,10,16);
        ctx.fillStyle = blinking ? '#6ff' : '#09f';
        ctx.fillRect(13,16,4,8);
      }
    }
    ctx.globalAlpha=.2; ctx.fillStyle='#000'; if (dir<0) ctx.fillRect(-14,15,2,10); else ctx.fillRect(12,15,2,10);
    ctx.restore();
  }
  // Smiling Trump variant for overlays
  function drawTrumpSmile(x,y){
    const nod = Math.sin(nowMs()/1100 + (player.nodPhase||0)) * 0.3*CFG.SCALE;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
    // body
    const smileWearingGold = !!player.goldenShoesOn;
    function paintSmileLeg(xPos, yPos, w, h){
      const pantHeight = smileWearingGold ? Math.max(0, h - 4) : h;
      if (pantHeight > 0){
        ctx.fillStyle='#2b2b2b';
        ctx.fillRect(xPos, yPos, w, pantHeight);
      }
      if (smileWearingGold){
        const shoeY = yPos + pantHeight;
        const shoeH = Math.max(0, h - pantHeight);
        if (shoeH > 0){
          ctx.fillStyle='#f5d36a'; ctx.fillRect(xPos, shoeY, w, shoeH);
          if (shoeH >= 2 && w >= 4){
            ctx.fillStyle='#1e4fbf'; ctx.fillRect(xPos + 1, shoeY, Math.max(1, w - 2), 1);
            if (shoeH >= 3){
              ctx.fillStyle='#ff3b2f'; ctx.fillRect(xPos + 1, shoeY + 1, Math.max(1, w - 2), 1);
            }
          }
          ctx.fillStyle='#b88a1d'; ctx.fillRect(xPos, shoeY + shoeH - 1, w, 1);
        }
      }
    }
    paintSmileLeg(-10,34,9,10); 
    paintSmileLeg(2,34,9,10);
    ctx.fillStyle='#7a5328'; ctx.fillRect(-12,6,24,26);
    ctx.fillStyle='#d8e6ff'; ctx.fillRect(-8,10,16,18);
    ctx.fillStyle='#e02424'; ctx.fillRect(-2,14,4,14);
    // face
    ctx.fillStyle=skinColor(); ctx.fillRect(-9,-2,18,12);
    // eyes
    ctx.fillStyle='#111'; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
    // hair
    ctx.fillStyle='#f3a32d'; ctx.fillRect(-10,-6,20,6);
    // smile
    ctx.fillStyle='#111'; ctx.fillRect(-3,6,6,1);
    ctx.fillStyle='#111'; ctx.fillRect(-4,5,1,1); ctx.fillRect(3,5,1,1);
    ctx.restore();
  }
  // Epstein figure with sunglasses
  function drawEpsteinSunglasses(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // suit
    ctx.fillStyle='#333'; ctx.fillRect(-10,8,20,26);
    // legs
    ctx.fillStyle='#111'; ctx.fillRect(-7,34,6,10); ctx.fillRect(1,34,6,10);
    // shirt
    ctx.fillStyle='#ddd'; ctx.fillRect(-6,12,12,12);
    // face
    ctx.fillStyle='#e6c9a8'; ctx.fillRect(-8,-2,16,12);
    // sunglasses
    ctx.fillStyle='#111'; ctx.fillRect(-7,2,6,3); ctx.fillRect(1,2,6,3); ctx.fillRect(-1,3,2,1);
    // hair (gray)
    ctx.fillStyle='#bbb'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  // Grayscale versions for newspaper photo
  function drawTrumpBW(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#444'; ctx.fillRect(-10,34,9,10); ctx.fillRect(2,34,9,10);
    ctx.fillStyle='#666'; ctx.fillRect(-12,6,24,26);
    ctx.fillStyle='#bbb'; ctx.fillRect(-8,10,16,18);
    ctx.fillStyle='#555'; ctx.fillRect(-2,14,4,14);
    ctx.fillStyle='#caa'; ctx.fillRect(-9,-2,18,12);
    ctx.fillStyle='#222'; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
    ctx.fillStyle='#999'; ctx.fillRect(-10,-6,20,6);
    ctx.restore();
  }
  function drawEpsteinBWSunglasses(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#444'; ctx.fillRect(-10,8,20,26);
    ctx.fillStyle='#222'; ctx.fillRect(-7,34,6,10); ctx.fillRect(1,34,6,10);
    ctx.fillStyle='#bbb'; ctx.fillRect(-6,12,12,12);
    ctx.fillStyle='#999'; ctx.fillRect(-8,-2,16,12);
    ctx.fillStyle='#111'; ctx.fillRect(-7,2,6,3); ctx.fillRect(1,2,6,3); ctx.fillRect(-1,3,2,1);
    ctx.fillStyle='#aaa'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  // Simple plane labeled VIRGIN
  function drawVirginPlane(cx, cy, scale=1){
    ctx.save(); ctx.translate(cx, cy); ctx.scale(CFG.SCALE*scale, CFG.SCALE*scale);
    // fuselage
    ctx.fillStyle='#e0e0e0'; ctx.fillRect(-120,-20,240,40);
    // nose
    ctx.beginPath(); ctx.moveTo(-120,-20); ctx.quadraticCurveTo(-150,0,-120,20); ctx.closePath(); ctx.fill();
    // tail
    ctx.fillStyle='#b71c1c'; ctx.fillRect(90,-40,20,40);
    // wing
    ctx.fillStyle='#d0d0d0'; ctx.fillRect(-30,-8,140,16);
    // text VIRGIN
    ctx.fillStyle='#b71c1c'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; ctx.fillText('VIRGIN', 10, 4);
    ctx.restore();
  }
  function drawNobelMedal(x,y){
    // Draw simple ribbon + gold medal overlay on chest area
    ctx.save();
    ctx.translate(x, y-44*CFG.SCALE);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    // ribbon
    ctx.fillStyle = '#1565c0';
    ctx.fillRect(-8, 10, 16, 3);
    // medal string
    ctx.fillStyle = '#1e88e5';
    ctx.fillRect(-2, 10, 4, 8);
    // medal
    ctx.fillStyle = '#d4af37';
    ctx.beginPath(); ctx.arc(0, 20, 5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function skinColor(){
    // Enhanced, more dramatic tan gradient (0..5)
    const levels = ['#f4cda4','#f1b577','#ee9850','#ea7a28','#e16706','#c65200'];
    return levels[Math.min(levels.length-1, player.tanLevel||0)];
  }
  function drawMette(x,y){
    // removed ground shadow per request
    const nod = Math.sin(nowMs()/1200 + (GL.mette.nodPhase||0)) * 0.5*CFG.SCALE;
    const offset = getInteractionOffset({type:'mette', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-44*CFG.SCALE + nod + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // dress with Danish flag motif (red with white cross)
    ctx.fillStyle='#c01818'; ctx.fillRect(-10,8,20,26);
    // vertical white stripe
    ctx.fillStyle='#fff'; ctx.fillRect(-2,8,4,26);
    // horizontal white stripe
    ctx.fillRect(-10,20,20,4);
    // legs
    ctx.fillStyle='#2b2b2b'; ctx.fillRect(-6,34,6,10); ctx.fillRect(0,34,6,10);
    // inner shirt
    ctx.fillStyle='#d7cce5'; ctx.fillRect(-7,12,14,16);
    // face + hair
    ctx.fillStyle='#f4c59a'; ctx.fillRect(-8,-2,16,12);
    // eyes
    if (!(GL.mette.blinkUntil && nowMs() < GL.mette.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
    } else { ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1); }
    ctx.fillStyle='#5a4a2a'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawBear(x,y,alive=true){
    // Check if custom bear image is available
    if (GRAPHICS.drawOrFallback(ctx, 'bear', drawBearFallback, x, y, alive)) {
      return; // Custom image was drawn successfully
    }
    
    drawBearFallback(x, y, alive);
  }
  
  function drawBearFallback(x,y,alive=true){
    const offset = getInteractionOffset({type:'bear', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-30*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Body
    ctx.fillStyle='#ffffff'; 
    ctx.fillRect(-30,10,60,18); // main body
    ctx.fillRect(-26,26,10,6); ctx.fillRect(-6,26,10,6); ctx.fillRect(14,26,10,6); // paws
    
    // Head - bigger when angry, faces direction (only check in Greenland scene)
    const facing = (scene === 'greenland' && GL.bear) ? (GL.bear.facing || 1) : 1;
    
    if (scene === 'greenland' && GL.bear && GL.bear.angry && alive) {
      // BIGGER ANGRY HEAD - position based on facing direction
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 18 : -42; // flip head position
      ctx.fillRect(headX,-8,24,20);   // much bigger head
      
      // ANGRY BEAR - RED EYES, BIG OPEN MOUTH WITH TEETH
      ctx.fillStyle='#ff0000'; // Red angry eyes  
      if (facing > 0) {
        // Facing right
        ctx.fillRect(36,4,6,5); ctx.fillRect(28,2,4,3); // bigger red eyes
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(24,8,14,8); // much wider and taller mouth
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth
        ctx.fillRect(25,8,2,4); ctx.fillRect(28,8,2,4); ctx.fillRect(31,8,2,4); ctx.fillRect(34,8,2,4); 
        // Bottom row of teeth  
        ctx.fillRect(26,12,2,4); ctx.fillRect(29,12,2,4); ctx.fillRect(32,12,2,4); ctx.fillRect(35,12,2,4);
        
        // Extra angry eyebrows
        ctx.fillStyle='#000';
        ctx.fillRect(26,0,6,2); ctx.fillRect(36,0,6,2); // bigger angry eyebrows
      } else {
        // Facing left - mirror everything
        ctx.fillRect(-42,4,6,5); ctx.fillRect(-32,2,4,3); // bigger red eyes (flipped)
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(-38,8,14,8); // much wider and taller mouth (flipped)
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth (flipped)
        ctx.fillRect(-37,8,2,4); ctx.fillRect(-34,8,2,4); ctx.fillRect(-31,8,2,4); ctx.fillRect(-28,8,2,4); 
        // Bottom row of teeth (flipped)
        ctx.fillRect(-36,12,2,4); ctx.fillRect(-33,12,2,4); ctx.fillRect(-30,12,2,4); ctx.fillRect(-27,12,2,4);
        
        // Extra angry eyebrows (flipped)
        ctx.fillStyle='#000';
        ctx.fillRect(-42,0,6,2); ctx.fillRect(-32,0,6,2); // bigger angry eyebrows
      }
      
    } else {
      // Normal smaller head - position based on facing direction  
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 22 : -38;
      ctx.fillRect(headX,0,16,12);   // normal head
      // Normal bear eyes - position based on facing
      ctx.fillStyle='#222'; 
      if (facing > 0) {
        ctx.fillRect(34,6,4,4); ctx.fillRect(30,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(30,4,2,2); ctx.fillRect(34,6,4,1); 
        }
      } else {
        // Facing left - flipped eyes
        ctx.fillRect(-38,6,4,4); ctx.fillRect(-32,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(-32,4,2,2); ctx.fillRect(-38,6,4,1); 
        }
      }
    }
    
    ctx.restore();
  }
  function drawBearHP(bear){
    if (!bear.alive) return;
    const hp = Math.max(0, bear.hp||2), max=2;
    const y = bear.y - 40*CFG.SCALE; const x = bear.x - (max*10*CFG.SCALE)/2;
    for (let i=0;i<max;i++){
      ctx.fillStyle = i < hp ? '#e33' : 'rgba(255,255,255,.35)';
      ctx.fillRect(x + i*10*CFG.SCALE, y, 8*CFG.SCALE, 4*CFG.SCALE);
    }
  }
  function drawMine(x,y){
    // Hole in the ice with depth
    const offset = getInteractionOffset({type:'mine', x, y});
    ctx.save(); ctx.translate(x + offset.x, y + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // rim highlight
    ctx.fillStyle = '#cfeef9';
    ctx.beginPath(); ctx.ellipse(0, -2, 22, 7, 0, 0, Math.PI*2); ctx.fill();
    // top ellipse (opening)
    ctx.fillStyle = '#4a5f6a';
    ctx.beginPath(); ctx.ellipse(0, 0, 18, 6, 0, 0, Math.PI*2); ctx.fill();
    // depth (clipped rectangle)
    ctx.save();
    ctx.beginPath(); ctx.ellipse(0, 0, 18, 6, 0, 0, Math.PI*2); ctx.rect(-18,0,36,34); ctx.clip();
    const shaftDepth = Math.max(40, (H - y)/CFG.SCALE);
    const grad = ctx.createLinearGradient(0,0,0,shaftDepth);
    grad.addColorStop(0,'#22313b'); grad.addColorStop(1,'#0b0f12');
    ctx.fillStyle=grad; ctx.fillRect(-18,0,36,shaftDepth);
    // simple ladder rungs
    ctx.fillStyle='#8b6f3b'; for (let i=6;i<shaftDepth;i+=6){ ctx.fillRect(-4,i,8,2); }
    ctx.restore();
    // scattered ice chunks
    ctx.fillStyle='#a8d3e1'; ctx.fillRect(-20,2,4,2); ctx.fillRect(16,2,4,2);
    // wooden sign: "Rare minerals" (wider)
    const sx=36, sy=-4;
    ctx.fillStyle='#7b5a2b'; ctx.fillRect(sx, sy-30, 3, 30);
    ctx.fillStyle='#9b7a3e'; ctx.fillRect(sx-44, sy-50, 90, 22);
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.strokeRect(sx-44, sy-50, 90, 22);
    ctx.fillStyle='#fff'; ctx.font='bold 10px system-ui'; ctx.textAlign='center';
    ctx.fillText('RARE MINERALS', sx, sy-36);
    ctx.textAlign='left';
    ctx.restore();
  }

  function drawShopStall(shop){
    if (!shop) return;
    const off = getInteractionOffset(shop);
    ctx.save();
    ctx.translate(shop.x + (off?.x || 0), shop.y + (off?.y || 0));
    ctx.scale(CFG.SCALE, CFG.SCALE);
    const SCALE = 0.273;
    const anchorX = 483.5; // centre of main body in SVG coords
    const anchorY = 478.9; // bottom of legs
    ctx.scale(SCALE, SCALE);
    ctx.translate(-anchorX, -anchorY);

    function rect(fill, stroke, x, y, w, h, lineWidth){
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, w, h);
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth || 6; ctx.strokeRect(x, y, w, h); }
    }
    function poly(fill, stroke, pts, lineWidth){
      ctx.beginPath();
      pts.forEach(([px, py], i) => i ? ctx.lineTo(px, py) : ctx.moveTo(px, py));
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth || 6; ctx.stroke(); }
    }

    // Legs
    rect('#c38d51', '#b08350', 572.5, 453, 18.6, 25.9, 6);
    rect('#c38d51', '#b08350', 373, 453, 18.6, 25.9, 6);

    // Main cabinet
    rect('#bb3d3d', '#cc5454', 370, 279, 227, 179.7, 6);

    // Horizontal bands (front panels)
    poly('#e54848', '#902222', [
      [571.5, 386.5], [399.5, 386.5], [399.5, 448.5], [571.5, 449.5]
    ], 6);
    poly('#e54848', '#902222', [
      [571.5, 293], [399.5, 293], [399.5, 355], [571.5, 356]
    ], 6);

    // Shelves
    poly('#f2d2d2', '#902222', [
      [567.5, 336], [399.5, 336], [373.5, 375], [594.5, 375.5]
    ], 6);
    poly('#f2d2d2', '#902222', [
      [571.5, 421.5], [399.5, 421.5], [373.5, 460.5], [594.5, 461]
    ], 6);

    // Shelf trim lines
    ctx.strokeStyle = '#bb3d3d';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(332.5, 289);
    ctx.lineTo(643.5, 289);
    ctx.moveTo(367.2, 462);
    ctx.lineTo(600, 462);
    ctx.stroke();

    // Roof
    poly('#bb3d3d', '#a43636', [
      [601, 241], [381, 241], [340, 284], [638.5, 284]
    ], 6);

    // Sign posts
    rect('#f2b470', '#c05454', 598, 140, 5.4, 122.8, 6);
    rect('#f2b470', '#c05454', 373, 140, 5.4, 122.8, 6);

    // Sign board
    rect('#f2b470', '#c05454', 364, 75, 245.7, 69, 6);
    ctx.fillStyle = '#5b2b2b';
    ctx.font = 'bold 42px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('BUTIK', 486.85, 123);
    ctx.textAlign = 'left';

    // Product layout (use original coordinates)
    const shelfItemY = 350;
    const layout = [
      { id: 'tan', x: 430, y: 320 },
      { id: 'shoes', x: 540, y: 320 },
      { id: 'maga', x: 420, y: 380 },
      { id: 'dynamite', x: 550, y: 380 }
    ];
    layout.forEach(slot => {
      const item = SHOP_ITEMS.find(it => it.id === slot.id);
      if (!item) return;
      ctx.save();
      const sy = slot.y || shelfItemY;
      ctx.translate(slot.x, sy);
      ctx.scale(2.4, 2.4);
      ctx.translate(-19, -16);
      drawInvIcon(ctx, slot.id);
      ctx.restore();

      const tagY = (slot.y || shelfItemY) + 48;
      const tagW = 64;
      const tagH = 20;
      ctx.fillStyle = '#fdf0c4';
      ctx.fillRect(slot.x - tagW/2, tagY, tagW, tagH);
      ctx.strokeStyle = '#b08350';
      ctx.lineWidth = 4;
      ctx.strokeRect(slot.x - tagW/2, tagY, tagW, tagH);
    ctx.fillStyle = '#5b2b2b';
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`${item.price} g`, slot.x, tagY + 14);
      ctx.textAlign = 'left';
    });

    ctx.restore();
  }
  // y parameter is pole base (ground contact)
  function drawFlag(x,y){
    const poleH = 40*CFG.SCALE; const flagW = 36*CFG.SCALE; const flagH = 24*CFG.SCALE;
    // pole
    ctx.fillStyle='#666'; ctx.fillRect(x-2, y-poleH, 4, poleH);
    // flag top anchored near pole top
    const topY = y - poleH + 4*CFG.SCALE;
    const fx = x + 2;
    // stripes
    const stripes = 13; const stripeH = flagH/stripes;
    for (let i=0;i<stripes;i++){
      ctx.fillStyle = (i%2===0) ? '#bf0a30' : '#fff';
      ctx.fillRect(fx, topY + i*stripeH, flagW, stripeH);
    }
    // canton
    const cantonW = 14*CFG.SCALE; const cantonH = stripeH*7;
    ctx.fillStyle = '#002868';
    ctx.fillRect(fx, topY, cantonW, cantonH);
    // tiny stars
    ctx.fillStyle='#fff';
    for (let r=0;r<5;r++){
      for (let c=0;c<6;c++){
        const sx = fx + 2 + c* (cantonW/6);
        const sy = topY + 2 + r* (cantonH/5);
        ctx.fillRect(sx, sy, 1, 1);
      }
    }
  }
  function drawPhone(x,y){
    const offset = getInteractionOffset({type:'phone', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-34*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#111'; ctx.fillRect(-8,0,16,28);
    ctx.fillStyle='#0af'; ctx.fillRect(-6,4,12,18);
    ctx.restore();
  }
  function drawPickup(it){
    const bob = Math.sin(nowMs()/600 + it.x*0.01)*4*CFG.SCALE;
    const px = it.x, py = it.y-26*CFG.SCALE + bob;
    // Try custom sprites based on item id
    if (it.id==='tan' && GRAPHICS.drawOrFallback(ctx, 'tan_bottle', () => {}, px, py)) return;
    if (it.id==='shoes' && GRAPHICS.drawOrFallback(ctx, 'golden_shoes', () => {}, px, py)) return;
    if (it.id==='maga' && GRAPHICS.drawOrFallback(ctx, 'maga_cap', () => {}, px, py)) return;
    if (it.id==='dynamite' && GRAPHICS.drawOrFallback(ctx, 'dynamite', () => {}, px, py)) return;
    // Fallback vector icons
    ctx.save(); ctx.translate(px, py); ctx.scale(CFG.SCALE, CFG.SCALE);
    if (it.id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,8,16,10); ctx.fillStyle='#ccc'; ctx.fillRect(-6,4,12,6); }
    else if (it.id==='shoes'){
      ctx.fillStyle='#f5d36a'; ctx.fillRect(-14,4,28,12);
      ctx.fillStyle='#b88a1d'; ctx.fillRect(-14,14,28,4);
      ctx.fillStyle='#fff'; ctx.fillRect(-14,18,28,2);
      ctx.fillStyle='#ff3b2f'; ctx.fillRect(0,6,12,3);
      ctx.fillStyle='#1e4fbf'; ctx.fillRect(4,-2,12,6);
      ctx.fillStyle='#ffd700'; ctx.fillRect(6,0,3,2); ctx.fillRect(11,0,3,2); ctx.fillRect(8,2,3,2);
    }
    else if (it.id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,10,24,8); ctx.fillRect(-10,4,20,6); }
    else if (it.id==='dynamite'){ 
      // Two red sticks with black bands (match inventory icon)
      ctx.fillStyle='#d32f2f'; ctx.fillRect(-8,0,6,16); ctx.fillRect(2,0,6,16);
      ctx.fillStyle='#333'; ctx.fillRect(-8,4,6,2); ctx.fillRect(2,4,6,2);
      ctx.fillStyle='#333'; ctx.fillRect(-8,10,6,2); ctx.fillRect(2,10,6,2);
    }
    ctx.restore();
  }
  function drawGoldBar(goldBar){
    // gentle float/bob like pickups
    const bob = Math.sin(nowMs()/400 + goldBar.x*0.01)*3*CFG.SCALE;
    ctx.save(); ctx.translate(goldBar.x, goldBar.y-20*CFG.SCALE + bob); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // 3D Gold bar design (no text on bar itself)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(-8, -2, 16, 8); // bottom part
    ctx.fillRect(6, -4, 2, 6);   // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(-8, -4, 14, 6);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(-8, -4, 14, 3); // top surface
    ctx.fillRect(-8, -6, 2, 2);  // left edge highlight
    
    ctx.restore();
  }
  function drawRig(x,y){
    // Oil rig silhouette aligned to ground (no shadow)
    ctx.save(); ctx.translate(x, y-78*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // base
    ctx.fillStyle='#111'; ctx.fillRect(-36,70,72,8); ctx.fillRect(-30,62,60,6);
    // tower legs (triangular)
    ctx.fillStyle='#222';
    ctx.fillRect(-22,10,4,52); ctx.fillRect(18,10,4,52);
    // cross braces
    ctx.strokeStyle='#222'; ctx.lineWidth=4; ctx.beginPath();
    ctx.moveTo(-22,12); ctx.lineTo(18,36); ctx.moveTo(-22,36); ctx.lineTo(18,60);
    ctx.moveTo(18,12); ctx.lineTo(-22,36); ctx.moveTo(18,36); ctx.lineTo(-22,60);
    ctx.stroke();
    // central column
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-3,4,6,62);
    // top cap
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-16,-6,32,12); ctx.fillRect(-20,6,40,4);
    ctx.restore();
  }
  function drawHeli(x,y,spin=0.35){
    // Check if custom helicopter image is available
    if (GRAPHICS.drawOrFallback(ctx, 'helicopter', drawHeliFallback, x, y, spin)) {
      return; // Custom image was drawn successfully
    }
    
    drawHeliFallback(x, y, spin);
  }
  
  function drawHeliFallback(x,y,spin=0.35){
    ctx.save(); ctx.translate(x, y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // krop
    ctx.fillStyle='#2c3e50'; ctx.fillRect(-40,-10,100,28); // body
    // cockpit
    ctx.fillStyle='#86d0ff'; ctx.fillRect(46,-6,10,16);
    // rotor
    ctx.fillStyle='#333'; ctx.fillRect(6,-18,4,8); ctx.fillRect(-40,-22,140,4);
    // subtle rotor blur
    const t = nowMs();
    const alpha = Math.min(1, Math.max(0, spin));
    ctx.globalAlpha = 0.18 * alpha; ctx.fillStyle = '#000';
    const blurW = 160 + Math.sin(t/80)*8; ctx.fillRect(-blurW/2, -23, blurW, 6);
    ctx.globalAlpha = 1;
    // ben
    ctx.fillStyle='#333'; ctx.fillRect(-30,18,60,4); ctx.fillRect(20,18,40,4);
    ctx.restore();
  }
  function playEntryHeli(line, stopX){
    entryHeli.active = true; entryHeli.line = line || '';
    entryHeli.vertical = true;
    // Fixed stop X like Greenland, descend from above screen
    entryHeli.targetX = (typeof stopX === 'number') ? stopX : 160*CFG.SCALE;
    entryHeli.x = entryHeli.targetX;
    entryHeli.startY = -200*CFG.SCALE;
    entryHeli.targetY = (H - world.floor) - 18*CFG.SCALE;
    entryHeli.y = entryHeli.startY;
    entryHeli.start = nowMs(); entryHeli.dur = 1600;
  }
  // Intro: land helicopter from offscreen and have Trump step out
  function scheduleHeliIntro(line){
    // Use the same vertical entry animation as other scenes
    playEntryHeli(line || 'Perfect landing! Helicopter takes us anywhere.', 160*CFG.SCALE);
  }
  function drawBerg(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w/2, cy+h/2); ctx.lineTo(cx, cy-h/2); ctx.lineTo(cx+w/2, cy+h/2); ctx.closePath(); ctx.fill(); }
  
  function drawGlacier(x, y, w, h, blown = false) {
    if (blown) return; // Don't draw if blown up
    
    const offset = getInteractionOffset({type:'glacier', x, y});
    ctx.save(); 
    ctx.translate(x + offset.x, y + offset.y); 
    ctx.scale(CFG.SCALE, CFG.SCALE);
    // Optional glacier sprite override
    if (GRAPHICS.imageReady('glacier')) {
      const img = GRAPHICS.images.get('glacier');
      const gw = w, gh = h;
      ctx.drawImage(img, -gw/2, -gh/2, gw, gh);
      ctx.restore();
      return;
    }
    
    // Large glacier - more detailed than small bergs
    ctx.fillStyle='#e8f4f8';
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2);
    ctx.lineTo(-w/3, -h/2);
    ctx.lineTo(0, -h/2 - 20);
    ctx.lineTo(w/3, -h/2);
    ctx.lineTo(w/2, h/2);
    ctx.closePath();
    ctx.fill();
    
    // Shading/details
    ctx.fillStyle='#d0e8f0';
    ctx.beginPath();
    ctx.moveTo(-w/4, 0);
    ctx.lineTo(-w/6, -h/3);
    ctx.lineTo(w/6, -h/3);
    ctx.lineTo(w/4, 0);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }

  // Oval Office
  function drawOvalBackdrop(){
    // Wallpapered wall
    ctx.fillStyle='#f4efe3'; ctx.fillRect(0,0,W,H);
    // subtle damask-like pattern
    ctx.save(); ctx.globalAlpha=0.06; ctx.fillStyle='#bfb7a6';
    for (let y=40*CFG.SCALE; y<H-80*CFG.SCALE; y+=30*CFG.SCALE){
      for (let x=40*CFG.SCALE; x<W; x+=50*CFG.SCALE){
        ctx.beginPath(); ctx.ellipse(x, y, 18*CFG.SCALE, 8*CFG.SCALE, 0, 0, Math.PI*2); ctx.fill();
      }
    }
    ctx.restore();
    
    // Mantle and shelf
    const shelfY = H - world.floor - 44*CFG.SCALE;
    const shelfW = W*0.62, shelfX = W/2 - shelfW/2;
    // simple mantle block
    ctx.fillStyle='#e9e4d8'; ctx.fillRect(shelfX-30*CFG.SCALE, shelfY-30*CFG.SCALE, shelfW+60*CFG.SCALE, 26*CFG.SCALE);
    ctx.strokeStyle='#d2cbbd'; ctx.lineWidth=2; ctx.strokeRect(shelfX-30*CFG.SCALE, shelfY-30*CFG.SCALE, shelfW+60*CFG.SCALE, 26*CFG.SCALE);
    // shelf top
    ctx.fillStyle='#d9d2c4'; ctx.fillRect(shelfX, shelfY, shelfW, 10*CFG.SCALE);
    ctx.fillStyle='#cfc7b6'; ctx.fillRect(shelfX, shelfY+10*CFG.SCALE, shelfW, 4*CFG.SCALE);

    // Two floating shelves left and right of TV (below TV center)
    const tvW = 110*CFG.SCALE, tvH = 196*CFG.SCALE; // keep in sync with drawOvalWallScreen
    const tvCx = W/2, tvCy = 115*CFG.SCALE + tvH/2 + 150;
    const shelfY2 = tvCy + tvH*0.15; // a little lower than TV center
    const gap = 40*CFG.SCALE; // gap around TV
    const leftW = tvCx - tvW/2 - gap - 60*CFG.SCALE; // left shelf width
    const rightW = W - (tvCx + tvW/2 + gap) - 60*CFG.SCALE; // right shelf width
    const leftX = 40*CFG.SCALE; const rightX = tvCx + tvW/2 + gap;
    // draw shelves
    drawFloatingShelf(leftX, shelfY2, leftW);
    drawFloatingShelf(rightX, shelfY2, rightW);
    // base statues: 3 per shelf
    drawShelfStatuesRow(leftX, shelfY2, leftW, 3);
    drawShelfStatuesRow(rightX, shelfY2, rightW, 3);
    // extra stolen statues added alternating left/right
    drawLootStatues(leftX, rightX, shelfY2, leftW, rightW);
    
    // carpet (keep)
    ctx.fillStyle='#d4c6a6'; ctx.fillRect(0,H-world.floor,W,world.floor);
    ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle='#000';
    ctx.beginPath(); ctx.ellipse(W/2, H - world.floor + 60*CFG.SCALE, 200*CFG.SCALE, 40*CFG.SCALE, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    // subtle seal
    const cy = H - world.floor + 56*CFG.SCALE, cx = W/2;
    ctx.save(); ctx.translate(cx, cy); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.globalAlpha = 0.22; ctx.fillStyle = '#1e3a5f'; ctx.beginPath(); ctx.arc(0,0,38,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.9; ctx.strokeStyle='#f6e27d'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,40,0,Math.PI*2); ctx.stroke();
    ctx.restore();
    // (Desk body drawn later after Trump for proper layering)

    // Wall screen (TV) behind desk
    drawOvalWallScreen();
  }

  function drawFloatingShelf(x, y, w){
    ctx.fillStyle='#d9d2c4'; ctx.fillRect(x, y, w, 8*CFG.SCALE);
    ctx.fillStyle='#cfc7b6'; ctx.fillRect(x, y+8*CFG.SCALE, w, 3*CFG.SCALE);
  }
  function drawShelfStatuesRow(x, y, w, count){
    const spacing = w/(count+1);
    for (let i=1;i<=count;i++){
      const sx = Math.round(x + spacing*i);
      const variant = (i % 3) + 1; // stable pattern 1..3
      drawOneGoldStatue(sx, y, variant);
    }
  }
  function drawOneGoldStatue(x, y, variant){
    const sx = Math.round(x);
    ctx.save();
    ctx.fillStyle='#8a6b2f'; ctx.fillRect(sx-10*CFG.SCALE, y-16*CFG.SCALE, 20*CFG.SCALE, 16*CFG.SCALE);
    ctx.fillStyle='#d4af37';
    const v = variant || 1;
    if (v===1){ ctx.fillRect(sx-3*CFG.SCALE, y-40*CFG.SCALE, 6*CFG.SCALE, 24*CFG.SCALE); ctx.fillRect(sx-12*CFG.SCALE, y-28*CFG.SCALE, 24*CFG.SCALE, 8*CFG.SCALE); }
    else if (v===2){ ctx.fillRect(sx-2*CFG.SCALE, y-42*CFG.SCALE, 4*CFG.SCALE, 26*CFG.SCALE); ctx.fillRect(sx-10*CFG.SCALE, y-34*CFG.SCALE, 20*CFG.SCALE, 6*CFG.SCALE); }
    else { ctx.fillRect(sx-4*CFG.SCALE, y-36*CFG.SCALE, 8*CFG.SCALE, 20*CFG.SCALE); ctx.fillRect(sx-2*CFG.SCALE, y-44*CFG.SCALE, 4*CFG.SCALE, 8*CFG.SCALE); }
    ctx.restore();
  }
  function drawLootStatues(leftX, rightX, y, leftW, rightW){
    if (!OV.shelfLoot || !OV.shelfLoot.length) return;
    // place extra starting from center outward: alternate shelves
    let leftCount = 0, rightCount = 0;
    const base = 3; // already placed per shelf
    for (let i=0;i<OV.shelfLoot.length;i++){
      const placeRight = (i%2===0);
      if (placeRight){
        const spacing = rightW/(base+2+rightCount);
        const sx = Math.round(rightX + spacing*(base+rightCount+1));
        drawOneGoldStatue(sx, y, (OV.shelfLoot[i] && OV.shelfLoot[i].variant) || 1);
        rightCount++;
      } else {
        const spacing = leftW/(base+2+leftCount);
        const sx = Math.round(leftX + spacing*(base+leftCount+1));
        drawOneGoldStatue(sx, y, (OV.shelfLoot[i] && OV.shelfLoot[i].variant) || 1);
        leftCount++;
      }
    }
  }

  // Draws a wall-mounted screen that shows recent Oval Office events (portrait 9:16, centered)
  function drawOvalWallScreen(){
    const TV = { W: 110*CFG.SCALE, H: 196*CFG.SCALE, PAD: 10*CFG.SCALE };
    const tvW = TV.W, tvH = TV.H;
    const cx = W/2, cy = 115*CFG.SCALE + tvH/2 + 150; // move 150px down
    ctx.save();
    // TV frame (no rotation)
    ctx.fillStyle = '#111'; ctx.fillRect(cx - tvW/2 - 6, cy - tvH/2 - 6, tvW+12, tvH+12);
    ctx.fillStyle = '#1e1e1e'; ctx.fillRect(cx - tvW/2, cy - tvH/2, tvW, tvH);

    // Inner drawing area
    const ev = OV.screen && OV.screen.active;
    if (ev && nowMs() < ev.until){
      const pad = TV.PAD;
      const innerW = tvW-2*pad, innerH = tvH-2*pad;
      // background color by event
      let bg = 'rgba(50,50,50,0.9)';
      if (ev.type==='tariff') bg = 'rgba(183,28,28,0.9)';
      if (ev.type==='policy' && ev.bg) bg = ev.bg;
      ctx.fillStyle = bg; ctx.fillRect(cx - tvW/2 + pad, cy - tvH/2 + pad, innerW, innerH);
      ctx.textAlign='center'; ctx.fillStyle='#fff';

      // Title
      ctx.font = `bold ${11*CFG.SCALE}px system-ui`;
      const title = (ev.title || ev.country || 'POLICY').toUpperCase();
      ctx.fillText(title, cx, cy - tvH/2 + pad + 16*CFG.SCALE);

      // Central value + arrow
      if (ev.type==='tariff'){
        const t = Math.min(1, (nowMs()-ev.start)/500); // count-up
        const shown = Math.round(ev.delta * t);
        ctx.font = `bold ${18*CFG.SCALE}px system-ui`;
        ctx.fillText(`+${shown}%`, cx, cy);
        // arrow up: placed under title, above percentage
        ctx.beginPath();
        const ax = cx + innerW/2 - 20*CFG.SCALE, ay = cy - tvH/2 + pad + 36*CFG.SCALE;
        ctx.moveTo(ax, ay); ctx.lineTo(ax+16*CFG.SCALE, ay); ctx.lineTo(ax+8*CFG.SCALE, ay-20*CFG.SCALE); ctx.closePath();
        ctx.fill();
        ctx.font = `${9*CFG.SCALE}px system-ui`;
        ctx.fillText('Tariffs increased', cx, cy + tvH/2 - pad - 12*CFG.SCALE);
      } else if (ev.type==='policy'){
        ctx.font = `bold ${16*CFG.SCALE}px system-ui`;
        ctx.fillText(ev.value || '', cx, cy + 6*CFG.SCALE);
        // optional arrow
        if (ev.dir){
          ctx.beginPath();
          const ax = cx + innerW/2 - 20*CFG.SCALE, ay = cy - tvH/2 + pad + 36*CFG.SCALE;
          if (ev.dir==='up'){ ctx.moveTo(ax, ay); ctx.lineTo(ax+16*CFG.SCALE, ay); ctx.lineTo(ax+8*CFG.SCALE, ay-20*CFG.SCALE); }
          else { ctx.moveTo(ax, ay-16*CFG.SCALE); ctx.lineTo(ax+16*CFG.SCALE, ay-16*CFG.SCALE); ctx.lineTo(ax+8*CFG.SCALE, ay+4*CFG.SCALE); }
          ctx.closePath(); ctx.fill();
        }
        ctx.font = `${9*CFG.SCALE}px system-ui`;
        ctx.fillText(ev.caption || '', cx, cy + tvH/2 - pad - 12*CFG.SCALE);
      }
      ctx.textAlign='left';
    } else {
      // idle message
      ctx.textAlign='center'; ctx.fillStyle='#2a2a2a'; ctx.font = `${12*CFG.SCALE}px system-ui`;
      ctx.fillText('No signal', cx, cy + 4*CFG.SCALE);
      ctx.textAlign='left';
    }
    ctx.restore();
  }

  // Draw desk body (panel/top/legs) and on‚Äëdesk buttons so Trump appears behind it
  function drawOvalDesk(){
    const y = H - world.floor + 30*CFG.SCALE;
    const deskX = 420*CFG.SCALE, deskW = 340*CFG.SCALE;
    // body and top
    ctx.fillStyle='#7a4a22'; ctx.fillRect(deskX, y-40*CFG.SCALE, deskW, 80*CFG.SCALE);
    ctx.fillStyle='#8a5a2a'; ctx.fillRect(deskX-8, y-44*CFG.SCALE, deskW+16, 8*CFG.SCALE);
    // legs
    ctx.fillStyle='#6b3e18';
    ctx.fillRect(deskX+12, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    ctx.fillRect(deskX+deskW-28*CFG.SCALE, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    // drawer seams + handles
    ctx.strokeStyle='#5e3415'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(deskX+deskW*0.33, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.33, y+36*CFG.SCALE);
    ctx.moveTo(deskX+deskW*0.66, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.66, y+36*CFG.SCALE);
    ctx.stroke();
    ctx.fillStyle='#d4af37'; ctx.fillRect(deskX+deskW*0.33-4, y+8*CFG.SCALE, 8, 4); ctx.fillRect(deskX+deskW*0.66-4, y+8*CFG.SCALE, 8, 4);
    // buttons sitting ON the slim top board (y-44..y-36)
    OV.buttons.forEach((b,i)=>{
      const topY = y-44*CFG.SCALE; // top board upper edge
      ctx.save(); ctx.translate(b.x, topY);
      // base (mount) sits inside the 8px top thickness
      const baseH = 4; ctx.fillStyle='#5a4632'; ctx.fillRect(-b.w/2, 0, b.w, baseH);
      
      // cap rises above the top surface - adjust position if pressed
      const pressOffset = b.pressed ? 3 : 0; // Push down when pressed
      const capHeight = b.pressed ? b.h - 2 : b.h; // Slightly shorter when pressed
      ctx.fillStyle = b.pressed ? darkenColor(b.color) : b.color;
      ctx.fillRect(-b.w/2+2, -capHeight-2+pressOffset, b.w-4, capHeight);
      
      // highlight on cap - dimmer when pressed
      ctx.globalAlpha = b.pressed ? 0.1 : 0.25; 
      ctx.fillStyle='#fff'; 
      ctx.fillRect(-b.w/2+4, -capHeight+pressOffset, b.w-8, 2);
      ctx.restore();
    });
  }
  function drawKremlinBackdrop(){
    // walls
    ctx.fillStyle='#f2e6e6'; ctx.fillRect(0,0,W,H);
    // red drapes
    ctx.fillStyle='#b33'; for(let i=0;i<4;i++){ const x=300*CFG.SCALE + i*160*CFG.SCALE; ctx.fillRect(x,80*CFG.SCALE,80*CFG.SCALE,160*CFG.SCALE); }
    // Stalin pictogram in golden frame
    const fx = 160*CFG.SCALE, fy = 90*CFG.SCALE, fw = 90*CFG.SCALE, fh = 70*CFG.SCALE;
    ctx.fillStyle='#c9a641'; ctx.fillRect(fx-6, fy-6, fw+12, fh+12);
    ctx.fillStyle='#f5efe1'; ctx.fillRect(fx, fy, fw, fh);
    ctx.fillStyle='#333'; ctx.fillRect(fx+fw*0.35, fy+fh*0.28, fw*0.3, fh*0.38);
    ctx.fillRect(fx+fw*0.42, fy+fh*0.12, fw*0.16, fh*0.18);
    // carpet
    ctx.fillStyle='#8b0000'; ctx.fillRect(0,H-world.floor,W,world.floor);
    // long black table (main body only - top edge drawn later)
    const y = H - world.floor + 24*CFG.SCALE;
    const tx = 300*CFG.SCALE, tw = (W - 2*300*CFG.SCALE), th = 60*CFG.SCALE;
    ctx.fillStyle='#111'; ctx.fillRect(tx, y-30*CFG.SCALE, tw, th);
    // framed border map if drawn
    if (KR.border && KR.border.length>1){
      const mw=120*CFG.SCALE, mh=80*CFG.SCALE, mx=W - 220*CFG.SCALE, my=100*CFG.SCALE;
      ctx.fillStyle='#c9a641'; ctx.fillRect(mx-6,my-6,mw+12,mh+12);
      ctx.fillStyle='#f5efe1'; ctx.fillRect(mx,my,mw,mh);
      // draw stored polyline
      ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(mx + KR.border[0].x*mw, my + KR.border[0].y*mh);
      for (let i=1;i<KR.border.length;i++) ctx.lineTo(mx + KR.border[i].x*mw, my + KR.border[i].y*mh);
      ctx.stroke(); ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2; ctx.stroke();
    }
  }
  function drawDoor(x,y){
    ctx.save(); ctx.translate(x, y-80*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#ddd'; ctx.fillRect(-14,0,28,80); ctx.fillStyle='#bbb'; ctx.fillRect(10,34,4,8);
    ctx.restore();
  }
  function drawAide(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
    ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawYesGroup(x,y){
    // If a custom sprite is provided for group members, draw three of them
    if (GRAPHICS.imageReady('yes_member')){
      const spacing = 34*CFG.SCALE;
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x - spacing, y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x,             y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x + spacing, y - 22*CFG.SCALE, null, null, true);
      return;
    }
    const men = OV.yes.members || [];
    const spacing = 34*CFG.SCALE;
    const praising = OV.yes.speakingUntil > nowMs();
    for (let i=0;i<3;i++){
      const m = men[i] || { blinkUntil:0, nodPhase:i, isF: i===1 };
      const dx = x + (-spacing + i*spacing);
      // amplify nod a bit so it reads
      const nod = Math.sin(nowMs()/900 + (m.nodPhase||0))*1.0*CFG.SCALE;
      ctx.save(); ctx.translate(dx, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
      const suits = ['#3a3a5a','#2a4a2a','#4a2a2a'];
      // legs
      ctx.fillStyle='#2b2b2b'; ctx.fillRect(-10,34,9,10); ctx.fillRect(2,34,9,10);
      // torso/dress (left woman = pink w/o flag, right woman = red flag dress)
      if (m.isF){
        if (i===0){ ctx.fillStyle='#e91e63'; ctx.fillRect(-10,8,20,26); }
        else { ctx.fillStyle='#c01818'; ctx.fillRect(-10,8,20,26); ctx.fillStyle='#fff'; ctx.fillRect(-2,8,4,26); ctx.fillRect(-10,20,20,4); }
      }
      else { ctx.fillStyle=suits[i%3]; ctx.fillRect(-10,8,20,26); }
      // head
      ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
      // eyes (blink)
      if (!(m.blinkUntil && nowMs() < m.blinkUntil)){
        ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
      } else {
        ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1);
      }
      // hair (long hair for women)
      if (m.isF){
        ctx.fillStyle='#6b4328';
        ctx.fillRect(-9,-5,18,5);            // top
        ctx.fillRect(-10,-2,4,16);           // left strand
        ctx.fillRect(6,-2,4,16);             // right strand
      } else {
        ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
      }
      // arms: raise when praising
      ctx.globalAlpha=0.9; ctx.fillStyle=suits[i%3];
      if (praising){
        // raised arms near head
        ctx.fillRect(-14,0,4,14); // left up
        ctx.fillRect(10,0,4,14);  // right up
      } else {
        // down arms along sides
        ctx.globalAlpha=.2; ctx.fillStyle='#000';
        ctx.fillRect(-14,15,2,10); ctx.fillRect(12,15,2,10);
      }
      ctx.restore();
    }
  }
  function drawTesla(x,y){
    // align wheels to ground y; larger car
    ctx.save(); ctx.translate(x, y-12*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // wheels
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(-20,12,5,0,Math.PI*2); ctx.arc(20,12,5,0,Math.PI*2); ctx.fill();
    // body
    ctx.fillStyle='#c00'; ctx.fillRect(-36,-2,72,18);
    // window strip
    ctx.fillStyle='#222'; ctx.fillRect(-28,-4,56,6);
    // Tesla logo (stylized T)
    ctx.fillStyle='#fff'; ctx.fillRect(-2,0,4,8); ctx.fillRect(-10,-2,20,2);
    ctx.restore();
  }
  function drawButton(x,y,color,label){
    const offset = getInteractionOffset({type:'button', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-10*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#444'; ctx.fillRect(-16,10,32,8);
    ctx.fillStyle=color; ctx.fillRect(-14,4,28,8);
    ctx.fillStyle='#fff'; ctx.font='bold 8px system-ui'; ctx.textAlign='center';
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }

  // praising lines for the yes-choir
  const PRAISE = [
    'Genius move, sir!',
    'Historic leadership!',
    'Best decision ever!',
    'Total victory!',
    'Markets love it!'
  ];
  function praiseChoir(){
    const line = PRAISE[Math.floor(Math.random()*PRAISE.length)];
    OV.yes.say = line; OV.yes.speakingUntil = nowMs()+1200;
  }
  function pickRandomCountry(){
    const arr = ['Canada','Mexico','Germany','France','Denmark','China','India','Brazil','Japan','Australia','Norway','Sweden','Finland','UK','Italy'];
    return arr[Math.floor(Math.random()*arr.length)];
  }
  function drawPutin(x,y){
    const nod = Math.sin(nowMs()/1150 + (KR.putin.nodPhase||0)) * 0.4*CFG.SCALE;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    // Ben
    ctx.fillStyle='#111'; ctx.fillRect(-7,34,5,10); // venstre ben
    ctx.fillStyle='#111'; ctx.fillRect(2,34,5,10);  // h√∏jre ben
    ctx.fillStyle='#e6c9a8'; ctx.fillRect(-8,-2,16,12);
    if (!(KR.putin.blinkUntil && nowMs() < KR.putin.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
    } else { ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1); }
    ctx.fillStyle='#c2a26a'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawGoldStatue(x,y,variant=1){
    ctx.save(); ctx.translate(x, y-30*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // pedestal
    ctx.fillStyle='#8a6b2f'; ctx.fillRect(-10,16,20,6);
    // statue variants
    ctx.fillStyle='#d4af37';
    if (variant===1){ ctx.fillRect(-3,0,6,14); ctx.fillRect(-8,6,16,6); ctx.fillRect(-2,-6,4,6); }
    else if (variant===2){ ctx.fillRect(-2,0,4,14); ctx.fillRect(-10,8,20,4); ctx.fillRect(-2,-4,4,4); }
    else { ctx.fillRect(-4,2,8,12); ctx.fillRect(-2,-2,4,4); }
    ctx.restore();
  }

  function updateSecurityCamera() {
    const now = nowMs();
    const elapsed = (now - KR.camera.sweepStart) / 1000; // seconds
    const sweepDuration = 8; // 8 seconds for full sweep in one direction
    const fullCycle = sweepDuration * 2; // 16 seconds for full back-and-forth cycle
    
    // Calculate which part of cycle we're in
    const cycleProgress = (elapsed % fullCycle) / fullCycle;
    
    let sweepProgress;
    if (cycleProgress < 0.5) {
      // First half: left to right
      sweepProgress = cycleProgress * 2; // 0 to 1
    } else {
      // Second half: right to left  
      sweepProgress = 2 - (cycleProgress * 2); // 1 to 0
    }
    
    // Calculate sweep angle (30¬∞ to 150¬∞)
    KR.camera.angle = Math.PI/6 + (2*Math.PI/3) * sweepProgress;
  }

  function drawSecurityCamera() {
    updateSecurityCamera();
    
    const cam = KR.camera;
    
    // Draw camera body (3x larger)
    ctx.save();
    ctx.translate(cam.x, cam.y);
    
    // Camera housing (3x size)
    ctx.fillStyle = '#333';
    ctx.fillRect(-24*CFG.SCALE, -18*CFG.SCALE, 48*CFG.SCALE, 36*CFG.SCALE);
    
    // Camera lens - fixed at top center of housing (3x size)
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 12*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    
    // Red light when active - fixed position on lens
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 4.5*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    
    // Direction indicator (small line showing where camera points)
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const indicatorLength = 20*CFG.SCALE;
    const endX = Math.cos(cam.angle) * indicatorLength;
    const endY = Math.sin(cam.angle) * indicatorLength;
    ctx.moveTo(0, -18*CFG.SCALE);
    ctx.lineTo(endX, -18*CFG.SCALE + endY);
    ctx.stroke();
    
    ctx.restore();
    
    // Note: Laser cone is now drawn separately after depth sorting to be on top of everything
  }

  function drawLaserCone(x, y, angle) {
    // Calculate laser length to reach the floor
    const floorY = H - world.floor;
    const distanceToFloor = floorY - y;
    const coneLength = distanceToFloor / Math.sin(Math.abs(angle)) * 1.5; // Extended to ensure it reaches floor
    const coneWidth = Math.PI/8; // 22.5 degrees cone width
    
    // Calculate cone points
    const endX = x + Math.cos(angle) * coneLength;
    const endY = y + Math.sin(angle) * coneLength;
    
    const leftAngle = angle - coneWidth/2;
    const rightAngle = angle + coneWidth/2;
    
    const leftX = x + Math.cos(leftAngle) * coneLength;
    const leftY = y + Math.sin(leftAngle) * coneLength;
    const rightX = x + Math.cos(rightAngle) * coneLength;
    const rightY = y + Math.sin(rightAngle) * coneLength;
    
    // Draw laser cone
    ctx.save();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(leftX, leftY);
    ctx.lineTo(rightX, rightY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Center beam
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
  }

  function isStatueUnderSurveillance(statue) {
    const cam = KR.camera;
    const coneWidth = Math.PI/8; // Same as in drawLaserCone
    
    // Use lens position (same as laser cone)
    const lensX = cam.x;
    const lensY = cam.y - 18*CFG.SCALE;
    
    // Calculate angle from lens to statue
    const dx = statue.x - lensX;
    const dy = statue.y - lensY;
    const statueAngle = Math.atan2(dy, dx);
    
    // Normalize angles to 0-2PI range
    const normalizeAngle = (a) => {
      while (a < 0) a += Math.PI * 2;
      while (a >= Math.PI * 2) a -= Math.PI * 2;
      return a;
    };
    
    const camAngle = normalizeAngle(cam.angle);
    const targetAngle = normalizeAngle(statueAngle);
    
    // Calculate angular difference
    let diff = Math.abs(camAngle - targetAngle);
    if (diff > Math.PI) diff = Math.PI * 2 - diff;
    
    // Check if statue is within camera cone
    const isInCone = diff <= coneWidth/2;
    
    // Debug info
    if (CFG.DEBUG) console.log(`Statue surveillance check: angle diff ${(diff * 180/Math.PI).toFixed(1)}¬∞, inCone: ${isInCone}`);
    
    return isInCone;
  }

  function triggerSecurityDiscovery(statue) {
    if (CFG.DEBUG) console.log('üö® SECURITY DISCOVERY TRIGGERED! üö®');
    
    // Set discovery state
    KR.camera.discovered = true;
    
    // Putin reacts immediately
    KR.putin.speakingUntil = nowMs() + 2500;
    KR.putin.say = 'SECURITY ALERT! We have a thief!';
    
    // Trump's panicked response
    say(player, 'This is fake surveillance!', 2000);
    
    // Damage relationship severely
    adjustRelationship('putin', {respect: -15, trust: -20, fear: 5}, 'caught_stealing');
    
    // Spawn guards from door
    spawnSecurityGuards();
    
    // Screen flash effect (handled in render loop)
    KR.camera.flashUntil = nowMs() + 500;
    
    // After a short dramatic pause, trigger game over for Kremlin theft
    setTimeout(() => { try { gameOverCause('kremlin', {delayMs: 0}); } catch(_){} }, 1600);
    // Reset discovery state later (not visible after game over)
    setTimeout(() => {
      KR.camera.discovered = false;
      if (CFG.DEBUG) console.log('Discovery state reset');
    }, 5000);
  }

  function spawnSecurityGuards() {
    // For now, just show Putin's angry reaction and relationship damage
    // Future: could spawn actual guard sprites that walk in
    if (CFG.DEBUG) console.log('üî¥ Guards would spawn here!');
    
    // Additional Putin dialogue
    setTimeout(() => {
      if (KR.putin.speakingUntil < nowMs() + 1000) {
        KR.putin.speakingUntil = nowMs() + 2000;
        KR.putin.say = 'Security has been notified!';
      }
    }, 1500);
  }

  // ---------- Bear AI and Physics ----------
  function updateBearAI(dt, ground) {
    if (!GL.bear || !GL.bear.alive) return;
    
    GL.bear.vx = GL.bear.vx || 0; GL.bear.vy = GL.bear.vy || 0;
    
    // Chasing AI - if angry and on ground, chase Trump! (Only after HP reaches 0)  
    if (GL.bear.angry && GL.bear.chasing && GL.bear.hp <= 0 && GL.bear.y >= ground - 5*CFG.SCALE) {
      updateBearChaseLogic(dt);
    }
    
    updateBearPhysics(dt, ground);
  }
  
  function updateBearChaseLogic(dt) {
    const distToTrump = player.x - GL.bear.x;
    const chaseSpeed = GL.bear.speed * CFG.SCALE * dt;
    
    // Face Trump direction
    GL.bear.facing = distToTrump > 0 ? 1 : -1;
    
    // Move towards Trump
    if (Math.abs(distToTrump) > GAME_CONSTANTS.PHYSICS.BEAR_CHASE_DISTANCE*CFG.SCALE) {
      if (distToTrump > 0) {
        GL.bear.vx += chaseSpeed; // Chase right
      } else {
        GL.bear.vx -= chaseSpeed; // Chase left  
      }
      // Cap chase speed
      const maxSpeed = GL.bear.speed * CFG.SCALE;
      GL.bear.vx = Math.max(-maxSpeed, Math.min(maxSpeed, GL.bear.vx));
    } else {
      // Close enough - try to attack!
      if (Math.random() < GAME_CONSTANTS.PHYSICS.BEAR_ATTACK_CHANCE) {
        executeBearAttack(distToTrump);
      }
    }
  }
  
  function executeBearAttack(distToTrump) {
    say(GL.bear, "CHOMP! ü¶∑", 800);
    spawnBlood(player.x, player.y - 10*CFG.SCALE, 8);
    // Push Trump away
    const pushDir = Math.sign(distToTrump) || 1;
    nudge(player, pushDir * GAME_CONSTANTS.PHYSICS.HORIZONTAL_KNOCKBACK*CFG.SCALE, -20*CFG.SCALE, 200);
    SFX.error();
    
    // Lose some health or game over if caught too many times
    hudToast = "üêª Bear attack!";
    
    // Optional: could end game here if desired; doom mechanic removed
  }
  
  function updateBearPhysics(dt, ground) {
    // Apply physics
    const g = GAME_CONSTANTS.PHYSICS.GRAVITY * dt; // gravity px/s^2 scaled by dt
    GL.bear.vy += g;
    
    // Update position
    GL.bear.y += GL.bear.vy * dt;
    GL.bear.x += GL.bear.vx * dt;
    
    // Horizontal damping (less when chasing)
    const dampingFactor = GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.CHASE_DAMPING : GAME_CONSTANTS.PHYSICS.NORMAL_DAMPING;
    GL.bear.vx *= dampingFactor;
    
    // Ground collision with improved detection
    if (GL.bear.y >= ground) { 
      GL.bear.y = ground; 
      GL.bear.vy = 0;
      // Extra damping when on ground to prevent sliding (less when chasing)
      GL.bear.vx *= GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_CHASE : GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_NORMAL;
    }
    
    // Screen bounds to prevent getting stuck off-screen
    const minX = GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE, 
          maxX = W - GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE;
    if (GL.bear.x < minX) {
      GL.bear.x = minX;
      GL.bear.vx = Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
    if (GL.bear.x > maxX) {
      GL.bear.x = maxX;
      GL.bear.vx = -Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
  }

  // ---------- Actors update ----------
  function updateActors(dt){
    // Bear physics and AI - only in Greenland scene
    if (scene === 'greenland') {
      const ground = H - world.floor;
      updateBearAI(dt, ground);
    } // End greenland scene check
    // clouds (parallax)
    if (CLOUDS && CLOUDS.length){
      CLOUDS.forEach(c=>{ c.x += c.vx*dt; if (c.x > W + c.w) c.x = -c.w; });
    }
    // schedule blinks
    const tnow = nowMs();
    function updBlink(o){
      if (!o) return;
      if (!o.nextBlink || tnow > o.nextBlink){
        o.blinkUntil = tnow + 120;
        // next blink 2‚Äì4.5s later
        o.nextBlink = tnow + 2000 + Math.random()*2500;
      }
    }
    updBlink(player);
    updBlink(GL.mette);
    updBlink(KR.putin);
    // yes-men
    if (OV.yes && OV.yes.members){ OV.yes.members.forEach(m=>{ if (!m.nextBlink || tnow>m.nextBlink){ m.blinkUntil = tnow+120; m.nextBlink = tnow + 2000 + Math.random()*2500; } }); }
  }

  // ---------- FX update/draw ----------
  function updateFx(dt){
    // blood - optimized with object pooling
    const g = 220*CFG.SCALE; // gravity-ish
    const deadBlood = [];
    fx.blood = fx.blood.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadBlood.push(p);
        return false;
      }
      return true;
    });
    deadBlood.forEach(p => returnParticle('blood', p));
    fx.blood.forEach(p => {
      p.vy += g*dt*0.6;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
    });
    
    // sparks - optimized with object pooling
    const gs = 380*CFG.SCALE;
    const deadSparks = [];
    fx.sparks = fx.sparks.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadSparks.push(p);
        return false;
      }
      return true;
    });
    deadSparks.forEach(p => returnParticle('sparks', p));
    fx.sparks.forEach(p => {
      p.vy += gs*dt*0.5;
      p.vx *= 0.98; p.vy *= 0.98;
      p.x += p.vx*dt; p.y += p.vy*dt;
    });

    // confetti
    const deadConf = [];
    fx.confetti = fx.confetti.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) { deadConf.push(p); return false; }
      return true;
    });
    deadConf.forEach(() => {}); // no pooling for confetti
    fx.confetti.forEach(p => {
      p.vy += gs*dt*0.6;
      p.vx *= 0.985; p.vy *= 0.985;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.rot += p.rotSpeed*dt;
    });
    
    // contamination particles
    if (fx.contamination) {
      const deadContamination = [];
      fx.contamination = fx.contamination.filter(p => {
        p.life -= dt*1000;
        if (p.life <= 0) {
          deadContamination.push(p);
          return false;
        }
        return true;
      });
      deadContamination.forEach(p => returnParticle('contamination', p));
      fx.contamination.forEach(p => {
        p.vy += gs*dt*0.3; // Slight gravity
        p.vx *= 0.95; p.vy *= 0.95; // Damping
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.alpha = Math.max(0.1, p.alpha - dt*0.5); // Fade out
      });
    }
    
    // downwash - optimized
    const deadDownwash = [];
    fx.downwash = fx.downwash.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadDownwash.push(p);
        return false;
      }
      return true;
    });
    deadDownwash.forEach(p => returnParticle('downwash', p));
    fx.downwash.forEach(p => {
      p.vy += 260*CFG.SCALE*dt*0.4;
      p.vx *= 0.96; p.vy *= 0.96;
      p.x += p.vx*dt; p.y += p.vy*dt;
    });
    
    // missile flame - optimized
    const deadFlame = [];
    fx.flame = fx.flame.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadFlame.push(p);
        return false;
      }
      return true;
    });
    deadFlame.forEach(p => returnParticle('flame', p));
    fx.flame.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.96; p.vy *= 0.98; });
    
    // oil particles - optimized
    const ground = H - world.floor;
    const deadOil = [];
    fx.oil = fx.oil.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadOil.push(p);
        return false;
      }
      return true;
    });
    deadOil.forEach(p => returnParticle('oil', p));
    fx.oil.forEach(p => {
      if (!p.landed){
        p.vy += 900*CFG.SCALE*dt;
        p.x += p.vx*dt; p.y += p.vy*dt;
        if (p.y >= ground){ p.y = ground; p.vy = 0; p.vx *= 0.5; p.landed = true; p.life += 800; }
      } else {
        p.vx *= 0.9; p.x += p.vx*dt; // small spread
      }
    });
    
    // Update ice chunks from glacier explosion
    if (glacierExplosion.active) {
      glacierExplosion.iceChunks = glacierExplosion.iceChunks.filter(chunk => {
        chunk.life -= dt * 1000;
        if (chunk.life <= 0) return false;
        
        // Physics
        chunk.vy += 1400 * dt * 0.8; // Gravity for ice chunks
        chunk.x += chunk.vx * dt;
        chunk.y += chunk.vy * dt;
        chunk.rotation += chunk.rotSpeed * dt;
        
        // Bounce off ground
        if (chunk.y >= ground) {
          chunk.y = ground;
          chunk.vy *= -0.3; // Bounce with damping
          chunk.vx *= 0.8; // Friction
        }
        
        return true;
      });
    }
  }
  function drawFx(){
    // draw blood as pixel squares
    ctx.save();
    fx.blood.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#b31217';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // sparks
    fx.sparks.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = a>0.5 ? '#ffd54f' : '#ff9800';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // confetti
    fx.confetti.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/1200));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      // draw small rotating square
      ctx.save();
      ctx.translate(p.x + p.size/2, p.y + p.size/2);
      ctx.rotate(p.rot);
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.restore();
    });
    // Draw briefly placed dynamite objects
    if (PLANTED && PLANTED.length){
      const nowt = nowMs();
      PLANTED = PLANTED.filter(p => (nowt - p.start) < p.ttl);
      PLANTED.forEach(p => {
        const fuseOn = Math.floor(nowt/120)%2===0;
        ctx.save();
        ctx.fillStyle='#d32f2f';
        ctx.fillRect(p.x-6*CFG.SCALE, p.y-12*CFG.SCALE, 6*CFG.SCALE, 14*CFG.SCALE);
        ctx.fillRect(p.x+2*CFG.SCALE, p.y-12*CFG.SCALE, 6*CFG.SCALE, 14*CFG.SCALE);
        ctx.fillStyle='#333'; ctx.fillRect(p.x-6*CFG.SCALE, p.y-8*CFG.SCALE, 6*CFG.SCALE, 2*CFG.SCALE);
        ctx.fillRect(p.x+2*CFG.SCALE, p.y-8*CFG.SCALE, 6*CFG.SCALE, 2*CFG.SCALE);
        // fuse spark and particles
        const fxX = p.x + 8*CFG.SCALE, fxY = p.y - 14*CFG.SCALE;
        ctx.fillStyle = fuseOn? '#ffd54f' : '#ff9800';
        ctx.fillRect(fxX, fxY, 2*CFG.SCALE, 2*CFG.SCALE);
        // Emit small sparks periodically while the fuse "burns"
        if (!p.lastSparkAt || (nowt - p.lastSparkAt) > 140){
          spawnSparks(fxX, fxY, 3);
          p.lastSparkAt = nowt;
        }
        // slide-up arrow above placement
        const k = Math.max(0, Math.min(1, (nowt - p.start)/p.ttl));
        const ay = (p.y - 18*CFG.SCALE) - 10*CFG.SCALE*k;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(p.x, ay - 6*CFG.SCALE);
        ctx.lineTo(p.x - 6*CFG.SCALE, ay + 4*CFG.SCALE);
        ctx.lineTo(p.x + 6*CFG.SCALE, ay + 4*CFG.SCALE);
        ctx.closePath(); ctx.fill();
        // 'Planted!' label
        ctx.font = `${10*CFG.SCALE}px system-ui`;
        ctx.fillStyle = `rgba(255,255,255,${(1 - (nowt - p.start)/p.ttl).toFixed(2)})`;
        ctx.textAlign = 'center';
        ctx.fillText('Planted!', p.x, ay - 6*CFG.SCALE);
        ctx.textAlign = 'left';
        ctx.restore();
      });
    }
    // contamination particles
    if (fx.contamination) {
      fx.contamination.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = '#00FF00'; // Bright green
        ctx.fillRect(p.x, p.y, p.size, p.size);
        // Add a slight glow effect
        ctx.globalAlpha = p.alpha * 0.3;
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(p.x-1, p.y-1, p.size+2, p.size+2);
      });
    }
    // downwash
    fx.downwash.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // oil
    fx.oil.forEach(p => {
      const a = Math.max(0.1, Math.min(1, p.life/900));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#111';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // flame
    fx.flame.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    
    // Draw glacier explosion effects
    if (glacierExplosion.active) {
      // Draw explosion effects
      glacierExplosion.explosions.forEach(exp => {
        const elapsed = nowMs() - exp.time;
        if (elapsed < exp.duration) {
          const progress = elapsed / exp.duration;
          const size = progress * 100 * CFG.SCALE;
          const alpha = 1 - progress;
          
          // Try custom explosion sprite
          if (!GRAPHICS.drawOrFallback(ctx, 'explosion', () => {}, exp.x, exp.y)) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Inner white flash
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw ice chunks
      glacierExplosion.iceChunks.forEach(chunk => {
        const alpha = Math.max(0, chunk.life / 3000);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#e8f4f8';
        
        ctx.save();
        ctx.translate(chunk.x, chunk.y);
        ctx.rotate(chunk.rotation);
        ctx.fillRect(-chunk.size/2, -chunk.size/2, chunk.size, chunk.size);
        ctx.restore();
      });
      
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }

  // ---------- Missile overlay ----------
  function drawMissileFallback(x,y){
    ctx.save();
    const s = 4*CFG.SCALE; // 4x bigger
    // body
    ctx.fillStyle='#bbb'; ctx.fillRect(x-10*s, y-40*s, 20*s, 40*s);
    // cone
    ctx.beginPath(); ctx.moveTo(x, y-56*s); ctx.lineTo(x-10*s, y-40*s); ctx.lineTo(x+10*s, y-40*s); ctx.closePath(); ctx.fillStyle='#999'; ctx.fill();
    // fins
    ctx.fillStyle='#777'; ctx.fillRect(x-16*s, y-18*s, 6*s, 12*s);
    ctx.fillRect(x+10*s, y-18*s, 6*s, 12*s);
    // nuclear symbol
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x, y-26*s, 6*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#ffd54f';
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, -Math.PI/6, Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI/2 - Math.PI/6, Math.PI/2 + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI - Math.PI/6, Math.PI + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    // flame
    ctx.fillStyle='#ff9800'; ctx.fillRect(x-6*s, y, 12*s, 12*s);
    ctx.fillStyle='#ffd54f'; ctx.fillRect(x-3*s, y+2*s, 6*s, 6*s);
    ctx.restore();
  }

  function drawMissile(x,y){
    if (GRAPHICS.drawOrFallback(ctx, 'missile', drawMissileFallback, x, y)) return;
    drawMissileFallback(x,y);
  }

  // ---------- Hint tegning ----------
  
  // pulsating hover outline (disabled by default via CFG.SHOW_PULSE)
  function drawPulseFor(o){
    const t = nowMs()/1000;
    const w = Math.max(18, o.w||22) * CFG.SCALE;
    const h = (o.h? Math.max(10, o.h/2): 12) * CFG.SCALE;
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(o.x, o.y-6, w*0.9 + Math.sin(t*3)*2, h*0.5 + Math.sin(t*3)*1, 0, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5 + (Math.sin(t*3)*0.6);
    ctx.stroke();
    ctx.restore();
  }
  // Shape-following interact glow outlines
  function drawGlowOutline(obj){
    const maxR = CFG.INTERACT_DIST*2.2*CFG.SCALE;
    const d = Math.hypot(player.x-obj.x, player.y-obj.y);
    if (d>maxR) return;
    const a = Math.max(0, 1 - d/maxR);
    const color = (obj.type==='bear') ? 'rgba(120,170,255,'+(0.6*a).toFixed(3)+')' : 'rgba(255,255,255,'+(0.55*a).toFixed(3)+')';
    ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    if (obj.type==='bear'){
      const w=60*CFG.SCALE, h=20*CFG.SCALE; const x=obj.x, y=obj.y-12*CFG.SCALE;
      roundedRectPath(x-w/2, y-h/2, w, h, 10*CFG.SCALE);
      ctx.moveTo(x+w*0.35, y-h*0.6); roundedRectPath(x+w*0.35, y-h*0.9, 22*CFG.SCALE, 14*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='rig'){
      const x=obj.x, y=obj.y-60*CFG.SCALE; const base=32*CFG.SCALE;
      ctx.moveTo(x-base, y+70*CFG.SCALE); ctx.lineTo(x, y-8*CFG.SCALE); ctx.lineTo(x+base, y+70*CFG.SCALE); ctx.closePath();
      ctx.moveTo(x-36*CFG.SCALE, y+70*CFG.SCALE); ctx.lineTo(x+36*CFG.SCALE, y+70*CFG.SCALE);
    } else if (obj.type==='mine'){
      ctx.ellipse(obj.x, obj.y, 20*CFG.SCALE, 8*CFG.SCALE, 0, 0, Math.PI*2);
    } else if (obj.type==='heli'){
      const x=obj.x, y=obj.y; ctx.rect(x-40*CFG.SCALE, y-10*CFG.SCALE, 100*CFG.SCALE, 28*CFG.SCALE);
    } else if (obj.type==='mette' || obj.type==='putin' || obj.type==='aide'){
      roundedRectPath(obj.x-12*CFG.SCALE, obj.y-44*CFG.SCALE, 24*CFG.SCALE, 44*CFG.SCALE, 6*CFG.SCALE);
    } else if (obj.type==='door'){
      roundedRectPath(obj.x-14*CFG.SCALE, obj.y-80*CFG.SCALE, 28*CFG.SCALE, 80*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='glacier'){
      const w = obj.w*CFG.SCALE, h = obj.h*CFG.SCALE;
      ctx.beginPath();
      ctx.moveTo(obj.x-w/2, obj.y+h/2);
      ctx.lineTo(obj.x-w/3, obj.y-h/2);
      ctx.lineTo(obj.x, obj.y-h/2-20*CFG.SCALE);
      ctx.lineTo(obj.x+w/3, obj.y-h/2);
      ctx.lineTo(obj.x+w/2, obj.y+h/2);
      ctx.closePath();
    } else if (obj.type==='phone'){
      roundedRectPath(obj.x-8*CFG.SCALE, obj.y-34*CFG.SCALE, 16*CFG.SCALE, 28*CFG.SCALE, 3*CFG.SCALE);
    } else if (obj.type==='statue'){
      roundedRectPath(obj.x-10*CFG.SCALE, obj.y-30*CFG.SCALE, 20*CFG.SCALE, 30*CFG.SCALE, 4*CFG.SCALE);
    } else {
      ctx.restore(); return;
    }
    ctx.stroke(); ctx.restore();
  }
  function roundedRectPath(x,y,w,h,r){
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  }
  // (outline hint removed for now per request)

  // Hint: planting instruction for Greenland when dynamite is selected
  function drawPlantHintGreenland(){
    if (scene!=='greenland') return;
    if (player.selectedItem !== 'dynamite') return;
    const dyn = inventory.find(i=>i.id==='dynamite');
    if (!dyn || (dyn.qty||0)<=0) return;
    // find nearest valid target
    const obj = nearestGL();
    const valid = obj && (obj.type==='mette' || obj.type==='bear' || obj.type==='rig' || obj.type==='glacier');
    if (!valid) return; // show only when near a valid target
    const x = obj.x;
    const y = obj.y;
    const msg = 'Press E to plant dynamite';
    ctx.save();
    ctx.font = `${12*CFG.SCALE}px system-ui`;
    const pad = 8*CFG.SCALE; const tw = ctx.measureText(msg).width; const w = tw + pad*2; const h = 22*CFG.SCALE;
    const bx = Math.max(pad, Math.min(W - w - pad, x - w/2));
    // Raise hint higher to avoid overlapping characters
    const by = y - 100*CFG.SCALE;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 1;
    roundRect(bx, by, w, h, 6*CFG.SCALE); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.fillText(msg, bx + w/2, by + h*0.7);
    ctx.textAlign='left'; ctx.restore();
  }
  function drawPlantHintGeneric(){
    // Currently we only support valid planting targets in Greenland.
    // For other scenes, do not show a generic hint to avoid confusion.
    return;
  }

  // ---------- Error Handling Utilities ----------
  function safeExecute(fn, errorMsg, fallback = null) {
    try {
      return fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`${errorMsg}:`, err);
      }
      return fallback;
    }
  }
  
  function safeDraw(fn, context = 'render') {
    try {
      fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`Drawing error in ${context}:`, err);
      }
      // Drawing errors shouldn't crash the game
    }
  }

  // ---------- Loop ----------
  function step(t){
    try {
      const renderStart = performance.now();
      
      // Performance monitoring
      PERF.frameCount++;
      if (t - PERF.lastFpsUpdate > 1000) { // Update FPS every second
        PERF.fps = Math.round(PERF.frameCount * 1000 / (t - PERF.lastFpsUpdate));
        PERF.frameCount = 0;
        PERF.lastFpsUpdate = t;
      }
      
      deltaTime = Math.min(MAX_DELTA, t - last);
      const dt = Math.min(0.033, deltaTime/1000); 
      last = t;
    
    // Handle intro screen animation
    if (scene === 'intro') {
      const introCanvas = document.getElementById('intro-canvas');
      if (introCanvas && (t - introStartTime) > (GAME_CONSTANTS.ANIMATION && GAME_CONSTANTS.ANIMATION.INTRO_UPDATE_MS || 100)) { // Update frequency
        const ictx = introCanvas.getContext('2d');
        ictx.imageSmoothingEnabled = false; // Ensure pixel art style
        drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
        introStartTime = t;
      }
      requestAnimationFrame(step);
      return;
    }
    // No global countdown timer


    if (scene === 'golf') {
      golfUpdate(dt);
    }

    // bev√¶gelse (ingen i choice-overlay). Stopper ved auto-walk tween
    if (scene !== 'golf' && !choiceOverlay && !infoCard && !flagOverlay && !walkTween && !introRunning && !tug) {
      let dx=0, dy=0;
      if (keys.has('arrowleft')) dx-=1;
      if (keys.has('arrowright')) dx+=1;
      if (keys.has('arrowup')) dy-=1;
      if (keys.has('arrowdown')) dy+=1;
      const len=Math.hypot(dx,dy)||1;
      // Swim damping when head is under water in Greenland
      let submerged = false;
      if (scene==='greenland' && glacierExplosion && glacierExplosion.active && glacierExplosion.waterLevel>0){
        const waterLine = H - glacierExplosion.waterLevel;
        const headY = player.y - 38*CFG.SCALE;
        submerged = headY > waterLine;
      }
      const spd = CFG.SPEED * (player.speedMul||1) * (submerged ? 0.85 : 1);
      const oldX = player.x;
      player.x += (dx/len)*spd*dt*CFG.SCALE;
      player.y += (dy/len)*spd*dt*CFG.SCALE;
      if (dx) player.facing=Math.sign(dx);
      
      // Walking animation logic
      const isMoving = Math.abs(player.x - oldX) > 0.1 || Math.abs(dx) > 0 || Math.abs(dy) > 0;
      if (isMoving) {
        player.walking = true;
        player.walkCycle += dt * 8; // Walking speed (higher = faster steps)
      } else {
        player.walking = false;
        player.walkCycle = 0; // Reset to neutral pose when stopped
      }
      // bounds
      const g = H-world.floor; const minX=40*CFG.SCALE,maxX=W-40*CFG.SCALE;
      player.x=clamp(player.x,minX,maxX); player.y=g;
    }

    // opdater auto-walk tween
    stepWalkTween(t);

    // speed boost timeout + HUD refresh
    if (speedBoostUntil && nowMs() > speedBoostUntil){ speedBoostUntil=0; player.baseSpeedMul = 1; updatePlayerSpeedMul(); }
    renderHUD();

    // opdater hop (jump) tween
    const ground = H - world.floor;
    if (jumpTween){
      const k = Math.min(1, (t - jumpTween.start)/jumpTween.dur);
      const lift = Math.sin(k*Math.PI) * jumpTween.height;
      player.y = ground - lift;
      if (k>=1){ jumpTween=null; if (!entryHeli.active) player.y = ground; }
    } else {
      if (!entryHeli.active) player.y = ground;
    }

    // update actors + fx
    updateActors(dt);
    updateFx(dt);
    
    // Update particle count for monitoring
    PERF.particleCount = fx.blood.length + fx.sparks.length + fx.downwash.length + fx.oil.length + fx.flame.length + fx.confetti.length;

    // ensure player is inside helicopter during entry before drawing
    if (entryHeli.active){
      const ktmp = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * ktmp;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * ktmp;
      }
      player.x = entryHeli.x + 30*CFG.SCALE;
      // keep Trump inside vertically as well (sit in cabin)
      player.y = entryHeli.y + 18*CFG.SCALE;
    }

    // optional camera shake near heli touchdown
    let shakeApplied=false; ctx.save();
    if (entryHeli.active){ const kshake = Math.min(1, (nowMs()-entryHeli.start)/entryHeli.dur); if (kshake>0.8){ const p=(kshake-0.8)/0.2; const amp = 2*CFG.SCALE*p; ctx.translate((Math.random()-0.5)*amp, (Math.random()-0.5)*amp); shakeApplied=true; } }

    // tegning
    if (scene==='greenland'){
      // Background: try custom image first, else fallback gradient + clouds
      const bgDrawn = GRAPHICS.drawBackground(ctx, 'greenland_bg');
      if (!bgDrawn){
        ctx.fillStyle=skyGrad; ctx.fillRect(0,0,W,H);
        CLOUDS.forEach(c=>{ ctx.globalAlpha=c.a; ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w/2, c.h/2, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; });
        ctx.fillStyle='#ebf8ff';
      }
      
      // Interactive glaciers
      GL.glaciers.forEach(glacier => {
        if (!glacier.blown) {
          drawGlacier(glacier.x, glacier.y, glacier.w, glacier.h, glacier.blown);
        }
      });
      const ground=H-world.floor; ctx.fillStyle='#e7fbff'; ctx.fillRect(0,ground,W,world.floor);
      ctx.fillStyle='#cfeef9'; for(let i=0;i<6;i++){ const y=ground+20+i*18*CFG.SCALE; ctx.fillRect(0,y,W,4); }

      // objekter
      drawMine(GL.mine.x, GL.mine.y);
      drawRig(GL.rig.x, GL.rig.y);
      drawShopStall(GL.shop);
      if (GL.flag) drawFlag(GL.flag.x, GL.flag.y);
      drawBear(GL.bear.x, GL.bear.y, GL.bear.alive);
      drawMette(GL.mette.x, GL.mette.y);
      // during entry, draw only Trump here (heli is drawn in overlay)
      if (entryHeli.active){
        drawTrump(player.x, player.y, player.facing);
      } else {
        drawHeli(GL.heli.x, GL.heli.y, 0.35);
        drawTrump(player.x, player.y, player.facing);
      }
      GL.items.forEach(it=>{ if(!it.collected) drawPickup(it); });
      // Draw coins
      GL.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      // blood/sparks/downwash fx
      drawFx();
      
      // Rising water level overlay (drawn on top of everything)
      if (glacierExplosion.active && glacierExplosion.waterLevel > 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#4a90e2'; // Ocean blue
        ctx.fillRect(0, H - glacierExplosion.waterLevel, W, glacierExplosion.waterLevel);
        
        // Water surface waves
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#ffffff';
        const waveY = H - glacierExplosion.waterLevel;
        for (let x = 0; x < W; x += 40) {
          const waveHeight = Math.sin((nowMs() * 0.005) + (x * 0.02)) * 3;
          ctx.fillRect(x, waveY + waveHeight - 2, 30, 4);
        }
        ctx.restore();
      }

      // bobler
      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed) - 60*CFG.SCALE;
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE; // lift to match Mette spacing
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (GL.mette.speakingUntil>n){
        const yOff = placeBubble(GL.mette.say, GL.mette.x, GL.mette.y, true, placed);
        textBubble(GL.mette.say, GL.mette.x, GL.mette.y, true, 'mette', yOff);
      }
      if (GL.bear.speakingUntil>n){
        const yOff = placeBubble(GL.bear.say, GL.bear.x, GL.bear.y, true, placed);
        textBubble(GL.bear.say, GL.bear.x, GL.bear.y, true, 'bear', yOff);
      }

      // interaktionshint
      const near=nearestGL();
      // hover pulse: prefer cursor target if active
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
      // airborne pickup collection: collide with player's head while jumping
      const gnd = H - world.floor;
      if (player.y < gnd - 4*CFG.SCALE){
        const headX = player.x, headY = player.y - 38*CFG.SCALE;
        GL.items.forEach(it=>{
          if (it.collected) return;
          const cx = it.x, cy = it.y - 18*CFG.SCALE;
          const d = Math.hypot(headX - cx, headY - cy);
          if (d < 26*CFG.SCALE){ it.collected=true; addToInventory(it.id, it.name); spawnSparks(cx, cy, 10); }
        });
      }

      // Plant hint when dynamite selected
      drawPlantHintGreenland();
    }
    
    // Global gold bar collection logic for all scenes (when jumping)
    if (scene!=='golf'){
      const gnd = H - world.floor;
      if (player.y < gnd - 4*CFG.SCALE){
        const headX = player.x, headY = player.y - 38*CFG.SCALE;
        const currentCoins = scene==='greenland' ? GL.coins : scene==='oval' ? OV.coins : KR.coins;
        currentCoins.forEach(coin=>{
          if (coin.collected) return;
          const cx = coin.x, cy = coin.y - 20*CFG.SCALE;
          const d = Math.hypot(headX - cx, headY - cy);
          if (d < 20*CFG.SCALE){ 
            coin.collected=true; 
            collectedCoins++; 
            player.goldBalance = (player.goldBalance || 0) + 1;
            spawnSparks(cx, cy, 15);
            checkCoinRewards();
            renderHUD(); // Update HUD to show new coin count
          }
        });
      }
    }
    
    if (scene==='golf') {
      golfDraw();
    } else if (scene==='oval') {
      drawOvalBackdrop();
      drawDoor(OV.door.x, OV.door.y);
      // aide removed from behind the desk for this layout
      drawYesGroup(OV.yes.x, OV.yes.y);
      // draw Trump first so desk can overlay (he stands behind desk)
      if (entryHeli.active){ drawTrump(player.x, player.y, player.facing); }
      else { drawHeli(OV.heli.x, OV.heli.y, 0.35); drawTrump(player.x, player.y, player.facing); }
      // then desk on top, with buttons
      drawOvalDesk();
      // Draw coins
      OV.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      drawFx();

      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed) - 60*CFG.SCALE;
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE;
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (OV.aide.speakingUntil>n){
        const yOff = placeBubble(OV.aide.say, OV.aide.x, OV.aide.y, true, placed);
        textBubble(OV.aide.say, OV.aide.x, OV.aide.y, true, 'aide', yOff);
      }
      if (OV.yes.speakingUntil>n){
        const centerX = OV.yes.x; const baseY = OV.yes.y - 46*CFG.SCALE;
        const yOff = placeBubble(OV.yes.say, centerX, baseY, false, placed) - 8*CFG.SCALE;
        textBubble(OV.yes.say, centerX, baseY, false, 'default', yOff);
      }

      const near=nearestOV();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[OV.door, OV.phone, OV.aide];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
    } else if (scene==='kremlin') {
      drawKremlinBackdrop();
      drawDoor(KR.door.x, KR.door.y);
      drawSecurityCamera(); // Draw camera body first (but not laser - comes later)
      
      // Depth sorting: collect all drawable objects with y-positions
      const drawables = [];
      
      // Add Putin
      drawables.push({y: KR.putin.y, draw: () => drawPutin(KR.putin.x, KR.putin.y)});
      
      // Add Trump with artificially low y-value to force him behind everything
      if (entryHeli.active) {
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      } else {
        drawables.push({y: KR.heli.y, draw: () => drawHeli(KR.heli.x, KR.heli.y, 0.35)});
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      }
      
      // Add statues
      KR.statues.forEach(s => {
        if (!s.collected) {
          drawables.push({y: s.y, draw: () => drawGoldStatue(s.x, s.y, s.variant)});
        }
      });
      
      // Add desk top edge (high y-value to render in front)
      const deskY = H - world.floor + 24*CFG.SCALE;
      const deskX = 300*CFG.SCALE, deskW = (W - 2*300*CFG.SCALE);
      drawables.push({y: deskY, draw: () => {
        const lipHeight = 16*CFG.SCALE;
        const lipTop = deskY - 36*CFG.SCALE;
        ctx.fillStyle = '#1c1c1c';
        ctx.fillRect(deskX-6, lipTop, deskW+12, lipHeight);
        // subtle highlight along edge
        ctx.fillStyle = '#272727';
        ctx.fillRect(deskX-6, lipTop, deskW+12, 3*CFG.SCALE);
        ctx.fillStyle = '#0d0d0d';
        ctx.fillRect(deskX-6, lipTop + lipHeight - 2*CFG.SCALE, deskW+12, 2*CFG.SCALE);
      }});
      
      // Sort by y-position (top to bottom) and draw
      drawables.sort((a, b) => a.y - b.y);
      drawables.forEach(drawable => drawable.draw());
      if (player.selectedItem==='dynamite') drawPlantHintGeneric();
      
      // Draw laser cone AFTER everything else so it's always on top
      const cam = KR.camera;
      const lensX = cam.x;
      const lensY = cam.y - 18*CFG.SCALE;
      drawLaserCone(lensX, lensY, cam.angle);
      
      // Draw coins
      KR.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      
      drawFx();

      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed) - 60*CFG.SCALE;
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE;
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (KR.putin.speakingUntil>n){
        const yOff = placeBubble(KR.putin.say, KR.putin.x, KR.putin.y, true, placed);
        textBubble(KR.putin.say, KR.putin.x, KR.putin.y, true, 'default', yOff);
      }

      const near=nearestKR();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[KR.door, KR.putin];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }

      // Security camera flash effect
      if (KR.camera.flashUntil && nowMs() < KR.camera.flashUntil) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    } else if (scene==='epstein') {
      drawEpsteinScene();
      if (player.selectedItem==='dynamite') drawPlantHintGeneric();
    }

    if (scene!=='epstein') setCanvasCursor('default');

    // restore after scene draw
    if (shakeApplied) { /* keep overlay unaffected */ } ctx.restore();

    // entry helicopter overlay
    if (entryHeli.active){
      const k = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * k;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * k;
      }
      // keep player "inside" helicopter as it arrives
      player.x = entryHeli.x + 30*CFG.SCALE;
      player.y = entryHeli.y + 18*CFG.SCALE;
      drawHeli(entryHeli.x, entryHeli.y, 1.0);
      // rotor downwash while arriving
      if (k>0.6) spawnDownwash(entryHeli.x, entryHeli.y + 12*CFG.SCALE, scene);
      if (k>=1){
        entryHeli.active = false;
        introPlayed = true;
        startWalkTo(player.x + 40*CFG.SCALE, 500, ()=>{ if (entryHeli.line) say(player, entryHeli.line, 1600); });
      }
    }

    // missile overlay (in front of everything)
    if (NUKE.active){
      const k = Math.min(1, (nowMs() - NUKE.start)/NUKE.dur);
      NUKE.y = NUKE.startY + (NUKE.endY - NUKE.startY)*k;
      drawMissile(NUKE.x, NUKE.y);
      if (k>=1){ NUKE.active=false; gameOverCause('nuke', {delayMs: 900}); }
    }

    // tug-of-war overlay
    if (tug){
      const elapsed = nowMs() - tug.start; const k = Math.min(1, elapsed/tug.dur);
      // opponent pull
      tug.pos -= 0.22 * (1/60); // approx per frame pull; mild
      tug.pos = Math.max(-1, Math.min(1, tug.pos));
      // UI
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(W/2-180, H/2-50, 360, 100);
      ctx.fillStyle='#fff'; ctx.font = `bold ${16*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      ctx.fillText('Tug of War! Mash A + D', W/2, H/2-12);
      // center bar from -1..1, green to the right, red left
      const barW = 240, barH=12, cx=W/2, cy=H/2+10;
      ctx.strokeStyle='#fff'; ctx.strokeRect(cx-barW/2, cy, barW, barH);
      const px = (tug.pos+1)/2; // 0..1
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(cx, cy, (barW/2)*Math.max(0, tug.pos), barH);
      ctx.fillStyle = '#e53935';
      ctx.fillRect(cx - (barW/2)*Math.max(0, -tug.pos), cy, (barW/2)*Math.max(0, -tug.pos), barH);
      ctx.textAlign='left';
      if (elapsed >= tug.dur){
        const win = tug.pos > 0.5;
        
        // Dynamic Putin dialogue based on relationships
        const putinRel = RELATIONSHIPS.putin;
        let putinResponse, trumpResponse;
        
        if (win) {
          // Trump wins handshake
          if (putinRel.respect >= 70) {
            putinResponse = 'Impressive strength, my friend.';
            trumpResponse = 'Mutual respect achieved!';
          } else if (putinRel.respect >= 40) {
            putinResponse = 'Strong. I respect that.';
            trumpResponse = 'Dominated the handshake!';
          } else {
            putinResponse = 'Strong.';
            trumpResponse = 'Power move successful!';
          }
          adjustRelationship('putin', {respect: 8, fear: -3}, 'handshake_win');
          addSafe('kremlin', 'putin-handshake-win');
        } else {
          // Putin wins handshake
          if (putinRel.trust <= 20) {
            putinResponse = 'Weakness. Disappointing.';
            trumpResponse = 'Strategic retreat...';
          } else if (putinRel.fear >= 60) {
            putinResponse = 'You seem... nervous, Donald.';
            trumpResponse = 'Recalibrating approach...';
          } else {
            putinResponse = 'Too soft.';
            trumpResponse = 'Next time‚Ä¶';
          }
          adjustRelationship('putin', {respect: -5, trust: -3, fear: 2}, 'handshake_loss');
        }
        
        KR.putin.speakingUntil = nowMs()+1600; 
        KR.putin.say = putinResponse;
        say(player, trumpResponse, 1000);
        tug = null;
        // plant flag based on who won
        if (win) { 
          plantFlag('american'); 
          KR.nobelPending = true; // award Nobel after player exits the map overlay
        } else { 
          plantFlag('russian'); 
        }
      }
    }

    // Nobel medal drop overlay (after returning from map)
    if (nobelDrop && nobelDrop.active){
      const chestX = player.x;
      const chestY = player.y - 24*CFG.SCALE; // approx medal center
      // physics
      // Even slower falling speed (about 1/8 of original)
      nobelDrop.vy += 300*dt*CFG.SCALE;
      nobelDrop.y += nobelDrop.vy*dt;
      // ribbon swing update (simple damped oscillation)
      nobelDrop.swingPhase += dt*4; // slower swing frequency to match slower fall
      nobelDrop.swingAmp *= 0.992; // damping
      const angle = Math.sin(nobelDrop.swingPhase) * nobelDrop.swingAmp; // radians
      if (nobelDrop.y >= chestY){
        nobelDrop.y = chestY;
        nobelDrop.active = false;
        GS.nobelAwarded = true;
        GS.achievements.nobelLaureate = true;
        spawnConfetti(chestX, chestY, 60);
        SFX.achievement();
        // Play voiceline 1s after landing
        setTimeout(() => { try { say(player, 'Thanks for the Nobel Prize ‚Äî finally!', 2200); } catch(_){} }, 1000);
      }
      // draw falling medal
      ctx.save();
      ctx.fillStyle = '#d4af37';
      ctx.beginPath(); ctx.arc(chestX, nobelDrop.y, 6*CFG.SCALE, 0, Math.PI*2); ctx.fill();
      // ribbon dangling (rotated rectangle anchored above medal)
      ctx.translate(chestX, nobelDrop.y - 6*CFG.SCALE);
      ctx.rotate(angle);
      ctx.fillStyle = '#1e88e5';
      const rw = 4*CFG.SCALE, rh = 18*CFG.SCALE;
      ctx.fillRect(-rw/2, -rh, rw, rh);
      ctx.restore();
    }

    // border draw overlay
    if (borderDraw){
      const card = getBorderCardRect();
      // dim
      ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
      // card background (image if available)
      if (MAP_IMG_READY){
        ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
      } else {
        ctx.fillStyle='#f7f5ee'; ctx.fillRect(card.x, card.y, card.w, card.h);
      }
      ctx.strokeStyle='#c9a641'; ctx.lineWidth=4; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
      // Enhanced world map with recognizable regions
      if (!MAP_IMG_READY){
        ctx.save(); ctx.translate(card.x, card.y);
        drawEnhancedWorldMap(ctx, card.w, card.h);
        ctx.restore();
      }

      // auto-generate border if putin mode and not generated
      if (borderDraw.mode==='putin' && !borderDraw.gen){
        const pts=[]; const steps=12; for (let i=0;i<=steps;i++){ const t=i/steps; const x=card.x + card.w*(0.35+0.45*t); const y=card.y + card.h*(0.40+0.05*Math.sin(t*Math.PI)); pts.push({x,y}); }
        borderDraw.points = pts; borderDraw.gen = true;
      }
      // draw user path with enhanced visual feedback
      if (borderDraw.points.length){
        // Main border line
        const borderColor = borderDraw.mode === 'trump' ? '#ff6b35' : '#d63031';
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 5; 
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath(); 
        ctx.moveTo(borderDraw.points[0].x, borderDraw.points[0].y); 
        for (let i=1;i<borderDraw.points.length;i++){ 
          ctx.lineTo(borderDraw.points[i].x, borderDraw.points[i].y); 
        } 
        ctx.stroke();
        
        // Add glow effect
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 8; 
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Mark start and end points
        if (borderDraw.points.length > 0) {
          const start = borderDraw.points[0];
          const end = borderDraw.points[borderDraw.points.length - 1];
          
          // Start marker (green)
          ctx.fillStyle = '#00b894';
          ctx.beginPath();
          ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // End marker (red)
          if (borderDraw.points.length > 1) {
            ctx.fillStyle = '#e84393';
            ctx.beginPath();
            ctx.arc(end.x, end.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Preview line to current mouse position (if drawing mode)
          if (borderDraw.mode === 'trump' && mouse.active && !isDrawing && drawingSettings.showPreview) {
            const card = getBorderCardRect();
            if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
              ctx.strokeStyle = '#ff6b35';
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.5;
              ctx.setLineDash([8, 8]);
              ctx.beginPath();
              ctx.moveTo(end.x, end.y);
              ctx.lineTo(mouse.x, mouse.y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.globalAlpha = 1;
            }
          }
        }
        
        // Drawing cursor and tools
        if (borderDraw.mode === 'trump' && mouse.active) {
          const card = getBorderCardRect();
          if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
            // Crosshair cursor
            ctx.strokeStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(mouse.x - 10, mouse.y);
            ctx.lineTo(mouse.x + 10, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 10);
            ctx.lineTo(mouse.x, mouse.y + 10);
            ctx.stroke();
            
            // Center dot
            ctx.fillStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
      }
      // Enhanced instructions and live analysis
      ctx.fillStyle='#333'; ctx.font=`bold ${14*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      
      // Enhanced Instructions
      let msg;
      if (borderDraw.mode==='trump') {
        if (borderDraw.points.length === 0) {
          msg = 'üñäÔ∏è Click and drag to draw border ¬∑ Hold mouse button and draw smoothly';
        } else {
          msg = `üñäÔ∏è Drawing (${borderDraw.points.length} points) ¬∑ Enter: Confirm ¬∑ Backspace: Undo ¬∑ C: Clear ¬∑ U: Smooth ¬∑ Esc: Cancel`;
        }
      } else {
        msg = 'ü§ñ Putin\'s Proposed Border';
      }
      
      ctx.fillText(msg, W/2, card.y + card.h + 28);
      
      // Live border analysis and drawing stats
      if (borderDraw.mode === 'trump') {
        ctx.font = `${12*CFG.SCALE}px system-ui`;
        ctx.fillStyle='rgba(0,0,0,.8)';
        const statBoxHeight = borderDraw.points.length > 3 ? 80 : 40;
        ctx.fillRect(card.x + 10, card.y + 10, 200, statBoxHeight);
        ctx.fillStyle='#fff';
        ctx.textAlign='left';
        
        // Drawing progress
        ctx.fillText(`üñäÔ∏è Points: ${borderDraw.points.length}`, card.x + 20, card.y + 28);
        
        if (isDrawing) {
          ctx.fillStyle='#ff3333';
          ctx.fillText(`‚úèÔ∏è Drawing...`, card.x + 120, card.y + 28);
        }
        
        // Border analysis (if enough points)
        if (borderDraw.points.length > 3) {
          const analysis = analyzeBorderLive(borderDraw.points, card);
          ctx.fillStyle='#fff';
          ctx.fillText(`üìè Length: ${analysis.lengthDesc}`, card.x + 20, card.y + 45);
          ctx.fillText(`üéØ Strategy: ${analysis.strategyDesc}`, card.x + 20, card.y + 62);
          ctx.fillText(`‚ö° Aggression: ${analysis.aggressionDesc}`, card.x + 20, card.y + 79);
        }
      }
      ctx.textAlign='left';
      
      // Relationship display (top right corner)
      if (scene === 'greenland' || scene === 'kremlin') {
        ctx.font = `${11*CFG.SCALE}px system-ui`;
        ctx.fillStyle = 'rgba(0,0,0,.8)';
        ctx.fillRect(W - 200, 10, 190, 80);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText('üë• RELATIONSHIPS', W - 195, 28);
        
        // Mette relationship
        if (scene === 'greenland') {
          const metteEmoji = getRelationshipEmoji('mette');
          const metteRel = RELATIONSHIPS.mette;
          ctx.fillText(`${metteEmoji} Mette: R${metteRel.respect} T${metteRel.trust} F${metteRel.fear}`, W - 195, 48);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 40, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 40, barWidth, 8);
        }
        
        // Putin relationship  
        if (scene === 'kremlin') {
          const putinEmoji = getRelationshipEmoji('putin');
          const putinRel = RELATIONSHIPS.putin;
          ctx.fillStyle = '#fff';
          ctx.fillText(`${putinEmoji} Putin: R${putinRel.respect} T${putinRel.trust} F${putinRel.fear}`, W - 195, 68);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 60, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 60, barWidth, 8);
        }
      }
    }

    // choice overlay
    if (choiceOverlay){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);
      const lines = choiceOverlay.text.split('\n');
      ctx.fillStyle='#fff'; ctx.font=`bold ${18*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      lines.forEach((ln,i)=>ctx.fillText(ln, W/2, H/2 + (i-1)*24*CFG.SCALE));
      ctx.textAlign='left';
    }

    // info card overlay
    if (infoCard){
      drawInfoCard();
    }

    // flag overlay
    if (flagOverlay){
      drawFlagOverlay();
    }

    // HUD toast
    if (hudToast){ ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(W-260, 44, 240, 26); ctx.fillStyle='#fff'; ctx.font=`12px system-ui`; ctx.fillText(hudToast, W-248, 62); ctx.restore(); hudToast=null; }

    // game over overlay
      if (GS.over){ 
      // Continue overlay (after game over)
      if (GS.overMode === 'continue'){
        // Background
        ctx.fillStyle = '#efe8d2';
        ctx.fillRect(0,0,W,H);
        ctx.textAlign='center';
        
        // Title
        ctx.fillStyle='#141414';
        ctx.font=`800 ${28*CFG.SCALE}px system-ui`;
        ctx.fillText('Continue?', W/2, H*0.18);
        ctx.font=`${14*CFG.SCALE}px system-ui`;
        ctx.fillStyle='#2a2a2a';
        ctx.fillText('Make America Continue Again', W/2, H*0.18 + 22*CFG.SCALE);

        // Voting machine box on pedestal
        const boxW = Math.min(W*0.66, 580*CFG.SCALE);
        const boxH = Math.min(H*0.46, 280*CFG.SCALE);
        const bx = (W - boxW)/2, by = H*0.28;
        // Pedestal column
        const stemW = Math.max(18*CFG.SCALE, boxW*0.04);
        const stemH = 120*CFG.SCALE;
        const stemX = W/2 - stemW/2;
        const stemY = by + boxH + 6*CFG.SCALE;
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(stemX, stemY, stemW, stemH);
        // Base
        const baseW = boxW*0.5, baseH = 18*CFG.SCALE;
        const baseY = stemY + stemH;
        ctx.fillStyle = '#1b1b1b';
        ctx.fillRect(W/2 - baseW/2, baseY, baseW, baseH);
        // Feet
        ctx.fillStyle = '#111';
        ctx.fillRect(W/2 - baseW/2 - 24*CFG.SCALE, baseY + baseH - 6*CFG.SCALE, 24*CFG.SCALE, 6*CFG.SCALE);
        ctx.fillRect(W/2 + baseW/2, baseY + baseH - 6*CFG.SCALE, 24*CFG.SCALE, 6*CFG.SCALE);

        // Outer case
        ctx.fillStyle = '#222';
        ctx.fillRect(bx, by, boxW, boxH);
        // Inner bezel
        ctx.fillStyle = '#333';
        ctx.fillRect(bx+8*CFG.SCALE, by+8*CFG.SCALE, boxW-16*CFG.SCALE, boxH-16*CFG.SCALE);
        // Screen area
        const pad = 18*CFG.SCALE;
        const sx = bx + pad, sy = by + pad, sw = boxW - pad*2, sh = boxH - pad*2 - 56*CFG.SCALE;
        ctx.fillStyle = '#0b0d2b';
        ctx.fillRect(sx, sy, sw, sh);
        // Slot window for text
        const winH = 40*CFG.SCALE;
        const winY = sy + sh*0.36 - winH/2;
        ctx.fillStyle = '#111a39';
        ctx.fillRect(sx + sw*0.12, winY, sw*0.76, winH);
        ctx.strokeStyle = '#6ad3ff';
        ctx.lineWidth = 3;
        ctx.strokeRect(sx + sw*0.12, winY, sw*0.76, winH);

        // Update slot state
        if (continueOverlay){
          const nowt = nowMs();
          if (continueOverlay.phase === 'spinning'){
            // Advance steps with deceleration
            while(!continueOverlay.stopped && nowt >= continueOverlay.nextAt){
              continueOverlay.idx = (continueOverlay.idx + 1) % continueOverlay.words.length;
              continueOverlay.stepsLeft = Math.max(0, continueOverlay.stepsLeft - 1);
              continueOverlay.interval += continueOverlay.inc;
              continueOverlay.nextAt += continueOverlay.interval;
              if (continueOverlay.stepsLeft <= 1){
                // Land on TRUMP and stop
                const stopIdx = continueOverlay.words.indexOf(continueOverlay.stopAt);
                continueOverlay.idx = stopIdx >= 0 ? stopIdx : continueOverlay.idx;
                continueOverlay.stopped = true;
                continueOverlay.stopAtTime = nowt;
                continueOverlay.phase = 'done';
                if (!continueOverlay.grantDone){ GS.lives = (GS.lives|0) + 1; continueOverlay.grantDone = true; renderHUD(); }
              }
            }
          }
          const N = continueOverlay.words.length;
          const idx = continueOverlay.idx;
          const prev = continueOverlay.words[(idx-1+N)%N];
          const cur = continueOverlay.words[idx];
          const next = continueOverlay.words[(idx+1)%N];
          // Local progress 0..1 within current step (for slide effect)
          const lastStepAt = continueOverlay.nextAt - continueOverlay.interval;
          let p = 0;
          if (continueOverlay.phase === 'spinning'){
            p = Math.max(0, Math.min(1, (nowt - lastStepAt)/Math.max(1, continueOverlay.interval)));
          } else {
            p = 1; // settle (idle or done)
          }
          const lineH = 28*CFG.SCALE;
          const centerY = winY + winH/2;
          const offset = (1-p) * lineH; // slide upward
          ctx.save();
          // Clip to window
          ctx.beginPath(); ctx.rect(sx + sw*0.12, winY, sw*0.76, winH); ctx.clip();
          ctx.fillStyle='#a5c4ff';
          ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
          ctx.fillText(prev, W/2, centerY - lineH + offset);
          ctx.fillStyle='#ffffff';
          ctx.fillText(cur,  W/2, centerY + offset);
          ctx.fillStyle='#a5c4ff';
          ctx.fillText(next, W/2, centerY + lineH + offset);
          ctx.restore();
          // +1 LIFE popup when done
          if (continueOverlay.phase === 'done'){
            ctx.fillStyle = '#2a2a2a';
            ctx.font = `bold ${16*CFG.SCALE}px system-ui`;
            ctx.fillText('+1 LIFE', W/2, sy + sh + 18*CFG.SCALE);
          }
        }

        // Confirm button row
        const btnY = by + boxH - 40*CFG.SCALE;
        // Left dim button (Democrat)
        const bw = 120*CFG.SCALE, bh = 26*CFG.SCALE;
        const gap = 18*CFG.SCALE;
        const bx1 = bx + boxW/2 - bw - gap/2, bx2 = bx + boxW/2 + gap/2;
        ctx.fillStyle = '#555'; ctx.fillRect(bx1, btnY, bw, bh);
        ctx.fillStyle = '#222'; ctx.font=`bold ${12*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText('DEMOCRAT', bx1 + bw/2, btnY + 17*CFG.SCALE);
        // Right bright TRUMP button
        ctx.fillStyle = '#e6a300'; ctx.fillRect(bx2, btnY, bw, bh);
        ctx.fillStyle = '#211a00'; ctx.fillText('TRUMP', bx2 + bw/2, btnY + 17*CFG.SCALE);

        // Prompt
        ctx.textAlign='center';
        ctx.fillStyle='#1f1f1f'; ctx.font=`${14*CFG.SCALE}px system-ui`;
        const prompt = (continueOverlay && continueOverlay.phase !== 'done') ? 'Press Enter or T to vote' : 'Press Enter or T to continue';
        ctx.fillText(prompt, W/2, by + boxH + 36*CFG.SCALE);
        ctx.textAlign='left';
      } else if (GS.overMode === 'epstein_success'){
        // Custom Epstein success card overlay (like Kremlin map card)
        const card = getBorderCardRect();
        // Dim background outside card area only
        ctx.fillStyle='rgba(0,0,0,.6)';
        ctx.fillRect(0,0,W,H);
        // Clear card area
        ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
        // Card background + frame borders
        ctx.fillStyle='#f7f5ee';
        ctx.fillRect(card.x, card.y, card.w, card.h);
        ctx.strokeStyle='#c9a641'; ctx.lineWidth=6; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
        ctx.strokeStyle='#8b7355'; ctx.lineWidth=2; ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);

        // Inner content: title, plane, characters, prompt
        ctx.textAlign='center';
        ctx.fillStyle='#111';
        ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
        ctx.fillText('Selvf√∏lgelig er jeg ikke n√¶vnt ‚Äî never met the guy', card.x + card.w/2, card.y + 36*CFG.SCALE);

        // Plane centered in upper/middle area
        drawVirginPlane(card.x + card.w/2, card.y + card.h/2 - 20*CFG.SCALE, 1.0);
        // Characters near bottom center inside card
        const baseY = card.y + card.h - 40*CFG.SCALE;
        drawEpsteinSunglasses(card.x + card.w/2 - 20*CFG.SCALE, baseY);
        drawTrumpSmile(card.x + card.w/2 + 20*CFG.SCALE, baseY);

        // Prompt inside card bottom
        ctx.fillStyle='#333';
        ctx.font = `${14*CFG.SCALE}px system-ui`;
        ctx.fillText('Press Enter to continue', card.x + card.w/2, card.y + card.h - 12*CFG.SCALE);
        ctx.textAlign='left';
      } else if (GS.overMode === 'epstein_fail'){
        // Newspaper-style fail card
        const card = getBorderCardRect();
        ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
        ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
        // Card
        ctx.fillStyle='#f7f5ee'; ctx.fillRect(card.x, card.y, card.w, card.h);
        ctx.strokeStyle='#c9a641'; ctx.lineWidth=6; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
        ctx.strokeStyle='#8b7355'; ctx.lineWidth=2; ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);

        // Rotated newspaper content (clip to card so paper can bleed beyond edges)
        const cx = card.x + card.w/2, cy = card.y + card.h/2;
        ctx.save();
        ctx.save(); ctx.beginPath(); ctx.rect(card.x, card.y, card.w, card.h); ctx.clip();
        ctx.translate(cx, cy); ctx.rotate(10*Math.PI/180);
        // Paper wider inside card, and much taller so it extends beyond the bottom edge.
        const baseH = card.h*0.75; // original visible height to anchor top
        const paperW = card.w*0.9;
        const paperH = card.h*1.6; // extend downward
        const iyTop = -baseH/2; // keep top where it used to be
        const ix = -paperW/2, iy = iyTop;
        ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 2;
        ctx.fillRect(ix, iy, paperW, paperH);
        ctx.strokeRect(ix, iy, paperW, paperH);

        // Content margins inside paper
        const padX = 22*CFG.SCALE, padY = 18*CFG.SCALE;
        // masthead + date
        ctx.fillStyle='#111'; ctx.font=`bold ${18*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText('The Daily Tremendous', 0, iy + padY + 8*CFG.SCALE);
        ctx.font=`${10*CFG.SCALE}px system-ui`; ctx.fillStyle='#555';
        ctx.fillText('Today ‚Ä¢ Washington D.C.', 0, iy + padY + 22*CFG.SCALE);
        // headline
        ctx.fillStyle='#b71c1c'; ctx.font=`bold ${20*CFG.SCALE}px system-ui`;
        ctx.fillText('BREAKING: DONALD NAMED. MULTIPLE TIMES.', 0, iy + padY + 46*CFG.SCALE);
        // photo box
        const px = ix + padX, py = iy + padY + 64*CFG.SCALE, pw = paperW - padX*2, ph = 80*CFG.SCALE;
        ctx.fillStyle='#d9d9d9'; ctx.fillRect(px, py, pw, ph);
        ctx.strokeStyle='#aaa'; ctx.lineWidth=3; ctx.strokeRect(px, py, pw, ph);
        // black-and-white figures inside photo (side-by-side)
        drawTrumpBW(px + pw*0.35, py + ph);
        drawEpsteinBWSunglasses(px + pw*0.65, py + ph);
        // subhead: only Trump quote
        ctx.fillStyle='#333'; ctx.font=`italic ${12*CFG.SCALE}px system-ui`;
        ctx.fillText('\"Witch hunt. Very unfair newspaper.\"', 0, py + ph + 22*CFG.SCALE);
        // article lines
        ctx.fillStyle='#bbb'; let ly = py + ph + 36*CFG.SCALE;
        for (let i=0;i<7;i++){ const lw = pw - (i%2?30:0); ctx.fillRect(px, ly + i*10*CFG.SCALE, lw, 6*CFG.SCALE); }
        // prompt
        ctx.fillStyle='#333'; ctx.font=`${13*CFG.SCALE}px system-ui`;
        ctx.fillText('Press Enter to continue', 0, iy + paperH - 12*CFG.SCALE);
        ctx.restore();
        ctx.restore();
        ctx.textAlign='left';
      } else if (GS.overMode && String(GS.overMode).startsWith('go_')){
        // Generic Game Over with cause-specific art
        ctx.fillStyle='#efe8d2'; ctx.fillRect(0,0,W,H);
        ctx.textAlign='center';
        // Title and subtitle (allow overrides via GO or asset-pack options)
        const opt = (GRAPHICS && GRAPHICS.config) || {};
        const tKey = 'gameover_title_' + (GO.cause||'generic');
        const sKey = 'gameover_subtitle_' + (GO.cause||'generic');
        const title = GO.title || opt[tKey] || opt.gameover_title || 'Game Over';
        const subtitle = GO.subtitle || opt[sKey] || opt.gameover_subtitle || 'Bedre held n√¶ste gang';
        ctx.fillStyle='#141414';
        ctx.font=`800 ${28*CFG.SCALE}px system-ui`;
        ctx.fillText(title, W/2, H*0.18);
        ctx.font=`${16*CFG.SCALE}px system-ui`;
        ctx.fillStyle='#2a2a2a';
        ctx.fillText(subtitle, W/2, H*0.22 + 14*CFG.SCALE);

        // Art area
        const boxW = Math.min(W*0.7, 720*CFG.SCALE);
        const boxH = Math.min(H*0.55, 360*CFG.SCALE);
        const bx = (W - boxW)/2, by = H*0.28;
        // Try to draw custom art from asset pack: gameover_<cause>
        const artKey = 'gameover_' + (GO.cause||'generic');
        const cfg = GRAPHICS && GRAPHICS.config;
        const url = cfg && (cfg[artKey] || cfg.gameover_default || cfg.gameover);
        let drawn=false;
        if (url){
          const img = GRAPHICS.images.get(artKey);
          if (img && img.complete){
            // contain fit (use global gameover_fit if provided)
            const iw = img.naturalWidth||img.width||1, ih=img.naturalHeight||img.height||1;
            const fit = (cfg && (cfg.gameover_fit)) || 'contain';
            const s = fit==='cover' ? Math.max(boxW/iw, boxH/ih) : Math.min(boxW/iw, boxH/ih);
            const dw = iw*s, dh = ih*s; const dx = bx+(boxW-dw)/2, dy=by+(boxH-dh)/2;
            try { ctx.imageSmoothingEnabled=false; } catch(_){ }
            ctx.drawImage(img, dx, dy, dw, dh);
            drawn=true;
          } else { GRAPHICS.loadImage(artKey, url); }
        }
        if (!drawn){
          // Simple pixel fallback by cause
          ctx.save(); try{ctx.imageSmoothingEnabled=false;}catch(_){ }
          if (GO.cause==='ice'){
            ctx.fillStyle='#cfe9ff'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='#80c0ff'; ctx.fillRect(bx, by+boxH*0.7, boxW, boxH*0.3);
          } else if (GO.cause==='nuke'){
            ctx.fillStyle='#000'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='#0a0a2a'; ctx.fillRect(bx,by,boxW,boxH*0.6);
            ctx.fillStyle='#3cf'; ctx.beginPath(); ctx.arc(bx+boxW*0.6, by+boxH*0.45, boxH*0.18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#ffb300'; ctx.beginPath(); ctx.arc(bx+boxW*0.6, by+boxH*0.45, boxH*0.12, 0, Math.PI*2); ctx.fill();
          } else if (GO.cause==='kremlin'){
            ctx.fillStyle='#1a1a1a'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='rgba(255,0,0,0.25)'; ctx.fillRect(bx+boxW*0.1, by+boxH*0.1, boxW*0.8, boxH*0.8);
          } else if (GO.cause==='epstein'){
            ctx.fillStyle='#f7f5ee'; ctx.fillRect(bx,by,boxW,boxH); ctx.strokeStyle='#8b7355'; ctx.strokeRect(bx+8,by+8,boxW-16,boxH-16);
          } else {
            ctx.fillStyle='#ddd'; ctx.fillRect(bx,by,boxW,boxH);
          }
          ctx.restore();
        }

        // Continue prompt
        ctx.fillStyle='#1f1f1f'; ctx.font=`${14*CFG.SCALE}px system-ui`;
        ctx.fillText('Tryk for at forts√¶tte', W/2, by + boxH + 36*CFG.SCALE);
        ctx.textAlign='left';
      } else {
        ctx.fillStyle='rgba(0,0,0,.8)'; 
        ctx.fillRect(0,0,W,H); 
        ctx.fillStyle='#fff'; 
        ctx.textAlign='center'; 
        
        // Main ending text
        ctx.font=`bold ${24*CFG.SCALE}px system-ui`; 
        const lines = GS.overText.split('\n');
        lines.forEach((line, i) => {
          ctx.fillText(line, W/2, H/2 - 60*CFG.SCALE + i*28*CFG.SCALE);
        });
        
        // Show achievements earned
        const earnedAchievements = Object.entries(GS.achievements).filter(([key, earned]) => earned);
        if (earnedAchievements.length > 0) {
          ctx.font=`bold ${16*CFG.SCALE}px system-ui`;
          ctx.fillText('üèÜ ACHIEVEMENTS UNLOCKED:', W/2, H/2 + 50*CFG.SCALE);
          
          ctx.font=`${12*CFG.SCALE}px system-ui`;
          const achievementNames = {
            perfectDiplomat: 'ü§ù Perfect Diplomat',
            collector: 'üóÉÔ∏è Master Collector',
            twitterAddict: 'üì± Twitter Master',
            bearWhisperer: 'üêª Bear Whisperer',
            nobelLaureate: 'üèÖ Nobel Peace Prize'
          };
          
          earnedAchievements.forEach(([key], i) => {
            ctx.fillText(achievementNames[key], W/2, H/2 + 75*CFG.SCALE + i*18*CFG.SCALE);
          });
        }
        
        ctx.font=`${14*CFG.SCALE}px system-ui`; 
        const restartY = (Object.values(GS.achievements).filter(Boolean).length > 0) ? H/2 + 140*CFG.SCALE : H/2 + 80*CFG.SCALE;
        ctx.fillText('Tryk for at forts√¶tte', W/2, restartY); 
        ctx.textAlign='left'; 
      }
    }
    
    // Debug and performance info
    if (CFG.SHOW_FPS || CFG.DEBUG) {
      ctx.save();
      const panelH = CFG.DEBUG ? 120 : 40;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(10, 10, 200, panelH);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText(`FPS: ${PERF.fps}`, 15, 28);
      if (CFG.DEBUG) {
        ctx.fillText(`Particles: ${PERF.particleCount}`, 15, 45);
        ctx.fillText(`Delta: ${deltaTime.toFixed(1)}ms`, 15, 62);
        ctx.fillText(`Render: ${PERF.renderTime.toFixed(1)}ms`, 15, 79);
        // Debug: final art source, fit, and rect size
        try {
          const fit = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art_fit) || 'cover';
          const src = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art) ? 'PNG' : ((window.LOTTIE_ART && LOTTIE_ART.json) ? 'Lottie' : 'Vector');
          const r = (typeof EP!=='undefined' && EP && EP.finalArtRect) ? EP.finalArtRect : null;
          const sz = r ? `${Math.round(r.w)}x${Math.round(r.h)}` : 'n/a';
          ctx.fillText(`FinalArt: ${src} | fit=${fit} | box=${sz}`, 15, 96);
        } catch(_){}
      }
      ctx.restore();
    }
    
      // Record render time
      PERF.renderTime = performance.now() - renderStart;

      requestAnimationFrame(step);
    } catch(err) {
      console.error('Game loop error:', err);
      // Try to continue running after a short delay
      setTimeout(() => requestAnimationFrame(step), 100);
    }
  }
  
  // Start the game loop with error handling
  try {
    requestAnimationFrame(step);
  } catch(err) {
    console.error('Failed to start game loop:', err);
  }
})();

/*
GRAPHICS SYSTEM USAGE EXAMPLES:

// Show all recommended dimensions
showAllDimensions();

// Get specific dimensions
getGraphicDimensions('trump');  // Shows: trump: 24x44px - Trump character sprite

// Set individual graphics
setGraphic('trump', 'https://your-server.com/trump.png');
setGraphic('helicopter', 'https://your-server.com/heli.png');
setGraphic('greenland_bg', 'https://your-server.com/greenland.jpg');

// Set multiple graphics at once
setGraphics({
  trump: 'https://your-server.com/trump.png',
  mette: 'https://your-server.com/mette.png',
  putin: 'https://your-server.com/putin.png',
  helicopter: 'https://your-server.com/helicopter.png',
  greenland_bg: 'https://your-server.com/greenland-bg.jpg'
});

// List all available graphics to customize
listGraphics();

// Clear image cache (useful when updating graphics)
GRAPHICS.clearCache();

RECOMMENDED DIMENSIONS SUMMARY:
Characters: 24x44px (Trump, Mette, Putin, Aide)
Bear: 60x30px
Helicopter: 140x40px
Backgrounds: 1200x800px (will scale to screen)
Items: 16-20x12-30px (varies by item)
Objects: Various sizes (see showAllDimensions() for details)

NOTE: All dimensions are at scale 1.0. The game will automatically scale 
based on screen size (CFG.SCALE), so your images should be at the base size.
*/
</script>
<!--
ASSET PACK SAMPLE (commented). To use, either:
  1) Paste your assets into the live block below with id="asset-pack" (kept empty by default)
  2) Or copy this sample, remove the HTML comments, and ensure the script id is exactly "asset-pack"

Notes:
- images values can be data URLs (base64) or https URLs.
- svgs values are raw <svg> strings and will be converted to data URLs automatically.
- lottie.birthday_art accepts an AE (Bodymovin) JSON object for the final drawing.
- To see available keys, open DevTools and run: window.listGraphics()

Example data URL PNG (your converter output is correct):
  data:image/png;base64,iVBORw0K... (very long string)

Example pack structure:
<script id="asset-pack" type="application/json">
{
  "images": {
    "birthday_art": "drawing.png",
    "gameover_default": "gameover_default.png"
  }
}
</script>
-->

<!-- Empty asset pack block; paste your pack JSON here when ready -->
<script id="asset-pack" type="application/json">
{
  "images": {
    "birthday_art": "drawing.png",
    "gameover_default": "gameover_default.png"
  }
}
</script>
<script id="prop-catalog" type="application/json">
{
  "props": {}
}
</script>

<!-- SVG Prop Importer (development helper) -->
<div id="propImporter" style="position:fixed; right:16px; top:16px; z-index:99998; background:rgba(0,0,0,0.82); color:#fff; padding:12px 14px; border-radius:12px; font:13px system-ui; width:280px; display:none; flex-direction:column; gap:8px; box-shadow:0 4px 18px rgba(0,0,0,0.35); backdrop-filter:blur(6px);" aria-hidden="true">
  <div style="font-weight:700; display:flex; align-items:center; justify-content:space-between;">
    <span>SVG Prop Importer</span>
    <button id="propImporterClose" type="button" style="background:none;border:none;color:#ccc;font-size:16px;cursor:pointer;">√ó</button>
  </div>
  <div style="font-size:12px; opacity:0.82; line-height:1.4;">Importer rekvisitter (isbjerge, borde, knapper, golfbolde) som SVG. Kr√¶ver <code>data-key</code> p√• hver gruppe.</div>
  <input id="propFiles" type="file" accept=".svg" multiple />
  <div style="display:flex; gap:8px;">
    <button id="btnImportProps" type="button">Import√©r</button>
    <button id="btnClearPropLog" type="button">Ryd log</button>
  </div>
  <pre id="propImportLog" style="margin:0; max-height:140px; overflow:auto; font-size:11px; background:rgba(255,255,255,0.06); padding:8px; border-radius:8px;">Ready.
</pre>
</div>

<script id="course-mar-a-lago" type="application/json">
{
  "name": "Mar-a-Lago Mini-Putt",
  "par": [],
  "holes": []
}
</script>

<!-- Shared SVG utilities -->
<script src="js/svg-utils.js"></script>

<!-- SVG importer registry and golf loader -->
<script src="js/svg-importers/index.js"></script>
<script src="js/svg-importers/golf.js"></script>

<!-- Prop Importer Logic -->
<script>
(function(){
  const SVG = window.SVGUTILS;
  if (!SVG) return;
  const container = document.getElementById('propImporter');
  if (!container) return;

  const fileInput = document.getElementById('propFiles');
  const importBtn = document.getElementById('btnImportProps');
  const clearBtn = document.getElementById('btnClearPropLog');
  const closeBtn = document.getElementById('propImporterClose');
  const logEl = document.getElementById('propImportLog');
  const serializer = new XMLSerializer();

  const { geometryToPolygon, polygonBounds, toNumericPoly } = SVG;

  function log(message){
    if (!logEl) return;
    logEl.textContent += message + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  function warn(message){ log('‚ö†Ô∏è ' + message); }

  function ensureCatalog(){
    let el = document.getElementById('prop-catalog');
    if (!el){
      el = document.createElement('script');
      el.id = 'prop-catalog';
      el.type = 'application/json';
      el.textContent = JSON.stringify({ props: {} }, null, 2);
      document.body.appendChild(el);
    }
    let data;
    try { data = JSON.parse(el.textContent || '{}'); }
    catch(_){ data = {}; }
    if (!data || typeof data !== 'object') data = {};
    if (!data.props || typeof data.props !== 'object') data.props = {};
    return { el, data };
  }

  function parseAnchor(value, fallback){
    if (typeof value !== 'string' || !value.trim()) return fallback;
    const parts = value.split(',').map(v => parseFloat(v.trim()));
    if (parts.length === 2 && parts.every(Number.isFinite)){
      return { x: parts[0], y: parts[1] };
    }
    return fallback;
  }

  function guessLevel(key){
    if (!key) return null;
    const lower = key.toLowerCase();
    if (lower.includes('greenland') || lower.includes('gl')) return 'greenland';
    if (lower.includes('oval') || lower.includes('whitehouse')) return 'oval';
    if (lower.includes('kremlin') || lower.includes('putin')) return 'kremlin';
    if (lower.includes('epstein') || lower.includes('island')) return 'epstein';
    if (lower.includes('golf')) return 'golf';
    return null;
  }

  function mergeBounds(base, next){
    if (!next) return base;
    if (!base) return { x: next.x, y: next.y, w: next.w, h: next.h };
    const minX = Math.min(base.x, next.x);
    const minY = Math.min(base.y, next.y);
    const maxX = Math.max(base.x + base.w, next.x + next.w);
    const maxY = Math.max(base.y + base.h, next.y + next.h);
    base.x = minX; base.y = minY; base.w = maxX - minX; base.h = maxY - minY;
    return base;
  }

  function serializeGroupToSvg(rootSvg, group, viewBoxStr){
    const clone = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    clone.setAttribute('viewBox', viewBoxStr);
    const defs = rootSvg.querySelector('defs');
    if (defs) clone.appendChild(defs.cloneNode(true));
    clone.appendChild(group.cloneNode(true));
    return serializer.serializeToString(clone);
  }

  function parsePropSvg(source, filename){
    const parser = new DOMParser();
    const doc = parser.parseFromString(source, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (!svg) throw new Error('SVG mangler <svg> rod');

    let viewBoxAttr = svg.getAttribute('viewBox');
    let viewBoxVals = viewBoxAttr ? viewBoxAttr.trim().split(/\s+/).map(Number) : null;
    if (!viewBoxVals || viewBoxVals.length !== 4 || viewBoxVals.some(v => Number.isNaN(v))){
      const width = parseFloat(svg.getAttribute('width') || '0') || 512;
      const height = parseFloat(svg.getAttribute('height') || '0') || 512;
      viewBoxVals = [0, 0, width, height];
      viewBoxAttr = viewBoxVals.join(' ');
    }

    const defaultLevel = svg.dataset.level || null;
    const groups = svg.querySelectorAll('[data-key]');
    const nodes = groups.length ? Array.from(groups) : [svg];
    const entries = [];

    nodes.forEach((node, idx) => {
      const baseName = (filename || 'prop').replace(/\.svg$/i, '');
      const key = node.dataset.key || (groups.length ? `${baseName || 'prop'}_${idx + 1}` : (baseName || `prop_${idx+1}`));
      const level = node.dataset.level || defaultLevel || guessLevel(key);

      const meta = {};
      Object.entries(node.dataset || {}).forEach(([k, v]) => {
        if (k === 'key' || k === 'level') return;
        meta[k] = v;
      });

      const shapes = node.querySelectorAll('path,polygon,polyline,rect,circle,ellipse,line');
      const polys = [];
      shapes.forEach(el => {
        try {
          const poly = geometryToPolygon(el, 6);
          if (poly && poly.length) polys.push(poly);
        } catch(err){ warn(`Geometri fejl i ${key}: ${err?.message || err}`); }
      });

      let bounds = null;
      polys.forEach(poly => {
        const b = polygonBounds(poly);
        if (b) bounds = mergeBounds(bounds, b);
      });
      if (!bounds){
        bounds = { x: viewBoxVals[0], y: viewBoxVals[1], w: viewBoxVals[2], h: viewBoxVals[3] };
      }

      const anchor = parseAnchor(node.dataset.anchor || svg.dataset.anchor || '', {
        x: bounds.x + bounds.w / 2,
        y: bounds.y + bounds.h
      });

      const hitboxes = [];
      node.querySelectorAll('[data-hitbox]').forEach(el => {
        try {
          const poly = geometryToPolygon(el, 6);
          if (poly && poly.length) hitboxes.push(toNumericPoly(poly));
        } catch(err){ warn(`Hitbox fejl i ${key}: ${err?.message || err}`); }
      });

      const svgString = serializeGroupToSvg(svg, node, viewBoxAttr);

      entries.push({
        key,
        level,
        source: filename,
        viewBox: viewBoxAttr,
        size: { width: bounds.w, height: bounds.h },
        origin: { x: bounds.x, y: bounds.y },
        anchor,
        hitboxes,
        meta,
        svg: svgString.trim()
      });
    });

    return entries;
  }

  async function handleImport(){
    try {
      const files = Array.from(fileInput?.files || []);
      if (!files.length){
        alert('V√¶lg mindst √©n SVG-fil');
        return;
      }
      const { el, data } = ensureCatalog();
      let count = 0;
      for (const file of files){
        const text = await file.text();
        const entries = parsePropSvg(text, file.name);
        entries.forEach(entry => {
          data.props[entry.key] = entry;
          count++;
          log(`‚úì ${entry.key} (${entry.level || 'scene-agnostisk'})`);
        });
      }
      el.textContent = JSON.stringify(data, null, 2);
      log(`F√¶rdig: ${count} prop(s) gemt.`);
    } catch(err){
      console.error(err);
      warn(err.message || String(err));
    }
  }

  if (importBtn) importBtn.addEventListener('click', handleImport);
  if (clearBtn) clearBtn.addEventListener('click', () => { if (logEl) { logEl.textContent = 'Log ryddet.\n'; } });
  if (closeBtn) closeBtn.addEventListener('click', () => { container.style.display = 'none'; });
})();
</script>
</body>
</html>
